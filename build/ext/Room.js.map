{
  "version": 3,
  "sources": ["../../node_modules/ms/index.js", "../../node_modules/debug/src/common.js", "../../node_modules/debug/src/browser.js", "../../node_modules/supports-color/index.js", "../../node_modules/debug/src/node.js", "../../node_modules/debug/src/index.js", "../../node_modules/detect-libc/lib/process.js", "../../node_modules/detect-libc/lib/filesystem.js", "../../node_modules/detect-libc/lib/detect-libc.js", "../../node_modules/node-gyp-build-optional-packages/node-gyp-build.js", "../../node_modules/node-gyp-build-optional-packages/index.js", "../../node_modules/msgpackr-extract/index.js", "../../node_modules/nanoid/random.js", "../../node_modules/nanoid/url.js", "../../node_modules/nanoid/index.js", "../../node_modules/@colyseus/timer/build/index.mjs", "../../node_modules/@colyseus/greeting-banner/build/index.mjs", "../../node_modules/@colyseus/core/build/Debug.mjs", "../../node_modules/@colyseus/core/build/Logger.mjs", "../../node_modules/@colyseus/msgpackr/unpack.js", "../../node_modules/@colyseus/msgpackr/pack.js", "../../node_modules/@colyseus/msgpackr/struct.js", "../../node_modules/@colyseus/msgpackr/node-index.js", "../../node_modules/@colyseus/schema/src/encoding/spec.ts", "../../node_modules/@colyseus/schema/src/symbol.shim.ts", "../../node_modules/@colyseus/schema/src/types/symbols.ts", "../../node_modules/@colyseus/schema/src/encoding/encode.ts", "../../node_modules/@colyseus/schema/src/encoding/decode.ts", "../../node_modules/@colyseus/schema/src/types/registry.ts", "../../node_modules/@colyseus/schema/src/types/TypeContext.ts", "../../node_modules/@colyseus/schema/src/Metadata.ts", "../../node_modules/@colyseus/schema/src/encoder/ChangeTree.ts", "../../node_modules/@colyseus/schema/src/encoder/EncodeOperation.ts", "../../node_modules/@colyseus/schema/src/decoder/DecodeOperation.ts", "../../node_modules/@colyseus/schema/src/encoding/assert.ts", "../../node_modules/@colyseus/schema/src/types/custom/ArraySchema.ts", "../../node_modules/@colyseus/schema/src/types/custom/MapSchema.ts", "../../node_modules/@colyseus/schema/src/annotations.ts", "../../node_modules/@colyseus/schema/src/utils.ts", "../../node_modules/@colyseus/schema/src/Schema.ts", "../../node_modules/@colyseus/schema/src/types/custom/CollectionSchema.ts", "../../node_modules/@colyseus/schema/src/types/custom/SetSchema.ts", "../../node_modules/@colyseus/schema/node_modules/tslib/tslib.es6.js", "../../node_modules/@colyseus/schema/src/types/utils.ts", "../../node_modules/@colyseus/schema/src/encoder/Root.ts", "../../node_modules/@colyseus/schema/src/encoder/Encoder.ts", "../../node_modules/@colyseus/schema/src/decoder/ReferenceTracker.ts", "../../node_modules/@colyseus/schema/src/decoder/Decoder.ts", "../../node_modules/@colyseus/schema/src/Reflection.ts", "../../node_modules/@colyseus/schema/src/decoder/strategy/StateCallbacks.ts", "../../node_modules/@colyseus/schema/src/decoder/strategy/RawChanges.ts", "../../node_modules/@colyseus/schema/src/encoder/StateView.ts", "../../node_modules/@colyseus/schema/src/index.ts", "../../node_modules/@colyseus/core/build/Protocol.mjs", "../../node_modules/@colyseus/core/build/errors/ServerError.mjs", "../../node_modules/@colyseus/core/build/MatchMaker.mjs", "../../node_modules/@colyseus/core/build/utils/Utils.mjs", "../../node_modules/@colyseus/core/build/utils/DevMode.mjs", "../../node_modules/@colyseus/core/build/Room.mjs", "../../node_modules/@colyseus/core/build/serializer/NoneSerializer.mjs", "../../node_modules/@colyseus/core/build/Transport.mjs", "../../node_modules/@colyseus/core/build/serializer/SchemaSerializer.mjs", "../../node_modules/@colyseus/core/build/errors/RoomExceptions.mjs", "../../node_modules/@colyseus/core/build/presence/LocalPresence.mjs", "../../node_modules/@colyseus/core/build/Stats.mjs", "../../node_modules/@colyseus/core/build/rooms/RelayRoom.mjs", "../../src-backend/ext/Room.ts"],
  "sourcesContent": ["/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n", "\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '')\n\t\t\t.trim()\n\t\t\t.replace(' ', ',')\n\t\t\t.split(',')\n\t\t\t.filter(Boolean);\n\n\t\tfor (const ns of split) {\n\t\t\tif (ns[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(ns.slice(1));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(ns);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */\n\tfunction matchesTemplate(search, template) {\n\t\tlet searchIndex = 0;\n\t\tlet templateIndex = 0;\n\t\tlet starIndex = -1;\n\t\tlet matchIndex = 0;\n\n\t\twhile (searchIndex < search.length) {\n\t\t\tif (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n\t\t\t\t// Match character or proceed with wildcard\n\t\t\t\tif (template[templateIndex] === '*') {\n\t\t\t\t\tstarIndex = templateIndex;\n\t\t\t\t\tmatchIndex = searchIndex;\n\t\t\t\t\ttemplateIndex++; // Skip the '*'\n\t\t\t\t} else {\n\t\t\t\t\tsearchIndex++;\n\t\t\t\t\ttemplateIndex++;\n\t\t\t\t}\n\t\t\t} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition\n\t\t\t\t// Backtrack to the last '*' and try to match more characters\n\t\t\t\ttemplateIndex = starIndex + 1;\n\t\t\t\tmatchIndex++;\n\t\t\t\tsearchIndex = matchIndex;\n\t\t\t} else {\n\t\t\t\treturn false; // No match\n\t\t\t}\n\t\t}\n\n\t\t// Handle trailing '*' in template\n\t\twhile (templateIndex < template.length && template[templateIndex] === '*') {\n\t\t\ttemplateIndex++;\n\t\t}\n\n\t\treturn templateIndex === template.length;\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names,\n\t\t\t...createDebug.skips.map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tfor (const skip of createDebug.skips) {\n\t\t\tif (matchesTemplate(name, skip)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const ns of createDebug.names) {\n\t\t\tif (matchesTemplate(name, ns)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n", "/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t// eslint-disable-next-line no-return-assign\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n", "'use strict';\nvar argv = process.argv;\n\nvar terminator = argv.indexOf('--');\nvar hasFlag = function (flag) {\n\tflag = '--' + flag;\n\tvar pos = argv.indexOf(flag);\n\treturn pos !== -1 && (terminator !== -1 ? pos < terminator : true);\n};\n\nmodule.exports = (function () {\n\tif ('FORCE_COLOR' in process.env) {\n\t\treturn true;\n\t}\n\n\tif (hasFlag('no-color') ||\n\t\thasFlag('no-colors') ||\n\t\thasFlag('color=false')) {\n\t\treturn false;\n\t}\n\n\tif (hasFlag('color') ||\n\t\thasFlag('colors') ||\n\t\thasFlag('color=true') ||\n\t\thasFlag('color=always')) {\n\t\treturn true;\n\t}\n\n\tif (process.stdout && !process.stdout.isTTY) {\n\t\treturn false;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn true;\n\t}\n\n\tif ('COLORTERM' in process.env) {\n\t\treturn true;\n\t}\n\n\tif (process.env.TERM === 'dumb') {\n\t\treturn false;\n\t}\n\n\tif (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n})();\n", "/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n", "/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n", "// Copyright 2017 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst isLinux = () => process.platform === 'linux';\n\nlet report = null;\nconst getReport = () => {\n  if (!report) {\n    /* istanbul ignore next */\n    if (isLinux() && process.report) {\n      const orig = process.report.excludeNetwork;\n      process.report.excludeNetwork = true;\n      report = process.report.getReport();\n      process.report.excludeNetwork = orig;\n    } else {\n      report = {};\n    }\n  }\n  return report;\n};\n\nmodule.exports = { isLinux, getReport };\n", "// Copyright 2017 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst fs = require('fs');\n\n/**\n * The path where we can find the ldd\n */\nconst LDD_PATH = '/usr/bin/ldd';\n\n/**\n * Read the content of a file synchronous\n *\n * @param {string} path\n * @returns {string}\n */\nconst readFileSync = (path) => fs.readFileSync(path, 'utf-8');\n\n/**\n * Read the content of a file\n *\n * @param {string} path\n * @returns {Promise<string>}\n */\nconst readFile = (path) => new Promise((resolve, reject) => {\n  fs.readFile(path, 'utf-8', (err, data) => {\n    if (err) {\n      reject(err);\n    } else {\n      resolve(data);\n    }\n  });\n});\n\nmodule.exports = {\n  LDD_PATH,\n  readFileSync,\n  readFile\n};\n", "// Copyright 2017 Lovell Fuller and others.\n// SPDX-License-Identifier: Apache-2.0\n\n'use strict';\n\nconst childProcess = require('child_process');\nconst { isLinux, getReport } = require('./process');\nconst { LDD_PATH, readFile, readFileSync } = require('./filesystem');\n\nlet cachedFamilyFilesystem;\nlet cachedVersionFilesystem;\n\nconst command = 'getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true';\nlet commandOut = '';\n\nconst safeCommand = () => {\n  if (!commandOut) {\n    return new Promise((resolve) => {\n      childProcess.exec(command, (err, out) => {\n        commandOut = err ? ' ' : out;\n        resolve(commandOut);\n      });\n    });\n  }\n  return commandOut;\n};\n\nconst safeCommandSync = () => {\n  if (!commandOut) {\n    try {\n      commandOut = childProcess.execSync(command, { encoding: 'utf8' });\n    } catch (_err) {\n      commandOut = ' ';\n    }\n  }\n  return commandOut;\n};\n\n/**\n * A String constant containing the value `glibc`.\n * @type {string}\n * @public\n */\nconst GLIBC = 'glibc';\n\n/**\n * A Regexp constant to get the GLIBC Version.\n * @type {string}\n */\nconst RE_GLIBC_VERSION = /LIBC[a-z0-9 \\-).]*?(\\d+\\.\\d+)/i;\n\n/**\n * A String constant containing the value `musl`.\n * @type {string}\n * @public\n */\nconst MUSL = 'musl';\n\nconst isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-');\n\nconst familyFromReport = () => {\n  const report = getReport();\n  if (report.header && report.header.glibcVersionRuntime) {\n    return GLIBC;\n  }\n  if (Array.isArray(report.sharedObjects)) {\n    if (report.sharedObjects.some(isFileMusl)) {\n      return MUSL;\n    }\n  }\n  return null;\n};\n\nconst familyFromCommand = (out) => {\n  const [getconf, ldd1] = out.split(/[\\r\\n]+/);\n  if (getconf && getconf.includes(GLIBC)) {\n    return GLIBC;\n  }\n  if (ldd1 && ldd1.includes(MUSL)) {\n    return MUSL;\n  }\n  return null;\n};\n\nconst getFamilyFromLddContent = (content) => {\n  if (content.includes('musl')) {\n    return MUSL;\n  }\n  if (content.includes('GNU C Library')) {\n    return GLIBC;\n  }\n  return null;\n};\n\nconst familyFromFilesystem = async () => {\n  if (cachedFamilyFilesystem !== undefined) {\n    return cachedFamilyFilesystem;\n  }\n  cachedFamilyFilesystem = null;\n  try {\n    const lddContent = await readFile(LDD_PATH);\n    cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);\n  } catch (e) {}\n  return cachedFamilyFilesystem;\n};\n\nconst familyFromFilesystemSync = () => {\n  if (cachedFamilyFilesystem !== undefined) {\n    return cachedFamilyFilesystem;\n  }\n  cachedFamilyFilesystem = null;\n  try {\n    const lddContent = readFileSync(LDD_PATH);\n    cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);\n  } catch (e) {}\n  return cachedFamilyFilesystem;\n};\n\n/**\n * Resolves with the libc family when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\nconst family = async () => {\n  let family = null;\n  if (isLinux()) {\n    family = await familyFromFilesystem();\n    if (!family) {\n      family = familyFromReport();\n    }\n    if (!family) {\n      const out = await safeCommand();\n      family = familyFromCommand(out);\n    }\n  }\n  return family;\n};\n\n/**\n * Returns the libc family when it can be determined, `null` otherwise.\n * @returns {?string}\n */\nconst familySync = () => {\n  let family = null;\n  if (isLinux()) {\n    family = familyFromFilesystemSync();\n    if (!family) {\n      family = familyFromReport();\n    }\n    if (!family) {\n      const out = safeCommandSync();\n      family = familyFromCommand(out);\n    }\n  }\n  return family;\n};\n\n/**\n * Resolves `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {Promise<boolean>}\n */\nconst isNonGlibcLinux = async () => isLinux() && await family() !== GLIBC;\n\n/**\n * Returns `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {boolean}\n */\nconst isNonGlibcLinuxSync = () => isLinux() && familySync() !== GLIBC;\n\nconst versionFromFilesystem = async () => {\n  if (cachedVersionFilesystem !== undefined) {\n    return cachedVersionFilesystem;\n  }\n  cachedVersionFilesystem = null;\n  try {\n    const lddContent = await readFile(LDD_PATH);\n    const versionMatch = lddContent.match(RE_GLIBC_VERSION);\n    if (versionMatch) {\n      cachedVersionFilesystem = versionMatch[1];\n    }\n  } catch (e) {}\n  return cachedVersionFilesystem;\n};\n\nconst versionFromFilesystemSync = () => {\n  if (cachedVersionFilesystem !== undefined) {\n    return cachedVersionFilesystem;\n  }\n  cachedVersionFilesystem = null;\n  try {\n    const lddContent = readFileSync(LDD_PATH);\n    const versionMatch = lddContent.match(RE_GLIBC_VERSION);\n    if (versionMatch) {\n      cachedVersionFilesystem = versionMatch[1];\n    }\n  } catch (e) {}\n  return cachedVersionFilesystem;\n};\n\nconst versionFromReport = () => {\n  const report = getReport();\n  if (report.header && report.header.glibcVersionRuntime) {\n    return report.header.glibcVersionRuntime;\n  }\n  return null;\n};\n\nconst versionSuffix = (s) => s.trim().split(/\\s+/)[1];\n\nconst versionFromCommand = (out) => {\n  const [getconf, ldd1, ldd2] = out.split(/[\\r\\n]+/);\n  if (getconf && getconf.includes(GLIBC)) {\n    return versionSuffix(getconf);\n  }\n  if (ldd1 && ldd2 && ldd1.includes(MUSL)) {\n    return versionSuffix(ldd2);\n  }\n  return null;\n};\n\n/**\n * Resolves with the libc version when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\nconst version = async () => {\n  let version = null;\n  if (isLinux()) {\n    version = await versionFromFilesystem();\n    if (!version) {\n      version = versionFromReport();\n    }\n    if (!version) {\n      const out = await safeCommand();\n      version = versionFromCommand(out);\n    }\n  }\n  return version;\n};\n\n/**\n * Returns the libc version when it can be determined, `null` otherwise.\n * @returns {?string}\n */\nconst versionSync = () => {\n  let version = null;\n  if (isLinux()) {\n    version = versionFromFilesystemSync();\n    if (!version) {\n      version = versionFromReport();\n    }\n    if (!version) {\n      const out = safeCommandSync();\n      version = versionFromCommand(out);\n    }\n  }\n  return version;\n};\n\nmodule.exports = {\n  GLIBC,\n  MUSL,\n  family,\n  familySync,\n  isNonGlibcLinux,\n  isNonGlibcLinuxSync,\n  version,\n  versionSync\n};\n", "var fs = require('fs')\nvar path = require('path')\nvar url = require('url')\nvar os = require('os')\n// Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'\nvar runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require // eslint-disable-line\n\nvar vars = (process.config && process.config.variables) || {}\nvar prebuildsOnly = !!process.env.PREBUILDS_ONLY\nvar versions = process.versions\nvar abi = versions.modules\nif (versions.deno || process.isBun) {\n  // both Deno and Bun made the very poor decision to shoot themselves in the foot and lie about support for ABI\n  // (which they do not have)\n  abi = 'unsupported'\n}\nvar runtime = isElectron() ? 'electron' : (isNwjs() ? 'node-webkit' : 'node')\nvar arch = process.env.npm_config_arch || os.arch()\nvar platform = process.env.npm_config_platform || os.platform()\nvar libc = process.env.LIBC || (isMusl(platform) ? 'musl' : 'glibc')\n\nvar armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''\nvar uv = (versions.uv || '').split('.')[0]\n\nmodule.exports = load\n\nfunction load (dir) {\n  return runtimeRequire(load.resolve(dir))\n}\n\nload.resolve = load.path = function (dir) {\n  dir = path.resolve(dir || '.')\n  var packageName = ''\n  var packageNameError\n  try {\n    packageName = runtimeRequire(path.join(dir, 'package.json')).name;\n    var varName = packageName.toUpperCase().replace(/-/g, '_')\n    if (process.env[varName + '_PREBUILD']) dir = process.env[varName + '_PREBUILD']\n  } catch (err) {\n    packageNameError = err;\n  }\n  if (!prebuildsOnly) {\n    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n    if (release) return release\n\n    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n    if (debug) return debug\n  }\n\n  var prebuild = resolve(dir)\n  if (prebuild) return prebuild\n\n  var nearby = resolve(path.dirname(process.execPath))\n  if (nearby) return nearby\n\n  var platformPackage = (packageName[0] == '@' ? '' : '@' + packageName + '/') + packageName + '-' + platform + '-' + arch\n  var packageResolutionError\n  try {\n    var prebuildPackage = path.dirname(require('module').createRequire(url.pathToFileURL(path.join(dir, 'package.json'))).resolve(platformPackage))\n    return resolveFile(prebuildPackage)\n  } catch(error) {\n    packageResolutionError = error\n  }\n\n  var target = [\n    'platform=' + platform,\n    'arch=' + arch,\n    'runtime=' + runtime,\n    'abi=' + abi,\n    'uv=' + uv,\n    armv ? 'armv=' + armv : '',\n    'libc=' + libc,\n    'node=' + process.versions.node,\n    process.versions.electron ? 'electron=' + process.versions.electron : '',\n    typeof __webpack_require__ === 'function' ? 'webpack=true' : '' // eslint-disable-line\n  ].filter(Boolean).join(' ')\n  let errMessage = 'No native build was found for ' + target + '\\n    attempted loading from: ' + dir + ' and package:' +\n    ' ' + platformPackage + '\\n';\n  if (packageNameError) {\n    errMessage += 'Error finding package.json: ' + packageNameError.message + '\\n';\n  }\n  if (packageResolutionError) {\n    errMessage += 'Error resolving package: ' + packageResolutionError.message + '\\n';\n  }\n  throw new Error(errMessage)\n\n  function resolve (dir) {\n    // Find matching \"prebuilds/<platform>-<arch>\" directory\n    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple)\n    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0]\n    if (!tuple) return\n    return resolveFile(path.join(dir, 'prebuilds', tuple.name))\n  }\n  function resolveFile (prebuilds) {\n    // Find most specific flavor first\n    var parsed = readdirSync(prebuilds).map(parseTags)\n    var candidates = parsed.filter(matchTags(runtime, abi))\n    var winner = candidates.sort(compareTags(runtime))[0]\n    if (winner) return path.join(prebuilds, winner.file)\n  }\n}\n\nfunction readdirSync (dir) {\n  try {\n    return fs.readdirSync(dir)\n  } catch (err) {\n    return []\n  }\n}\n\nfunction getFirst (dir, filter) {\n  var files = readdirSync(dir).filter(filter)\n  return files[0] && path.join(dir, files[0])\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction parseTuple (name) {\n  // Example: darwin-x64+arm64\n  var arr = name.split('-')\n  if (arr.length !== 2) return\n\n  var platform = arr[0]\n  var architectures = arr[1].split('+')\n\n  if (!platform) return\n  if (!architectures.length) return\n  if (!architectures.every(Boolean)) return\n\n  return { name, platform, architectures }\n}\n\nfunction matchTuple (platform, arch) {\n  return function (tuple) {\n    if (tuple == null) return false\n    if (tuple.platform !== platform) return false\n    return tuple.architectures.includes(arch)\n  }\n}\n\nfunction compareTuples (a, b) {\n  // Prefer single-arch prebuilds over multi-arch\n  return a.architectures.length - b.architectures.length\n}\n\nfunction parseTags (file) {\n  var arr = file.split('.')\n  var extension = arr.pop()\n  var tags = { file: file, specificity: 0 }\n\n  if (extension !== 'node') return\n\n  for (var i = 0; i < arr.length; i++) {\n    var tag = arr[i]\n\n    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {\n      tags.runtime = tag\n    } else if (tag === 'napi') {\n      tags.napi = true\n    } else if (tag.slice(0, 3) === 'abi') {\n      tags.abi = tag.slice(3)\n    } else if (tag.slice(0, 2) === 'uv') {\n      tags.uv = tag.slice(2)\n    } else if (tag.slice(0, 4) === 'armv') {\n      tags.armv = tag.slice(4)\n    } else if (tag === 'glibc' || tag === 'musl') {\n      tags.libc = tag\n    } else {\n      continue\n    }\n\n    tags.specificity++\n  }\n\n  return tags\n}\n\nfunction matchTags (runtime, abi) {\n  return function (tags) {\n    if (tags == null) return false\n    if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false\n    if (tags.abi !== abi && !tags.napi) return false\n    if (tags.uv && tags.uv !== uv) return false\n    if (tags.armv && tags.armv !== armv) return false\n    if (tags.libc && tags.libc !== libc) return false\n\n    return true\n  }\n}\n\nfunction runtimeAgnostic (tags) {\n  return tags.runtime === 'node' && tags.napi\n}\n\nfunction compareTags (runtime) {\n  // Precedence: non-agnostic runtime, abi over napi, then by specificity.\n  return function (a, b) {\n    if (a.runtime !== b.runtime) {\n      return a.runtime === runtime ? -1 : 1\n    } else if (a.abi !== b.abi) {\n      return a.abi ? -1 : 1\n    } else if (a.specificity !== b.specificity) {\n      return a.specificity > b.specificity ? -1 : 1\n    } else {\n      return 0\n    }\n  }\n}\n\nfunction isNwjs () {\n  return !!(process.versions && process.versions.nw)\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n\nfunction isMusl (platform) {\n  if (platform !== 'linux') return false;\n  const { familySync, MUSL } = require('detect-libc');\n  return familySync() === MUSL;\n}\n\n// Exposed for unit tests\n// TODO: move to lib\nload.parseTags = parseTags\nload.matchTags = matchTags\nload.compareTags = compareTags\nload.parseTuple = parseTuple\nload.matchTuple = matchTuple\nload.compareTuples = compareTuples\n\n", "const runtimeRequire = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require // eslint-disable-line\nif (typeof runtimeRequire.addon === 'function') { // if the platform supports native resolving prefer that\n  module.exports = runtimeRequire.addon.bind(runtimeRequire)\n} else { // else use the runtime version here\n  module.exports = require('./node-gyp-build.js')\n}\n", "module.exports = require('node-gyp-build-optional-packages')(__dirname);", "var crypto = require('crypto')\n\nif (crypto.randomFillSync) {\n  // We reuse buffers with the same size to avoid memory fragmentations\n  // for better performance\n  var buffers = { }\n  module.exports = function (bytes) {\n    var buffer = buffers[bytes]\n    if (!buffer) {\n      // `Buffer.allocUnsafe()` faster because it don\u2019t clean memory.\n      // We do not need it, since we will fill memory with new bytes anyway.\n      buffer = Buffer.allocUnsafe(bytes)\n      if (bytes <= 255) buffers[bytes] = buffer\n    }\n    return crypto.randomFillSync(buffer)\n  }\n} else {\n  module.exports = crypto.randomBytes\n}\n", "// This alphabet uses a-z A-Z 0-9 _- symbols.\n// Despite the fact the source code is quite long, its entropy\n// is low and there are lots of duplicates - just what compressors\n// like GZIP and Brotli likes the best.\n\n/**\n * URL safe symbols.\n *\n * @name url\n * @type {string}\n *\n * @example\n * const url = require('nanoid/url')\n * generate(url, 10) //=> \"Uakgb_J5m9\"\n */\n\n// This alphabet uses a-z A-Z 0-9 _- symbols.\n// Symbols are generated for smaller size.\n// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA\nmodule.exports = '-_'\nvar i = 36\nwhile (i--) {\n  // 36 is radix. Number.prototype.toString(36) returns number\n  // in Base36 representation. Base36 is like hex, but it uses 0\u20139 and a-z.\n  module.exports += i.toString(36)\n  i > 9 && (module.exports += i.toString(36).toUpperCase())\n}\n", "var random = require('./random')\nvar url = require('./url')\n\n/**\n * Generate secure URL-friendly unique ID.\n *\n * By default, ID will have 21 symbols to have a collision probability similar\n * to UUID v4.\n *\n * @param {number} [size=21] The number of symbols in ID.\n *\n * @return {string} Random string.\n *\n * @example\n * const nanoid = require('nanoid')\n * model.id = nanoid() //=> \"Uakgb_J5m9g-0JDMbcJqL\"\n *\n * @name nanoid\n * @function\n */\nmodule.exports = function (size) {\n  size = size || 21\n  var bytes = random(size)\n  var id = ''\n  // Compact alternative for `for (var i = 0; i < size; i++)`\n  while (size--) {\n    // We can\u2019t use bytes bigger than the alphabet. 63 is 00111111 bitmask.\n    // This mask reduces random byte 0-255 to 0-63 values.\n    // There is no need in `|| ''` and `* 1.6` hacks in here,\n    // because bitmask trim bytes exact to alphabet size.\n    id += url[bytes[size] & 63]\n  }\n  return id\n}\n", "// src/Delayed.ts\nvar Type = /* @__PURE__ */ ((Type2) => {\n  Type2[Type2[\"Interval\"] = 0] = \"Interval\";\n  Type2[Type2[\"Timeout\"] = 1] = \"Timeout\";\n  Type2[Type2[\"Async\"] = 2] = \"Async\";\n  return Type2;\n})(Type || {});\nvar Delayed = class {\n  constructor(handler, args, time, type) {\n    this.active = true;\n    this.paused = false;\n    this.elapsedTime = 0;\n    this.handler = handler;\n    this.args = args;\n    this.time = time;\n    this.type = type;\n  }\n  tick(deltaTime) {\n    if (this.paused) {\n      return;\n    }\n    this.elapsedTime += deltaTime;\n    if (this.elapsedTime >= this.time) {\n      this.execute();\n    }\n  }\n  execute() {\n    this.handler.apply(this, this.args);\n    switch (this.type) {\n      case 1 /* Timeout */:\n      case 2 /* Async */:\n        this.active = false;\n        break;\n      case 0 /* Interval */:\n        this.elapsedTime -= this.time;\n        break;\n    }\n  }\n  reset() {\n    this.elapsedTime = 0;\n  }\n  pause() {\n    this.paused = true;\n  }\n  resume() {\n    this.paused = false;\n  }\n  clear() {\n    this.active = false;\n  }\n};\n\n// src/TimerClearedError.ts\nvar TimerClearedError = class extends Error {\n  constructor() {\n    super(\"Timer has been cleared\");\n  }\n};\n\n// node_modules/@colyseus/clock/build/index.mjs\nvar Clock = class {\n  // number or NodeJS.Timer\n  constructor(useInterval = false) {\n    this.running = false;\n    this.now = typeof window !== \"undefined\" && window.performance && window.performance.now && window.performance.now.bind(window.performance) || Date.now;\n    this.start(useInterval);\n  }\n  start(useInterval = false) {\n    this.deltaTime = 0;\n    this.currentTime = this.now();\n    this.elapsedTime = 0;\n    this.running = true;\n    if (useInterval) {\n      this._interval = setInterval(this.tick.bind(this), 1e3 / 60);\n    }\n  }\n  stop() {\n    this.running = false;\n    if (this._interval) {\n      clearInterval(this._interval);\n    }\n  }\n  tick(newTime = this.now()) {\n    this.deltaTime = newTime - this.currentTime;\n    this.currentTime = newTime;\n    this.elapsedTime += this.deltaTime;\n  }\n};\n\n// src/ClockTimer.ts\nvar ClockTimer = class extends Clock {\n  constructor(autoStart = false) {\n    super(autoStart);\n    /**\n     * An array of all the scheduled timeouts and intervals.\n     * @private For compatibility it's public but avoid modifying it directly.\n     */\n    this.delayed = [];\n  }\n  /**\n   * Re-evaluate all the scheduled timeouts and intervals and execute appropriate handlers.\n   * Use this in your own context or not if your passed `autoStart` as `true` in the constructor.\n   */\n  tick() {\n    super.tick();\n    let delayedList = this.delayed;\n    let i = delayedList.length;\n    while (i--) {\n      const delayed = delayedList[i];\n      if (delayed.active) {\n        delayed.tick(this.deltaTime);\n      } else {\n        delayedList.splice(i, 1);\n        continue;\n      }\n    }\n  }\n  /**\n   * Schedule a function to be called every `time` milliseconds.\n   * This `time` minimum value will be tied to the `tick` method of the clock. This means if you use the default `autoStart` value from the constructor, the minimum value will be 16ms. Otherwise it will depend on your `tick` method call.\n   *\n   * Returns a {@link Delayed} object that can be used to clear the timeout or play around with it.\n   */\n  setInterval(handler, time, ...args) {\n    const delayed = new Delayed(handler, args, time, 0 /* Interval */);\n    this.delayed.push(delayed);\n    return delayed;\n  }\n  /**\n   * Schedule a function to be called after a delay.\n   *\n   * This `time` minimum value will be tied to the `tick` method of the clock. This means if you use the default `autoStart` value from the constructor, the minimum value will be 16ms. Otherwise it will depend on your `tick` method call.\n   *\n   * Returns a {@link Delayed} object that can be used to clear the timeout or play around with it.\n   */\n  setTimeout(handler, time, ...args) {\n    const delayed = new Delayed(handler, args, time, 1 /* Timeout */);\n    this.delayed.push(delayed);\n    return delayed;\n  }\n  /**\n   * A promise that schedule a timeout that will resolves after the given time.\n   *\n   * If the {@link Delayed} instance is cleared before the time, the promise will be rejected. This happens when the {@link ClockTimer.clear} method is called.\n   *\n   * For the sake of simplicity of this API, you can only cancel a timeout scheduled with this method with {@link ClockTimer.clear} method (which clears all scheduled timeouts and intervals).\n   * If you need fine-tuned control over the timeout, use the {@link ClockTimer.setTimeout} method instead.\n   *\n   * @example **Inside an async function**\n   * ```typescript\n   * const timer = new Clock(true);\n   * await timer.duration(1000);\n   * console.log(\"1 second later\");\n   * ```\n   *\n   * @example **Using the promise**\n   * ```typescript\n   * const timer = new Clock(true);\n   * timer.duration(1000).then(() => console.log(\"1 second later\"));\n   * ```\n   *\n   * @example **Using the promise with error**\n   * ```typescript\n   * const timer = new Clock(true);\n   * timer.duration(1000).then(() => console.log(\"1 second later\")).catch(() => console.log(\"Timer cleared\"));\n   * timer.clear();\n   * ```\n   *\n   *\n   * @param ms the duration in milliseconds in which the promise will be resolved\n   */\n  duration(ms) {\n    return new Promise((resolve, reject) => {\n      const delayed = new Delayed(resolve, void 0, ms, 2 /* Async */);\n      delayed.clear = () => {\n        delayed.active = false;\n        reject(new TimerClearedError());\n      };\n      this.delayed.push(delayed);\n    });\n  }\n  /**\n   * Delete any scheduled timeout or interval. That will never be executed.\n   *\n   * If some of the timeouts/intervals are already executed, they will be removed from the list and callback will be garbage collected.\n   * For timeout created with {@link ClockTimer.duration}, the promise will be rejected and therefore the unused resolving callback will be garbage collected.\n   */\n  clear() {\n    let i = this.delayed.length;\n    while (i--) {\n      this.delayed[i].clear();\n    }\n    this.delayed = [];\n  }\n};\n\n// src/index.ts\nvar src_default = ClockTimer;\nexport {\n  Delayed,\n  TimerClearedError,\n  Type,\n  src_default as default\n};\n", "// packages/greeting-banner/src/index.ts\nvar index_default = process.env.COLYSEUS_CLOUD ? String.raw`\n   ______      __                              ________                __\n  / ____/___  / /_  __________  __  _______   / ____/ /___  __  ______/ /\n / /   / __ \\/ / / / / ___/ _ \\/ / / / ___/  / /   / / __ \\/ / / / __  /\n/ /___/ /_/ / / /_/ (__  )  __/ /_/ (__  )  / /___/ / /_/ / /_/ / /_/ /\n\\____/\\____/_/\\__, /____/\\___/\\__,_/____/   \\____/_/\\____/\\__,_/\\__,_/\n             /____/\n\n\u2753 Don't hesitate to contact support@colyseus.io if you have any issues.\n\uD83D\uDE80 Thank you for using Colyseus Cloud\n` : String.raw`\n       ___      _\n      / __\\___ | |_   _ ___  ___ _   _ ___\n     / /  / _ \\| | | | / __|/ _ \\ | | / __|\n    / /__| (_) | | |_| \\__ \\  __/ |_| \\__ \\\n    \\____/\\___/|_|\\__, |___/\\___|\\__,_|___/\n                  |___/\n\n     \u00B7 Multiplayer Framework for Node.js \u00B7\n\n\uD83D\uDC96 Consider becoming a Sponsor on GitHub \u2192 https://github.com/sponsors/endel\n\uD83C\uDF1F Give us a star on GitHub \u2192 https://github.com/colyseus/colyseus\n\u2601\uFE0F  Deploy and scale your project on Colyseus Cloud \u2192 https://cloud.colyseus.io\n\n`;\nexport {\n  index_default as default\n};\n", "// packages/core/src/Debug.ts\nimport debug from \"debug\";\nimport { logger } from \"./Logger.mjs\";\nimport { ServerError } from \"./errors/ServerError.mjs\";\nvar debugConnection = debug(\"colyseus:connection\");\nvar debugDriver = debug(\"colyseus:driver\");\nvar debugError = debug(\"colyseus:errors\");\nvar debugMatchMaking = debug(\"colyseus:matchmaking\");\nvar debugMessage = debug(\"colyseus:message\");\nvar debugPatch = debug(\"colyseus:patch\");\nvar debugPresence = debug(\"colyseus:presence\");\nvar debugAndPrintError = (e) => {\n  const message = e instanceof Error ? e.stack : e;\n  if (!(e instanceof ServerError)) {\n    logger.error(message);\n  }\n  debugError.call(debugError, message);\n};\nexport {\n  debugAndPrintError,\n  debugConnection,\n  debugDriver,\n  debugError,\n  debugMatchMaking,\n  debugMessage,\n  debugPatch,\n  debugPresence\n};\n", "// packages/core/src/Logger.ts\nvar Logger = class {\n  debug(...args) {\n    logger.debug(...args);\n  }\n  error(...args) {\n    logger.error(...args);\n  }\n  info(...args) {\n    logger.info(...args);\n  }\n  trace(...args) {\n    logger.trace(...args);\n  }\n  warn(...args) {\n    logger.warn(...args);\n  }\n};\nvar logger = console;\nfunction setLogger(instance) {\n  logger = instance;\n}\nexport {\n  Logger,\n  logger,\n  setLogger\n};\n", "var decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nvar src\nvar srcEnd\nvar position = 0\nvar alreadySet\nconst EMPTY_ARRAY = []\nvar strings = EMPTY_ARRAY\nvar stringPosition = 0\nvar currentUnpackr = {}\nvar currentStructures\nvar srcString\nvar srcStringStart = 0\nvar srcStringEnd = 0\nvar bundledStrings\nvar referenceMap\nvar currentExtensions = []\nvar dataView\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nexport class C1Type {}\nexport const C1 = new C1Type()\nC1.name = 'MessagePack 0xC1'\nvar sequentialMode = false\nvar inlineObjectReadThreshold = 2\nvar readStruct, onLoadedStructures, onSaveState\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\nexport class Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = []\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number'\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (!source.buffer && source.constructor === ArrayBuffer)\n\t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length\n\t\t\tposition = options.start || 0\n\t\t} else {\n\t\t\tposition = 0\n\t\t\tsrcEnd = options > -1 ? options : source.length\n\t\t}\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tsequentialMode = true\n\t\t\tlet size = source.length\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value, lastPosition, position) === false) return;\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead(), lastPosition, position) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures)\n\t\t\tloadedStructures = onLoadedStructures.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || []\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0))\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i]\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id]\n\t\t\t\tlet existing = existingStructures[id]\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure\n\t\t\t\t\tloadedStructures[id] = existing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, options) {\n\t\treturn this.unpack(source, options)\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength\n\t\t}\n\t\tlet result\n\t\tif (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n\t\t\tresult = readStruct(src, position, srcEnd, currentUnpackr)\n\t\t\tsrc = null // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON()\n\t\t\tposition = srcEnd\n\t\t} else\n\t\t\tresult = read()\n\t\tif (bundledStrings) { // bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition\n\t\t\tbundledStrings = null\n\t\t}\n\t\tif (sequentialMode)\n\t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n\t\t\t// we can clear this out and keep the structures we read\n\t\t\tcurrentStructures.restoreStructures = null\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures()\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tlet jsonView;\n\t\t\ttry {\n\t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100)\n\t\t\t} catch(error) {\n\t\t\t\tjsonView = '(JSON view not available ' + error + ')'\n\t\t\t}\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures()\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id]\n\t}\n\tcurrentStructures.restoreStructures = null\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f]\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f)\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey()\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_'\n\t\t\t\t\tobject[key] = read()\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map()\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read())\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90\n\t\t\tlet array = new Array(token)\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read()\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0\n\t\tif (srcStringEnd >= position) {\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\tvalue = read() // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position)\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value]\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position, ++position))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition++\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f, src[position++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\n\t\t\t\t\terror.incomplete = true\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read)\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {}\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i]\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_'\n\t\t\tobject[key] = read()\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position++]\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)\n\t\tlet structure = currentStructures[id] || loadStructures()[id]\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId)\n\t\treturn structure.read()\n\t}\n}\n\nexport function loadStructures() {\n\tlet loadedStructures = saveState(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null\n\t\treturn currentUnpackr.getStructures()\n\t})\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS\nvar readString8 = readStringJS\nvar readString16 = readStringJS\nvar readString32 = readStringJS\nexport let isNativeAccelerationEnabled = false\n\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset\n\t\t\t\tlet extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nexport function readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read()\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey()\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read()\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map()\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read())\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition = start\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position++]\n\tlet length\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\tlet end\n\t\treturn currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {\n\t\t\tposition = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn asSafeString(read())\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nfunction asSafeString(property) {\n\t// protect against expensive (DoS) string conversions\n\tif (typeof property === 'string') return property;\n\tif (typeof property === 'number' || typeof property === 'boolean' || typeof property === 'bigint') return property.toString();\n\tif (property == null) return property + '';\n\tthrow new Error('Invalid property type for record', typeof property);\n}\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(asSafeString) // ensure that all keys are strings and\n\t// that the array is mutable\n\tlet firstByte = id\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)\n\t\tstructure.highByte = highByte\n\t}\n\tlet existingStructure = currentStructures[id]\n\t// If it is a shared structure, we need to restore any changes after reading.\n\t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n\t// to the state prior to an incomplete read in order to properly resume.\n\tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\tstructure.read = createStructureReader(structure, firstByte)\n\treturn structure.read()\n}\ncurrentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true\n\ncurrentExtensions[0x42] = (data) => {\n\t// decode bigint\n\tlet length = data.length;\n\tlet value = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0]);\n\tfor (let i = 1; i < length; i++) {\n\t\tvalue <<= 8n;\n\t\tvalue += BigInt(data[i]);\n\t}\n\treturn value;\n}\n\nlet errors = { Error, TypeError, ReferenceError };\ncurrentExtensions[0x65] = () => {\n\tlet data = read()\n\treturn (errors[data[0]] || Error)(data[1], { cause: data[2] })\n}\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tif (!referenceMap)\n\t\treferenceMap = new Map()\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[0x73] = () => new Set(read())\n\nexport const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\n\nlet glbl = typeof globalThis === 'object' ? globalThis : window;\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0]\n\tlet typedArrayName = typedArrays[typeCode]\n\tif (!typedArrayName) {\n\t\tif (typeCode === 16) {\n\t\t\tlet ab = new ArrayBuffer(data.length - 1)\n\t\t\tlet u8 = new Uint8Array(ab)\n\t\t\tu8.set(data.subarray(1))\n\t\t\treturn ab;\n\t\t}\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t}\n\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n\treturn new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer)\n}\ncurrentExtensions[0x78] = () => {\n\tlet data = read()\n\treturn new RegExp(data[0], data[1])\n}\nconst TEMP_BUNDLE = []\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]\n\tlet dataPosition = position\n\tposition += dataSize - data.length\n\tbundledStrings = TEMP_BUNDLE\n\tbundledStrings = [readOnlyJSString(), readOnlyJSString()]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)// TODO: Implement support for negative\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n} // notepack defines extension 0 to mean undefined, so use that as the default here\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length)\n\tlet savedPackr = currentUnpackr\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents)\n\tcurrentUnpackr = savedPackr\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack\n\telse\n\t\tcurrentExtensions[extension.type] = extension\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nexport const Decoder = Unpackr\nvar defaultUnpackr = new Unpackr({ useRecords: false })\nexport const unpack = defaultUnpackr.unpack\nexport const unpackMultiple = defaultUnpackr.unpackMultiple\nexport const decode = defaultUnpackr.unpack\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nexport function setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct = updatedReadStruct;\n\tonLoadedStructures = loadedStructs;\n\tonSaveState = saveState;\n}\n", "import { Unpackr, mult10, C1Type, typedArrays, addExtension as unpackAddExtension } from './unpack.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet target, keysTarget\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nlet writeStructSlots\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nexport const RECORD_SYMBOL = Symbol('record-id')\nexport class Packr extends Unpackr {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, 0xffffffff)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet packr = this\n\t\tif (!options)\n\t\t\toptions = {}\n\t\tlet isSequential = options && options.sequential\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = []\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)\n\t\tlet sharedLimitId = maxSharedStructures + 0x40\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end,\n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff)\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\t\t\tstructures = packr.structures\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures())\n\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i]\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tlet encodingError;\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value)\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0)\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tpackr.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} catch(error) {\n\t\t\t\tencodingError = error;\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tresetStructures();\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n\t\t\t\t\t\tif (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time\n\t\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\t\treturn packr.pack(value, encodeOptions)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength\n\t\t\t\t\t\t\t// don't keep large buffers around\n\t\t\t\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// don't keep large buffers around, they take too much memory and cause problems (limit at 1GB)\n\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tconst resetStructures = () => {\n\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\tif (structures.length > sharedLength && !isSequential)\n\t\t\t\tstructures.length = sharedLength\n\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\tstructures.transitions = null\n\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\ttransitionsCount = 0\n\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\trecordIdsToRemove = []\n\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\n\t\t\t\t}\n\t\t\t\trecordIdsToRemove = []\n\t\t\t}\n\t\t}\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i])\n\t\t\t}\n\t\t}\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\tlet lastBundle\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings\n\t\t\t\t\t\t\ttarget[position] = 0xc8 // ext 16\n\t\t\t\t\t\t\tposition += 3 // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0) // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart)\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = 0xc1\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0\n\t\t\t\t\t\ttarget[position++] = value + 0x100\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1\n\t\t\t\t\t\ttargetView.setInt16(position, value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2\n\t\t\t\t\t\ttargetView.setInt32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object' || type === 'function') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xde\n\t\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n\t\t\t\t\t\t\t\tpack(key)\n\t\t\t\t\t\t\t\tpack(entryValue)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4 // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value)\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\n\t\t\t\t\t\t\t\tlet currentPosition = position\n\t\t\t\t\t\t\t\ttarget = null\n\t\t\t\t\t\t\t\tlet result\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\n\t\t\t\t\t\t\t\t\t\tposition += size\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack)\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position)\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n\t\t\t\t\t\t\tif (value.toJSON) {\n\t\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\t\treturn pack(json)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t\t\t\t\tif (type === 'function')\n\t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\n\t\t\t\t\t\t\t// no extension found, write as plain object\n\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(63)) && value >= -(BigInt(1)<<BigInt(63))) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3\n\t\t\t\t\ttargetView.setBigInt64(position, value)\n\t\t\t\t} else if (value < (BigInt(1)<<BigInt(64)) && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else if (this.useBigIntExtension && value < 2n**(1023n) && value > -(2n**(1023n))) {\n\t\t\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t\ttarget[position++] = 0x42 // \"B\" for BigInt\n\t\t\t\t\t\tlet bytes = [];\n\t\t\t\t\t\tlet alignedSign;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tlet byte = value & 0xffn;\n\t\t\t\t\t\t\talignedSign = (byte & 0x80n) === (value < 0n ? 0x80n : 0n);\n\t\t\t\t\t\t\tbytes.push(byte);\n\t\t\t\t\t\t\tvalue >>= 8n;\n\t\t\t\t\t\t} while (!((value === 0n || value === -1n) && alignedSign));\n\t\t\t\t\t\ttarget[position-2] = bytes.length;\n\t\t\t\t\t\tfor (let i = bytes.length; i > 0;) {\n\t\t\t\t\t\t\ttarget[position++] = Number(bytes[--i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +\n\t\t\t\t\t\t\t' useBigIntExtension or set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber) ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (this.coercibleKeyAsNumber) {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tkey = keys[i]\n\t\t\t\t\tlet num = Number(key)\n\t\t\t\t\tpack(isNaN(num) ? key : num)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tpack(key = keys[i])\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t}\n\n\t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet objectOffset = position++ - start\n\t\t\tlet wroteKeys\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object)\n\t\t\t\t\t\tlet lastTransition = transition\n\t\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\t\tlet newTransitions = 0\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions)\n\t\t\t\t\t\twroteKeys = true\n\t\t\t\t\t\ttransition = lastTransition[key]\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0)\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key]\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\tnewTransitions++\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = recordId >> 5\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t}\n\n\t\t// craete reference to useRecords if useRecords is a function\n\t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\n\t\tconst writeObject = checkUseRecords ? (object) => {\n\t\t\tcheckUseRecords(object) ? writeRecord(object) : writePlainObject(object)\n\t\t} : writeRecord\n\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))\n\t\t\tend = Math.min(end, target.length)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextOwnId = recordId + 1\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextId = recordId + 1\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1\n\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\ttransition.__keys__ = keys\n\t\t\tstructures[recordId - 0x40] = keys\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true\n\t\t\t\tstructures.sharedLength = recordId - 0x3f\n\t\t\t\thasSharedUpdate = true\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5 // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\tpack(keys)\n\t\t\t}\n\t\t}\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target\n\t\t\tlet mainPosition = position\n\t\t\tlet mainSafeEnd = safeEnd\n\t\t\tlet mainStart = start\n\t\t\ttarget = keysTarget\n\t\t\tposition = 0\n\t\t\tstart = 0\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192)\n\t\t\tsafeEnd = target.length - 10\n\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\tkeysTarget = target\n\t\t\tlet keysPosition = position\n\t\t\ttarget = mainTarget\n\t\t\tposition = mainPosition\n\t\t\tsafeEnd = mainSafeEnd\n\t\t\tstart = mainStart\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd)\n\t\t\t\tlet insertionPosition = insertionOffset + start\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition)\n\t\t\t\tposition = newEnd\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0]\n\t\t\t}\n\t\t}\n\t\tconst writeStruct = (object) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tresetStructures();\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object);\n\t\t\tposition = newPosition;\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tset position (value) {\n\t\tposition = value;\n\t}\n\tget position() {\n\t\treturn position;\n\t}\n\tset buffer (buffer) {\n\t\ttarget = buffer;\n\t}\n\tget buffer () {\n\t\treturn target;\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = []\n\t}\n}\n\nfunction copyBinary(source, target, targetOffset, offset, endOffset) {\n\twhile (offset < endOffset) {\n\t\ttarget[targetOffset++] = source[offset++]\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, C1Type ]\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\n\t\t\ttarget[position++] = 0xd6\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\n\t\t\ttarget[position++] = 0xd7\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\n\t\t\ttargetView.setUint32(position + 4, seconds)\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0)\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3)\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0xff\n\t\t\ttarget[position++] = 0xff\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\n\t\t\ttarget[position++] = 0xc7\n\t\t\ttarget[position++] = 12\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tif (this.setAsEmptyObject) {\n\t\t\tallocateForWrite(0);\n\t\t\treturn pack({})\n\t\t}\n\t\tlet array = Array.from(set)\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x73 // 's' for Set\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack(array)\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x65 // 'e' for error\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ error.name, error.message, error.cause ])\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ regex.source, regex.flags ])\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite)\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1)\n\t\ttarget[position] = 0xc1\n\t}\n}]\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length)\n\t\ttarget[position++] = 0xc7\n\t\ttarget[position++] = length + 1\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length)\n\t\ttarget[position++] = 0xc8\n\t\ttarget[position++] = (length + 1) >> 8\n\t\ttarget[position++] = (length + 1) & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\n\t\ttarget[position++] = 0xc9\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\n\t\tposition += 4\n\t}\n\ttarget[position++] = 0x74 // \"t\" for typed array\n\ttarget[position++] = type\n\tif (!typedArray.buffer) typedArray = new Uint8Array(typedArray)\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength\n\tvar target, position\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2)\n\t\ttarget[position++] = 0xc4\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3)\n\t\ttarget[position++] = 0xc5\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\n\t\ttarget[position++] = 0xc6\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\ttarget.set(buffer, position)\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9\n\t\t\t\ttarget[position++] = length >> 24\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t}\n\t}\n\ttarget[position++] = type\n\ttarget.set(result, position)\n\tposition += length\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 6\n\tlet lastEnd = serialized.length - distanceToMove\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tlet id = nextId.id\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 6\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd6\n\t\tserialized[position++] = 0x69 // 'i'\n\t\tserialized[position++] = id >> 24\n\t\tserialized[position++] = (id >> 16) & 0xff\n\t\tserialized[position++] = (id >> 8) & 0xff\n\t\tserialized[position++] = id & 0xff\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings\n\t\tbundledStrings = null\n\t\tpack(writeStrings[0])\n\t\tpack(writeStrings[1])\n\t}\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tunpackAddExtension(extension)\n}\nfunction prepareStructures(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t}\n\treturn structures\n}\nexport function setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false })\nexport const pack = defaultPackr.pack\nexport const encode = defaultPackr.pack\nexport const Encoder = Packr\nexport { FLOAT32_OPTIONS } from './unpack.js'\nimport { FLOAT32_OPTIONS } from './unpack.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const RESERVE_START_SPACE = 2048\n", "\n/*\n\nFor \"any-data\":\n32-55 - record with record ids (-32)\n56 - 8-bit record ids\n57 - 16-bit record ids\n58 - 24-bit record ids\n59 - 32-bit record ids\n250-255 - followed by typed fixed width values\n64-250 msgpackr/cbor/paired data\narrays and strings within arrays are handled by paired encoding\n\nStructure encoding:\n(type - string (using paired encoding))+\n\nType encoding\nencoding byte - fixed width byte - next reference+\n\nEncoding byte:\nfirst bit:\n\t0 - inline\n\t1 - reference\nsecond bit:\n\t0 - data or number\n\t1 - string\n\nremaining bits:\n\tcharacter encoding - ISO-8859-x\n\n\nnull (0xff)+ 0xf6\nnull (0xff)+ 0xf7\n\n*/\n\n\nimport {setWriteStructSlots, RECORD_SYMBOL, addExtension} from './pack.js'\nimport {setReadStruct, mult10, readString} from './unpack.js';\nconst ASCII = 3; // the MIBenum from https://www.iana.org/assignments/character-sets/character-sets.xhtml (and other character encodings could be referenced by MIBenum)\nconst NUMBER = 0;\nconst UTF8 = 2;\nconst OBJECT_DATA = 1;\nconst DATE = 16;\nconst TYPE_NAMES = ['num', 'object', 'string', 'ascii'];\nTYPE_NAMES[DATE] = 'date';\nconst float32Headers = [false, true, true, false, false, true, true, false];\nlet evalSupported;\ntry {\n\tnew Function('');\n\tevalSupported = true;\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n}\n\nlet updatedPosition;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nlet textEncoder, currentSource;\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nconst encodeUtf8 = hasNodeBuffer ? function(target, string, position) {\n\treturn target.utf8Write(string, position, 0xffffffff)\n} : (textEncoder && textEncoder.encodeInto) ?\n\tfunction(target, string, position) {\n\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t} : false\n\nconst TYPE = Symbol('type');\nconst PARENT = Symbol('parent');\nsetWriteStructSlots(writeStruct, prepareStructures);\nfunction writeStruct(object, target, encodingStart, position, structures, makeRoom, pack, packr) {\n\tlet typedStructs = packr.typedStructs || (packr.typedStructs = []);\n\t// note that we rely on pack.js to load stored structures before we get to this point\n\tlet targetView = target.dataView;\n\tlet refsStartPosition = (typedStructs.lastStringStart || 100) + position;\n\tlet safeEnd = target.length - 10;\n\tlet start = position;\n\tif (position > safeEnd) {\n\t\ttarget = makeRoom(position);\n\t\ttargetView = target.dataView;\n\t\tposition -= encodingStart;\n\t\tstart -= encodingStart;\n\t\trefsStartPosition -= encodingStart;\n\t\tencodingStart = 0;\n\t\tsafeEnd = target.length - 10;\n\t}\n\n\tlet refOffset, refPosition = refsStartPosition;\n\n\tlet transition = typedStructs.transitions || (typedStructs.transitions = Object.create(null));\n\tlet nextId = typedStructs.nextId || typedStructs.length;\n\tlet headerSize =\n\t\tnextId < 0xf ? 1 :\n\t\t\tnextId < 0xf0 ? 2 :\n\t\t\t\tnextId < 0xf000 ? 3 :\n\t\t\t\t\tnextId < 0xf00000 ? 4 : 0;\n\tif (headerSize === 0)\n\t\treturn 0;\n\tposition += headerSize;\n\tlet queuedReferences = [];\n\tlet usedAscii0;\n\tlet keyIndex = 0;\n\tfor (let key in object) {\n\t\tlet value = object[key];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: 0,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null,\n\t\t\t\tdate64: null\n\t\t\t};\n\t\t}\n\t\tif (position > safeEnd) {\n\t\t\ttarget = makeRoom(position);\n\t\t\ttargetView = target.dataView;\n\t\t\tposition -= encodingStart;\n\t\t\tstart -= encodingStart;\n\t\t\trefsStartPosition -= encodingStart;\n\t\t\trefPosition -= encodingStart;\n\t\t\tencodingStart = 0;\n\t\t\tsafeEnd = target.length - 10\n\t\t}\n\t\tswitch (typeof value) {\n\t\t\tcase 'number':\n\t\t\t\tlet number = value;\n\t\t\t\t// first check to see if we are using a lot of ids and should default to wide/common format\n\t\t\t\tif (nextId < 200 || !nextTransition.num64) {\n\t\t\t\t\tif (number >> 0 === number && number < 0x20000000 && number > -0x1f000000) {\n\t\t\t\t\t\tif (number < 0xf6 && number >= 0 && (nextTransition.num8 && !(nextId > 200 && nextTransition.num32) || number < 0x20 && !nextTransition.num32)) {\n\t\t\t\t\t\t\ttransition = nextTransition.num8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\t\t\t\ttarget[position++] = number;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\ttargetView.setUint32(position, number, true);\n\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (number < 0x100000000 && number >= -0x80000000) {\n\t\t\t\t\t\ttargetView.setFloat32(position, number, true);\n\t\t\t\t\t\tif (float32Headers[target[position + 3] >>> 5]) {\n\t\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\tif (((xShifted = number * mult10[((target[position + 3] & 0x7f) << 1) | (target[position + 2] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition.num64 || createTypeTransition(nextTransition, NUMBER, 8);\n\t\t\t\ttargetView.setFloat64(position, number, true);\n\t\t\t\tposition += 8;\n\t\t\t\tbreak;\n\t\t\tcase 'string':\n\t\t\t\tlet strLength = value.length;\n\t\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\t\tif ((strLength << 2) + refPosition > safeEnd) {\n\t\t\t\t\ttarget = makeRoom((strLength << 2) + refPosition);\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tposition -= encodingStart;\n\t\t\t\t\tstart -= encodingStart;\n\t\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\t\trefPosition -= encodingStart;\n\t\t\t\t\tencodingStart = 0;\n\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t}\n\t\t\t\tif (strLength > ((0xff00 + refOffset) >> 2)) {\n\t\t\t\t\tqueuedReferences.push(key, value, position - start);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet isNotAscii\n\t\t\t\tlet strStart = refPosition;\n\t\t\t\tif (strLength < 0x40) {\n\t\t\t\t\tlet i, c1, c2;\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[refPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trefPosition += encodeUtf8(target, value, refPosition);\n\t\t\t\t\tisNotAscii = refPosition - strStart > strLength;\n\t\t\t\t}\n\t\t\t\tif (refOffset < 0xa0 || (refOffset < 0xf6 && (nextTransition.ascii8 || nextTransition.string8))) {\n\t\t\t\t\t// short strings\n\t\t\t\t\tif (isNotAscii) {\n\t\t\t\t\t\tif (!(transition = nextTransition.string8)) {\n\t\t\t\t\t\t\tif (typedStructs.length > 10 && (transition = nextTransition.ascii8)) {\n\t\t\t\t\t\t\t\t// we can safely change ascii to utf8 in place since they are compatible\n\t\t\t\t\t\t\t\ttransition.__type = UTF8;\n\t\t\t\t\t\t\t\tnextTransition.ascii8 = null;\n\t\t\t\t\t\t\t\tnextTransition.string8 = transition;\n\t\t\t\t\t\t\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, UTF8, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (refOffset === 0 && !usedAscii0) {\n\t\t\t\t\t\tusedAscii0 = true;\n\t\t\t\t\t\ttransition = nextTransition.ascii0 || createTypeTransition(nextTransition, ASCII, 0);\n\t\t\t\t\t\tbreak; // don't increment position\n\t\t\t\t\t}// else ascii:\n\t\t\t\t\telse if (!(transition = nextTransition.ascii8) && !(typedStructs.length > 10 && (transition = nextTransition.string8)))\n\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, ASCII, 1);\n\t\t\t\t\ttarget[position++] = refOffset;\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: Enable ascii16 at some point, but get the logic right\n\t\t\t\t\t//if (isNotAscii)\n\t\t\t\t\t\ttransition = nextTransition.string16 || createTypeTransition(nextTransition, UTF8, 2);\n\t\t\t\t\t//else\n\t\t\t\t\t\t//transition = nextTransition.ascii16 || createTypeTransition(nextTransition, ASCII, 2);\n\t\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\t\tposition += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (value) {\n\t\t\t\t\tif (value.constructor === Date) {\n\t\t\t\t\t\ttransition = nextTransition.date64 || createTypeTransition(nextTransition, DATE, 8);\n\t\t\t\t\t\ttargetView.setFloat64(position, value.getTime(), true);\n\t\t\t\t\t\tposition += 8;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else { // null\n\t\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -10); // match CBOR with this\n\t\t\t\t\tif (nextTransition) {\n\t\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\t\ttransition = nextTransition.num8 || nextTransition.ascii8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\ttarget[position++] = value ? 0xf9 : 0xf8; // match CBOR with these\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -9); // match CBOR with this\n\t\t\t\tif (nextTransition) {\n\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\tfor (let i = 0, l = queuedReferences.length; i < l;) {\n\t\tlet key = queuedReferences[i++];\n\t\tlet value = queuedReferences[i++];\n\t\tlet propertyIndex = queuedReferences[i++];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: propertyIndex - keyIndex,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null\n\t\t\t};\n\t\t}\n\t\tlet newPosition;\n\t\tif (value) {\n\t\t\t/*if (typeof value === 'string') { // TODO: we could re-enable long strings\n\t\t\t\tif (position + value.length * 3 > safeEnd) {\n\t\t\t\t\ttarget = makeRoom(position + value.length * 3);\n\t\t\t\t\tposition -= start;\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tstart = 0;\n\t\t\t\t}\n\t\t\t\tnewPosition = position + target.utf8Write(value, position, 0xffffffff);\n\t\t\t} else { */\n\t\t\tlet size;\n\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\tif (refOffset < 0xff00) {\n\t\t\t\ttransition = nextTransition.object16;\n\t\t\t\tif (transition)\n\t\t\t\t\tsize = 2;\n\t\t\t\telse if ((transition = nextTransition.object32))\n\t\t\t\t\tsize = 4;\n\t\t\t\telse {\n\t\t\t\t\ttransition = createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\t\t\tsize = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttransition = nextTransition.object32 || createTypeTransition(nextTransition, OBJECT_DATA, 4);\n\t\t\t\tsize = 4;\n\t\t\t}\n\t\t\tnewPosition = pack(value, refPosition);\n\t\t\t//}\n\t\t\tif (typeof newPosition === 'object') {\n\t\t\t\t// re-allocated\n\t\t\t\trefPosition = newPosition.position;\n\t\t\t\ttargetView = newPosition.targetView;\n\t\t\t\ttarget = newPosition.target;\n\t\t\t\trefsStartPosition -= encodingStart;\n\t\t\t\tposition -= encodingStart;\n\t\t\t\tstart -= encodingStart;\n\t\t\t\tencodingStart = 0;\n\t\t\t} else\n\t\t\t\trefPosition = newPosition;\n\t\t\tif (size === 2) {\n\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\tposition += 2;\n\t\t\t} else {\n\t\t\t\ttargetView.setUint32(position, refOffset, true);\n\t\t\t\tposition += 4;\n\t\t\t}\n\t\t} else { // null or undefined\n\t\t\ttransition = nextTransition.object16 || createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\ttargetView.setInt16(position, value === null ? -10 : -9, true);\n\t\t\tposition += 2;\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\n\tlet recordId = transition[RECORD_SYMBOL];\n\tif (recordId == null) {\n\t\trecordId = packr.typedStructs.length;\n\t\tlet structure = [];\n\t\tlet nextTransition = transition;\n\t\tlet key, type;\n\t\twhile ((type = nextTransition.__type) !== undefined) {\n\t\t\tlet size = nextTransition.__size;\n\t\t\tnextTransition = nextTransition.__parent;\n\t\t\tkey = nextTransition.key;\n\t\t\tlet property = [type, size, key];\n\t\t\tif (nextTransition.enumerationOffset)\n\t\t\t\tproperty.push(nextTransition.enumerationOffset);\n\t\t\tstructure.push(property);\n\t\t\tnextTransition = nextTransition.parent;\n\t\t}\n\t\tstructure.reverse();\n\t\ttransition[RECORD_SYMBOL] = recordId;\n\t\tpackr.typedStructs[recordId] = structure;\n\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t}\n\n\n\tswitch (headerSize) {\n\t\tcase 1:\n\t\t\tif (recordId >= 0x10) return 0;\n\t\t\ttarget[start] = recordId + 0x20;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (recordId >= 0x100) return 0;\n\t\t\ttarget[start] = 0x38;\n\t\t\ttarget[start + 1] = recordId;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (recordId >= 0x10000) return 0;\n\t\t\ttarget[start] = 0x39;\n\t\t\ttargetView.setUint16(start + 1, recordId, true);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (recordId >= 0x1000000) return 0;\n\t\t\ttargetView.setUint32(start, (recordId << 8) + 0x3a, true);\n\t\t\tbreak;\n\t}\n\n\tif (position < refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\t// adjust positioning\n\t\ttarget.copyWithin(position, refsStartPosition, refPosition);\n\t\trefPosition += position - refsStartPosition;\n\t\ttypedStructs.lastStringStart = position - start;\n\t} else if (position > refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\ttypedStructs.lastStringStart = position - start;\n\t\treturn writeStruct(object, target, encodingStart, start, structures, makeRoom, pack, packr);\n\t}\n\treturn refPosition;\n}\nfunction anyType(transition, position, targetView, value) {\n\tlet nextTransition;\n\tif ((nextTransition = transition.ascii8 || transition.num8)) {\n\t\ttargetView.setInt8(position, value, true);\n\t\tupdatedPosition = position + 1;\n\t\treturn nextTransition;\n\t}\n\tif ((nextTransition = transition.string16 || transition.object16)) {\n\t\ttargetView.setInt16(position, value, true);\n\t\tupdatedPosition = position + 2;\n\t\treturn nextTransition;\n\t}\n\tif (nextTransition = transition.num32) {\n\t\ttargetView.setUint32(position, 0xe0000100 + value, true);\n\t\tupdatedPosition = position + 4;\n\t\treturn nextTransition;\n\t}\n\t// transition.float64\n\tif (nextTransition = transition.num64) {\n\t\ttargetView.setFloat64(position, NaN, true);\n\t\ttargetView.setInt8(position, value);\n\t\tupdatedPosition = position + 8;\n\t\treturn nextTransition;\n\t}\n\tupdatedPosition = position;\n\t// TODO: can we do an \"any\" type where we defer the decision?\n\treturn;\n}\nfunction createTypeTransition(transition, type, size) {\n\tlet typeName = TYPE_NAMES[type] + (size << 3);\n\tlet newTransition = transition[typeName] || (transition[typeName] = Object.create(null));\n\tnewTransition.__type = type;\n\tnewTransition.__size = size;\n\tnewTransition.__parent = transition;\n\treturn newTransition;\n}\nfunction onLoadedStructures(sharedData) {\n\tif (!(sharedData instanceof Map))\n\t\treturn sharedData;\n\tlet typed = sharedData.get('typed') || [];\n\tif (Object.isFrozen(typed))\n\t\ttyped = typed.map(structure => structure.slice(0));\n\tlet named = sharedData.get('named');\n\tlet transitions = Object.create(null);\n\tfor (let i = 0, l = typed.length; i < l; i++) {\n\t\tlet structure = typed[i];\n\t\tlet transition = transitions;\n\t\tfor (let [type, size, key] of structure) {\n\t\t\tlet nextTransition = transition[key];\n\t\t\tif (!nextTransition) {\n\t\t\t\ttransition[key] = nextTransition = {\n\t\t\t\t\tkey,\n\t\t\t\t\tparent: transition,\n\t\t\t\t\tenumerationOffset: 0,\n\t\t\t\t\tascii0: null,\n\t\t\t\t\tascii8: null,\n\t\t\t\t\tnum8: null,\n\t\t\t\t\tstring16: null,\n\t\t\t\t\tobject16: null,\n\t\t\t\t\tnum32: null,\n\t\t\t\t\tfloat64: null,\n\t\t\t\t\tdate64: null,\n\t\t\t\t};\n\t\t\t}\n\t\t\ttransition = createTypeTransition(nextTransition, type, size);\n\t\t}\n\t\ttransition[RECORD_SYMBOL] = i;\n\t}\n\ttyped.transitions = transitions;\n\tthis.typedStructs = typed;\n\tthis.lastTypedStructuresLength = typed.length;\n\treturn named;\n}\nvar sourceSymbol = Symbol.for('source')\nfunction readStruct(src, position, srcEnd, unpackr) {\n\tlet recordId = src[position++] - 0x20;\n\tif (recordId >= 24) {\n\t\tswitch(recordId) {\n\t\t\tcase 24: recordId = src[position++]; break;\n\t\t\t// little endian:\n\t\t\tcase 25: recordId = src[position++] + (src[position++] << 8); break;\n\t\t\tcase 26: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16); break;\n\t\t\tcase 27: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16) + (src[position++] << 24); break;\n\t\t}\n\t}\n\tlet structure = unpackr.typedStructs && unpackr.typedStructs[recordId];\n\tif (!structure) {\n\t\t// copy src buffer because getStructures will override it\n\t\tsrc = Uint8Array.prototype.slice.call(src, position, srcEnd);\n\t\tsrcEnd -= position;\n\t\tposition = 0;\n\t\tunpackr._mergeStructures(unpackr.getStructures());\n\t\tif (!unpackr.typedStructs)\n\t\t\tthrow new Error('Could not find any shared typed structures');\n\t\tunpackr.lastTypedStructuresLength = unpackr.typedStructs.length;\n\t\tstructure = unpackr.typedStructs[recordId];\n\t\tif (!structure)\n\t\t\tthrow new Error('Could not find typed structure ' + recordId);\n\t}\n\tvar construct = structure.construct;\n\tif (!construct) {\n\t\tconstruct = structure.construct = function LazyObject() {\n\t\t}\n\t\tvar prototype = construct.prototype;\n\t\tlet properties = [];\n\t\tlet currentOffset = 0;\n\t\tlet lastRefProperty;\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet definition = structure[i];\n\t\t\tlet [ type, size, key, enumerationOffset ] = definition;\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tlet property = {\n\t\t\t\tkey,\n\t\t\t\toffset: currentOffset,\n\t\t\t}\n\t\t\tif (enumerationOffset)\n\t\t\t\tproperties.splice(i + enumerationOffset, 0, property);\n\t\t\telse\n\t\t\t\tproperties.push(property);\n\t\t\tlet getRef;\n\t\t\tswitch(size) { // TODO: Move into a separate function\n\t\t\t\tcase 0: getRef = () => 0; break;\n\t\t\t\tcase 1:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet ref = source.bytes[position + property.offset];\n\t\t\t\t\t\treturn ref >= 0xf6 ? toConstant(ref) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint16(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint32(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xffffff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tproperty.getRef = getRef;\n\t\t\tcurrentOffset += size;\n\t\t\tlet get;\n\t\t\tswitch(type) {\n\t\t\t\tcase ASCII:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tproperty.multiGetCount = 0;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (source.srcString) {\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*if (property.multiGetCount > 0) {\n\t\t\t\t\t\t\tlet asciiEnd;\n\t\t\t\t\t\t\tnext = firstRefProperty;\n\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tasciiEnd = dataView.getUint16(source.position + next.offset, true);\n\t\t\t\t\t\t\t\tif (asciiEnd < 0xff00)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tasciiEnd = null;\n\t\t\t\t\t\t\t} while((next = next.next));\n\t\t\t\t\t\t\tif (asciiEnd == null)\n\t\t\t\t\t\t\t\tasciiEnd = source.bytesEnd - refStart\n\t\t\t\t\t\t\tsource.srcString = src.toString('latin1', refStart, refStart + asciiEnd);\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (source.prevStringGet) {\n\t\t\t\t\t\t\tsource.prevStringGet.multiGetCount += 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsource.prevStringGet = property;\n\t\t\t\t\t\t\tproperty.multiGetCount--;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\treturn readString(src, ref + refStart, end - ref);\n\t\t\t\t\t\t//return src.toString('latin1', ref + refStart, end + refStart);\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase UTF8: case OBJECT_DATA:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (type === UTF8) {\n\t\t\t\t\t\t\treturn src.toString('utf8', ref + refStart, end + refStart);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrentSource = source;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn unpackr.unpack(src, { start: ref + refStart, end: end + refStart });\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tcurrentSource = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase NUMBER:\n\t\t\t\t\tswitch(size) {\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet position = source.position + property.offset;\n\t\t\t\t\t\t\t\tlet value = dataView.getInt32(position, true)\n\t\t\t\t\t\t\t\tif (value < 0x20000000) {\n\t\t\t\t\t\t\t\t\tif (value > -0x1f000000)\n\t\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t\t\tif (value > -0x20000000)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(value & 0xff);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet fValue = dataView.getFloat32(position, true);\n\t\t\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\tlet multiplier = mult10[((src[position + 3] & 0x7f) << 1) | (src[position + 2] >> 7)]\n\t\t\t\t\t\t\t\treturn ((multiplier * fValue + (fValue > 0 ? 0.5 : -0.5)) >> 0) / multiplier;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet value = dataView.getFloat64(source.position + property.offset, true);\n\t\t\t\t\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\t\t\t\t\tlet byte = src[source.position + property.offset];\n\t\t\t\t\t\t\t\t\tif (byte >= 0xf6)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(byte);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet value = src[source.position + property.offset];\n\t\t\t\t\t\t\t\treturn value < 0xf6 ? value : toConstant(value);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase DATE:\n\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\treturn new Date(dataView.getFloat64(source.position + property.offset, true));\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tproperty.get = get;\n\t\t}\n\t\t// TODO: load the srcString for faster string decoding on toJSON\n\t\tif (evalSupported) {\n\t\t\tlet objectLiteralProperties = [];\n\t\t\tlet args = [];\n\t\t\tlet i = 0;\n\t\t\tlet hasInheritedProperties;\n\t\t\tfor (let property of properties) { // assign in enumeration order\n\t\t\t\tif (unpackr.alwaysLazyProperty && unpackr.alwaysLazyProperty(property.key)) {\n\t\t\t\t\t// these properties are not eagerly evaluated and this can be used for creating properties\n\t\t\t\t\t// that are not serialized as JSON\n\t\t\t\t\thasInheritedProperties = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tObject.defineProperty(prototype, property.key, { get: withSource(property.get), enumerable: true });\n\t\t\t\tlet valueFunction = 'v' + i++;\n\t\t\t\targs.push(valueFunction);\n\t\t\t\tobjectLiteralProperties.push('[' + JSON.stringify(property.key) + ']:' + valueFunction + '(s)');\n\t\t\t}\n\t\t\tif (hasInheritedProperties) {\n\t\t\t\tobjectLiteralProperties.push('__proto__:this');\n\t\t\t}\n\t\t\tlet toObject = (new Function(...args, 'return function(s){return{' + objectLiteralProperties.join(',') + '}}')).apply(null, properties.map(prop => prop.get));\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\treturn toObject.call(this, this[sourceSymbol]);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\t// return an enumerable object with own properties to JSON stringify\n\t\t\t\t\tlet resolved = {};\n\t\t\t\t\tfor (let i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t// TODO: check alwaysLazyProperty\n\t\t\t\t\t\tlet key = properties[i].key;\n\n\t\t\t\t\t\tresolved[key] = this[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t},\n\t\t\t\t// not enumerable or anything\n\t\t\t});\n\t\t}\n\t}\n\tvar instance = new construct();\n\tinstance[sourceSymbol] = {\n\t\tbytes: src,\n\t\tposition,\n\t\tsrcString: '',\n\t\tbytesEnd: srcEnd\n\t}\n\treturn instance;\n}\nfunction toConstant(code) {\n\tswitch(code) {\n\t\tcase 0xf6: return null;\n\t\tcase 0xf7: return undefined;\n\t\tcase 0xf8: return false;\n\t\tcase 0xf9: return true;\n\t}\n\tthrow new Error('Unknown constant');\n}\nfunction withSource(get) {\n\treturn function() {\n\t\treturn get(this[sourceSymbol]);\n\t}\n}\n\nfunction saveState() {\n\tif (currentSource) {\n\t\tcurrentSource.bytes = Uint8Array.prototype.slice.call(currentSource.bytes, currentSource.position, currentSource.bytesEnd);\n\t\tcurrentSource.position = 0;\n\t\tcurrentSource.bytesEnd = currentSource.bytes.length;\n\t}\n}\nfunction prepareStructures(structures, packr) {\n\tif (packr.typedStructs) {\n\t\tlet structMap = new Map();\n\t\tstructMap.set('named', structures);\n\t\tstructMap.set('typed', packr.typedStructs);\n\t\tstructures = structMap;\n\t}\n\tlet lastTypedStructuresLength = packr.lastTypedStructuresLength || 0;\n\tstructures.isCompatible = existing => {\n\t\tlet compatible = true;\n\t\tif (existing instanceof Map) {\n\t\t\tlet named = existing.get('named') || [];\n\t\t\tif (named.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t\tlet typed = existing.get('typed') || [];\n\t\t\tif (typed.length !== lastTypedStructuresLength)\n\t\t\t\tcompatible = false;\n\t\t} else if (existing instanceof Array || Array.isArray(existing)) {\n\t\t\tif (existing.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t}\n\t\tif (!compatible)\n\t\t\tpackr._mergeStructures(existing);\n\t\treturn compatible;\n\t};\n\tpackr.lastTypedStructuresLength = packr.typedStructs && packr.typedStructs.length;\n\treturn structures;\n}\n\nsetReadStruct(readStruct, onLoadedStructures, saveState);\n\n", "export { Packr, Encoder, addExtension, pack, encode, NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } from './pack.js'\nexport { Unpackr, Decoder, C1, unpack, unpackMultiple, decode, FLOAT32_OPTIONS, clearSource, roundFloat32, isNativeAccelerationEnabled } from './unpack.js'\nimport './struct.js'\nexport { PackrStream, UnpackrStream, PackrStream as EncoderStream, UnpackrStream as DecoderStream } from './stream.js'\nexport { decodeIter, encodeIter } from './iterators.js'\nexport const useRecords = false\nexport const mapsAsObjects = true\nimport { setExtractor } from './unpack.js'\nimport { createRequire } from 'module'\n\nconst nativeAccelerationDisabled = process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED !== undefined && process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === 'true';\n\nif (!nativeAccelerationDisabled) {\n\tlet extractor\n\ttry {\n\t\tif (typeof require == 'function')\n\t\t\textractor = require('msgpackr-extract')\n\t\telse\n\t\t\textractor = createRequire(import.meta.url)('msgpackr-extract')\n\t\tif (extractor)\n\t\t\tsetExtractor(extractor.extractStrings)\n\t} catch (error) {\n\t\t// native module is optional\n\t}\n}", "export const SWITCH_TO_STRUCTURE = 255; // (decoding collides with DELETE_AND_ADD + fieldIndex = 63)\nexport const TYPE_ID = 213;\n\n/**\n * Encoding Schema field operations.\n */\nexport enum OPERATION {\n    ADD = 128,            // (10000000) add new structure/primitive\n    REPLACE = 0,          // (00000001) replace structure/primitive\n    DELETE = 64,          // (01000000) delete field\n    DELETE_AND_MOVE = 96, // () ArraySchema only\n    MOVE_AND_ADD = 160,   // () ArraySchema only\n    DELETE_AND_ADD = 192, // (11000000) DELETE field, followed by an ADD\n\n    /**\n     * Collection operations\n     */\n    CLEAR = 10,\n\n    /**\n     * ArraySchema operations\n     */\n    REVERSE = 15,\n    MOVE = 32,\n    DELETE_BY_REFID = 33, // This operation is only used at ENCODING time. During DECODING, DELETE_BY_REFID is converted to DELETE\n    ADD_BY_REFID = 129,\n}\n", "\n//\n// Must have Symbol.metadata defined for metadata support on decorators:\n// https://github.com/microsoft/TypeScript/issues/55453#issuecomment-1687496648\n//\nexport {};\ndeclare global {\n    interface SymbolConstructor {\n        readonly metadata: unique symbol;\n    }\n}\n(Symbol as any).metadata ??= Symbol.for(\"Symbol.metadata\");", "export const $track = Symbol(\"$track\");\nexport const $encoder = Symbol(\"$encoder\");\nexport const $decoder = Symbol(\"$decoder\");\n\nexport const $filter = Symbol(\"$filter\");\n\nexport const $getByIndex = Symbol(\"$getByIndex\");\nexport const $deleteByIndex = Symbol(\"$deleteByIndex\");\n\n/**\n * Used to hold ChangeTree instances whitin the structures\n */\nexport const $changes = Symbol('$changes');\n\n/**\n * Used to keep track of the type of the child elements of a collection\n * (MapSchema, ArraySchema, etc.)\n */\nexport const $childType = Symbol('$childType');\n\n/**\n * Optional \"discard\" method for custom types (ArraySchema)\n * (Discards changes for next serialization)\n */\nexport const $onEncodeEnd = Symbol('$onEncodeEnd');\n\n/**\n * When decoding, this method is called after the instance is fully decoded\n */\nexport const $onDecodeEnd = Symbol(\"$onDecodeEnd\");\n\n/**\n * Metadata\n */\nexport const $descriptors = Symbol(\"$descriptors\");\nexport const $numFields = \"$__numFields\";\nexport const $refTypeFieldIndexes = \"$__refTypeFieldIndexes\";\nexport const $viewFieldIndexes = \"$__viewFieldIndexes\";\nexport const $fieldIndexesByViewTag = \"$__fieldIndexesByViewTag\";\n", "/**\n * Copyright (c) 2018 Endel Dreyer\n * Copyright (c) 2014 Ion Drive Software Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE\n */\n\nimport type { TextEncoder } from \"util\";\nimport type { Iterator } from \"./decode\";\n\nexport type BufferLike = number[] | ArrayBufferLike;\n\n/**\n * msgpack implementation highly based on notepack.io\n * https://github.com/darrachequesne/notepack\n */\n\nlet textEncoder: TextEncoder;\n// @ts-ignore\ntry { textEncoder = new TextEncoder(); } catch (e) { }\n\n// force little endian to facilitate decoding on multiple implementations\nconst _isLittleEndian = true;  // new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\nconst _convoBuffer = new ArrayBuffer(8);\nconst _int32 = new Int32Array(_convoBuffer);\nconst _float32 = new Float32Array(_convoBuffer);\nconst _float64 = new Float64Array(_convoBuffer);\nconst _int64 = new BigInt64Array(_convoBuffer);\n\nconst hasBufferByteLength = (typeof Buffer !== 'undefined' && Buffer.byteLength);\n\nconst utf8Length: (str: string, _?: any) => number = (hasBufferByteLength)\n    ? Buffer.byteLength // node\n    : function (str: string, _?: any) {\n        var c = 0, length = 0;\n        for (var i = 0, l = str.length; i < l; i++) {\n            c = str.charCodeAt(i);\n            if (c < 0x80) {\n                length += 1;\n            }\n            else if (c < 0x800) {\n                length += 2;\n            }\n            else if (c < 0xd800 || c >= 0xe000) {\n                length += 3;\n            }\n            else {\n                i++;\n                length += 4;\n            }\n        }\n        return length;\n    }\n\nfunction utf8Write(view: BufferLike, str: string, it: Iterator) {\n  var c = 0;\n  for (var i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i);\n    if (c < 0x80) {\n      view[it.offset++] = c;\n    }\n    else if (c < 0x800) {\n      view[it.offset] = 0xc0 | (c >> 6);\n      view[it.offset + 1] = 0x80 | (c & 0x3f);\n      it.offset += 2;\n    }\n    else if (c < 0xd800 || c >= 0xe000) {\n      view[it.offset] = 0xe0 | (c >> 12);\n      view[it.offset+1] = 0x80 | (c >> 6 & 0x3f);\n      view[it.offset+2] = 0x80 | (c & 0x3f);\n      it.offset += 3;\n    }\n    else {\n      i++;\n      c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n      view[it.offset] = 0xf0 | (c >> 18);\n      view[it.offset+1] = 0x80 | (c >> 12 & 0x3f);\n      view[it.offset+2] = 0x80 | (c >> 6 & 0x3f);\n      view[it.offset+3] = 0x80 | (c & 0x3f);\n      it.offset += 4;\n    }\n  }\n}\n\nfunction int8(bytes: BufferLike, value: number, it: Iterator) {\n    bytes[it.offset++] = value & 255;\n};\n\nfunction uint8(bytes: BufferLike, value: number, it: Iterator) {\n    bytes[it.offset++] = value & 255;\n};\n\nfunction int16(bytes: BufferLike, value: number, it: Iterator) {\n    bytes[it.offset++] = value & 255;\n    bytes[it.offset++] = (value >> 8) & 255;\n};\n\nfunction uint16(bytes: BufferLike, value: number, it: Iterator) {\n    bytes[it.offset++] = value & 255;\n    bytes[it.offset++] = (value >> 8) & 255;\n};\n\nfunction int32(bytes: BufferLike, value: number, it: Iterator) {\n  bytes[it.offset++] = value & 255;\n  bytes[it.offset++] = (value >> 8) & 255;\n  bytes[it.offset++] = (value >> 16) & 255;\n  bytes[it.offset++] = (value >> 24) & 255;\n};\n\nfunction uint32(bytes: BufferLike, value: number, it: Iterator) {\n  const b4 = value >> 24;\n  const b3 = value >> 16;\n  const b2 = value >> 8;\n  const b1 = value;\n  bytes[it.offset++] = b1 & 255;\n  bytes[it.offset++] = b2 & 255;\n  bytes[it.offset++] = b3 & 255;\n  bytes[it.offset++] = b4 & 255;\n};\n\nfunction int64(bytes: BufferLike, value: number, it: Iterator) {\n  const high = Math.floor(value / Math.pow(2, 32));\n  const low = value >>> 0;\n  uint32(bytes, low, it);\n  uint32(bytes, high, it);\n};\n\nfunction uint64(bytes: BufferLike, value: number, it: Iterator) {\n  const high = (value / Math.pow(2, 32)) >> 0;\n  const low = value >>> 0;\n  uint32(bytes, low, it);\n  uint32(bytes, high, it);\n};\n\nfunction bigint64(bytes: BufferLike, value: bigint, it: Iterator) {\n    _int64[0] = BigInt.asIntN(64, value);\n    int32(bytes, _int32[0], it);\n    int32(bytes, _int32[1], it);\n}\n\nfunction biguint64(bytes: BufferLike, value: bigint, it: Iterator) {\n    _int64[0] = BigInt.asIntN(64, value);\n    int32(bytes, _int32[0], it);\n    int32(bytes, _int32[1], it);\n}\n\nfunction float32(bytes: BufferLike, value: number, it: Iterator) {\n  _float32[0] = value;\n  int32(bytes, _int32[0], it);\n}\n\nfunction float64(bytes: BufferLike, value: number, it: Iterator) {\n  _float64[0] = value;\n  int32(bytes, _int32[_isLittleEndian ? 0 : 1], it);\n  int32(bytes, _int32[_isLittleEndian ? 1 : 0], it);\n}\n\nfunction boolean(bytes: BufferLike, value: number, it: Iterator) {\n  bytes[it.offset++] = value ? 1 : 0; // uint8\n};\n\nfunction string(bytes: BufferLike, value: string, it: Iterator) {\n  // encode `null` strings as empty.\n  if (!value) { value = \"\"; }\n\n  let length = utf8Length(value, \"utf8\");\n  let size = 0;\n\n  // fixstr\n  if (length < 0x20) {\n    bytes[it.offset++] = length | 0xa0;\n    size = 1;\n  }\n  // str 8\n  else if (length < 0x100) {\n    bytes[it.offset++] = 0xd9;\n    bytes[it.offset++] = length % 255;\n    size = 2;\n  }\n  // str 16\n  else if (length < 0x10000) {\n    bytes[it.offset++] = 0xda;\n    uint16(bytes, length, it);\n    size = 3;\n  }\n  // str 32\n  else if (length < 0x100000000) {\n    bytes[it.offset++] = 0xdb;\n    uint32(bytes, length, it);\n    size = 5;\n  } else {\n    throw new Error('String too long');\n  }\n\n  utf8Write(bytes, value, it);\n\n  return size + length;\n}\n\nfunction number(bytes: BufferLike, value: number, it: Iterator) {\n  if (isNaN(value)) {\n    return number(bytes, 0, it);\n\n  } else if (!isFinite(value)) {\n    return number(bytes, (value > 0) ? Number.MAX_SAFE_INTEGER : -Number.MAX_SAFE_INTEGER, it);\n\n  } else if (value !== (value|0)) {\n    if (Math.abs(value) <= 3.4028235e+38) { // range check\n        _float32[0] = value;\n        if (Math.abs(Math.abs(_float32[0]) - Math.abs(value)) < 1e-4) { // precision check; adjust 1e-n (n = precision) to in-/decrease acceptable precision loss\n            // now we know value is in range for f32 and has acceptable precision for f32\n            bytes[it.offset++] = 0xca;\n            float32(bytes, value, it);\n            return 5;\n        }\n    }\n\n    bytes[it.offset++] = 0xcb;\n    float64(bytes, value, it);\n    return 9;\n  }\n\n  if (value >= 0) {\n    // positive fixnum\n    if (value < 0x80) {\n      bytes[it.offset++] = value & 255; // uint8\n      return 1;\n    }\n\n    // uint 8\n    if (value < 0x100) {\n      bytes[it.offset++] = 0xcc;\n      bytes[it.offset++] = value & 255; // uint8\n      return 2;\n    }\n\n    // uint 16\n    if (value < 0x10000) {\n      bytes[it.offset++] = 0xcd;\n      uint16(bytes, value, it);\n      return 3;\n    }\n\n    // uint 32\n    if (value < 0x100000000) {\n      bytes[it.offset++] = 0xce;\n      uint32(bytes, value, it);\n      return 5;\n    }\n\n    // uint 64\n    bytes[it.offset++] = 0xcf;\n    uint64(bytes, value, it);\n    return 9;\n\n  } else {\n\n    // negative fixnum\n    if (value >= -0x20) {\n      bytes[it.offset++] = 0xe0 | (value + 0x20);\n      return 1;\n    }\n\n    // int 8\n    if (value >= -0x80) {\n      bytes[it.offset++] = 0xd0;\n      int8(bytes, value, it);\n      return 2;\n    }\n\n    // int 16\n    if (value >= -0x8000) {\n      bytes[it.offset++] = 0xd1;\n      int16(bytes, value, it);\n      return 3;\n    }\n\n    // int 32\n    if (value >= -0x80000000) {\n      bytes[it.offset++] = 0xd2;\n      int32(bytes, value, it);\n      return 5;\n    }\n\n    // int 64\n    bytes[it.offset++] = 0xd3;\n    int64(bytes, value, it);\n    return 9;\n  }\n}\n\nexport const encode = {\n    int8,\n    uint8,\n    int16,\n    uint16,\n    int32,\n    uint32,\n    int64,\n    uint64,\n    bigint64,\n    biguint64,\n    float32,\n    float64,\n    boolean,\n    string,\n    number,\n    utf8Write,\n    utf8Length,\n}", "/**\n * Copyright (c) 2018 Endel Dreyer\n * Copyright (c) 2014 Ion Drive Software Ltd.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE\n */\n\nimport type { BufferLike } from \"./encode\";\n\n/**\n * msgpack implementation highly based on notepack.io\n * https://github.com/darrachequesne/notepack\n */\n\nexport interface Iterator { offset: number; }\n\n// force little endian to facilitate decoding on multiple implementations\nconst _isLittleEndian = true;  // new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\nconst _convoBuffer = new ArrayBuffer(8);\n\nconst _int32 = new Int32Array(_convoBuffer);\nconst _float32 = new Float32Array(_convoBuffer);\nconst _float64 = new Float64Array(_convoBuffer);\nconst _uint64 = new BigUint64Array(_convoBuffer);\nconst _int64 = new BigInt64Array(_convoBuffer);\n\nfunction utf8Read(bytes: BufferLike, it: Iterator, length: number) {\n  var string = '', chr = 0;\n  for (var i = it.offset, end = it.offset + length; i < end; i++) {\n    var byte = bytes[i];\n    if ((byte & 0x80) === 0x00) {\n      string += String.fromCharCode(byte);\n      continue;\n    }\n    if ((byte & 0xe0) === 0xc0) {\n      string += String.fromCharCode(\n        ((byte & 0x1f) << 6) |\n        (bytes[++i] & 0x3f)\n      );\n      continue;\n    }\n    if ((byte & 0xf0) === 0xe0) {\n      string += String.fromCharCode(\n        ((byte & 0x0f) << 12) |\n        ((bytes[++i] & 0x3f) << 6) |\n        ((bytes[++i] & 0x3f) << 0)\n      );\n      continue;\n    }\n    if ((byte & 0xf8) === 0xf0) {\n      chr = ((byte & 0x07) << 18) |\n        ((bytes[++i] & 0x3f) << 12) |\n        ((bytes[++i] & 0x3f) << 6) |\n        ((bytes[++i] & 0x3f) << 0);\n      if (chr >= 0x010000) { // surrogate pair\n        chr -= 0x010000;\n        string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);\n      } else {\n        string += String.fromCharCode(chr);\n      }\n      continue;\n    }\n\n    console.error('Invalid byte ' + byte.toString(16));\n    // (do not throw error to avoid server/client from crashing due to hack attemps)\n    // throw new Error('Invalid byte ' + byte.toString(16));\n  }\n  it.offset += length;\n  return string;\n}\n\nfunction int8 (bytes: BufferLike, it: Iterator) {\n    return uint8(bytes, it) << 24 >> 24;\n};\n\nfunction uint8 (bytes: BufferLike, it: Iterator) {\n    return bytes[it.offset++];\n};\n\nfunction int16 (bytes: BufferLike, it: Iterator) {\n    return uint16(bytes, it) << 16 >> 16;\n};\n\nfunction uint16 (bytes: BufferLike, it: Iterator) {\n    return bytes[it.offset++] | bytes[it.offset++] << 8;\n};\n\nfunction int32 (bytes: BufferLike, it: Iterator) {\n    return bytes[it.offset++] | bytes[it.offset++] << 8 | bytes[it.offset++] << 16 | bytes[it.offset++] << 24;\n};\n\nfunction uint32 (bytes: BufferLike, it: Iterator) {\n    return int32(bytes, it) >>> 0;\n};\n\nfunction float32 (bytes: BufferLike, it: Iterator) {\n    _int32[0] = int32(bytes, it);\n    return _float32[0];\n};\n\nfunction float64 (bytes: BufferLike, it: Iterator) {\n    _int32[_isLittleEndian ? 0 : 1] = int32(bytes, it);\n    _int32[_isLittleEndian ? 1 : 0] = int32(bytes, it);\n    return _float64[0];\n};\n\nfunction int64(bytes: BufferLike, it: Iterator) {\n  const low = uint32(bytes, it);\n  const high = int32(bytes, it) * Math.pow(2, 32);\n  return high + low;\n};\n\nfunction uint64(bytes: BufferLike, it: Iterator) {\n    const low = uint32(bytes, it);\n    const high = uint32(bytes, it) * Math.pow(2, 32);\n    return high + low;\n};\n\nfunction bigint64(bytes: BufferLike, it: Iterator) {\n    _int32[0] = int32(bytes, it);\n    _int32[1] = int32(bytes, it);\n    return _int64[0];\n}\n\nfunction biguint64(bytes: BufferLike, it: Iterator) {\n    _int32[0] = int32(bytes, it);\n    _int32[1] = int32(bytes, it);\n    return _uint64[0];\n}\n\nfunction boolean (bytes: BufferLike, it: Iterator) {\n    return uint8(bytes, it) > 0;\n};\n\nfunction string (bytes: BufferLike, it: Iterator) {\n  const prefix = bytes[it.offset++];\n  let length: number;\n\n  if (prefix < 0xc0) {\n    // fixstr\n    length = prefix & 0x1f;\n\n  } else if (prefix === 0xd9) {\n    length = uint8(bytes, it);\n\n  } else if (prefix === 0xda) {\n    length = uint16(bytes, it);\n\n  } else if (prefix === 0xdb) {\n    length = uint32(bytes, it);\n  }\n\n  return utf8Read(bytes, it, length);\n}\n\nfunction number (bytes: BufferLike, it: Iterator) {\n  const prefix = bytes[it.offset++];\n\n  if (prefix < 0x80) {\n    // positive fixint\n    return prefix;\n\n  } else if (prefix === 0xca) {\n    // float 32\n    return float32(bytes, it);\n\n  } else if (prefix === 0xcb) {\n    // float 64\n    return float64(bytes, it);\n\n  } else if (prefix === 0xcc) {\n    // uint 8\n    return uint8(bytes, it);\n\n  } else if (prefix === 0xcd) {\n    // uint 16\n    return uint16(bytes, it);\n\n  } else if (prefix === 0xce) {\n    // uint 32\n    return uint32(bytes, it);\n\n  } else if (prefix === 0xcf) {\n    // uint 64\n    return uint64(bytes, it);\n\n  } else if (prefix === 0xd0) {\n    // int 8\n    return int8(bytes, it);\n\n  } else if (prefix === 0xd1) {\n    // int 16\n    return int16(bytes, it);\n\n  } else if (prefix === 0xd2) {\n    // int 32\n    return int32(bytes, it);\n\n  } else if (prefix === 0xd3) {\n    // int 64\n    return int64(bytes, it);\n\n  } else if (prefix > 0xdf) {\n    // negative fixint\n    return (0xff - prefix + 1) * -1\n  }\n};\n\nexport function stringCheck(bytes: BufferLike, it: Iterator) {\n  const prefix = bytes[it.offset];\n  return (\n    // fixstr\n    (prefix < 0xc0 && prefix > 0xa0) ||\n    // str 8\n    prefix === 0xd9 ||\n    // str 16\n    prefix === 0xda ||\n    // str 32\n    prefix === 0xdb\n  );\n}\n\nexport const decode = {\n    utf8Read,\n    int8,\n    uint8,\n    int16,\n    uint16,\n    int32,\n    uint32,\n    float32,\n    float64,\n    int64,\n    uint64,\n    bigint64,\n    biguint64,\n    boolean,\n    string,\n    number,\n    stringCheck,\n};", "import { DefinitionType, type } from \"../annotations\";\nimport { BufferLike, encode } from \"../encoding/encode\";\nimport { decode, Iterator } from \"../encoding/decode\";\n\nexport interface TypeDefinition {\n    constructor?: any,\n    encode?: (bytes: BufferLike, value: any, it: Iterator) => any;\n    decode?: (bytes: BufferLike, it: Iterator) => any;\n}\n\nconst registeredTypes: {[identifier: string] : TypeDefinition} = {};\nconst identifiers = new Map<any, string>();\n\nexport function registerType(identifier: string, definition: TypeDefinition) {\n    if (definition.constructor) {\n        identifiers.set(definition.constructor, identifier);\n        registeredTypes[identifier] = definition;\n    }\n\n    if (definition.encode) { encode[identifier] = definition.encode; }\n    if (definition.decode) { decode[identifier] = definition.decode; }\n}\n\nexport function getIdentifier(klass: any): string {\n    return identifiers.get(klass);\n}\n\nexport function getType(identifier: string): TypeDefinition {\n    return registeredTypes[identifier];\n}\n\nexport function defineCustomTypes<T extends {[key: string]: TypeDefinition}>(types: T) {\n    for (const identifier in types) {\n        registerType(identifier, types[identifier]);\n    }\n\n    return (t: keyof T) => type(t as DefinitionType);\n}", "import { Metadata } from \"../Metadata\";\nimport { Schema } from \"../Schema\";\nimport { $viewFieldIndexes } from \"./symbols\";\n\nexport class TypeContext {\n    types: { [id: number]: typeof Schema; } = {};\n    schemas = new Map<typeof Schema, number>();\n\n    hasFilters: boolean = false;\n    parentFiltered: {[typeIdAndParentIndex: string]: boolean} = {};\n\n    /**\n     * For inheritance support\n     * Keeps track of which classes extends which. (parent -> children)\n     */\n    static inheritedTypes = new Map<typeof Schema, Set<typeof Schema>>();\n\n    static register(target: typeof Schema) {\n        const parent = Object.getPrototypeOf(target);\n        if (parent !== Schema) {\n            let inherits = TypeContext.inheritedTypes.get(parent);\n            if (!inherits) {\n                inherits = new Set<typeof Schema>();\n                TypeContext.inheritedTypes.set(parent, inherits);\n            }\n            inherits.add(target);\n        }\n    }\n\n    constructor(rootClass?: typeof Schema) {\n        if (rootClass) {\n            //\n            // TODO:\n            //      cache \"discoverTypes\" results for each rootClass\n            //      to avoid re-discovering types for each new context/room\n            //\n            this.discoverTypes(rootClass);\n        }\n    }\n\n    has(schema: typeof Schema) {\n        return this.schemas.has(schema);\n    }\n\n    get(typeid: number) {\n        return this.types[typeid];\n    }\n\n    add(schema: typeof Schema, typeid = this.schemas.size) {\n        // skip if already registered\n        if (this.schemas.has(schema)) {\n            return false;\n        }\n\n        this.types[typeid] = schema;\n\n        //\n        // Workaround to allow using an empty Schema (with no `@type()` fields)\n        //\n        if (schema[Symbol.metadata] === undefined) {\n            Metadata.initialize(schema);\n        }\n\n        this.schemas.set(schema, typeid);\n        return true;\n    }\n\n    getTypeId(klass: typeof Schema) {\n        return this.schemas.get(klass);\n    }\n\n    private discoverTypes(klass: typeof Schema, parentType?: typeof Schema, parentIndex?: number, parentHasViewTag?: boolean) {\n        if (parentHasViewTag) {\n            this.registerFilteredByParent(klass, parentType, parentIndex);\n        }\n\n        // skip if already registered\n        if (!this.add(klass)) { return; }\n\n        // add classes inherited from this base class\n        TypeContext.inheritedTypes.get(klass)?.forEach((child) => {\n            this.discoverTypes(child, parentType, parentIndex, parentHasViewTag);\n        });\n\n        // add parent classes\n        let parent: any = klass;\n        while (\n            (parent = Object.getPrototypeOf(parent)) &&\n            parent !== Schema && // stop at root (Schema)\n            parent !== Function.prototype // stop at root (non-Schema)\n        ) {\n            this.discoverTypes(parent);\n        }\n\n        const metadata: Metadata = (klass[Symbol.metadata] ??= {});\n\n        // if any schema/field has filters, mark \"context\" as having filters.\n        if (metadata[$viewFieldIndexes]) {\n            this.hasFilters = true;\n        }\n\n        for (const fieldIndex in metadata) {\n            const index = fieldIndex as any as number;\n\n            const fieldType = metadata[index].type;\n            const fieldHasViewTag = (metadata[index].tag !== undefined);\n\n            if (typeof (fieldType) === \"string\") {\n                continue;\n            }\n\n            if (Array.isArray(fieldType)) {\n                const type = fieldType[0];\n\n                // skip primitive types\n                if (type === \"string\") {\n                    continue;\n                }\n\n                this.discoverTypes(type as typeof Schema, klass, index, parentHasViewTag || fieldHasViewTag);\n\n            } else if (typeof (fieldType) === \"function\") {\n                this.discoverTypes(fieldType as typeof Schema, klass, index, parentHasViewTag || fieldHasViewTag);\n\n            } else {\n                const type = Object.values(fieldType)[0];\n\n                // skip primitive types\n                if (typeof (type) === \"string\") {\n                    continue;\n                }\n\n                this.discoverTypes(type as typeof Schema, klass, index, parentHasViewTag || fieldHasViewTag);\n            }\n        }\n    }\n\n    /**\n     * Keep track of which classes have filters applied.\n     * Format: `${typeid}-${parentTypeid}-${parentIndex}`\n     */\n    private registerFilteredByParent(schema: typeof Schema, parentType?: typeof Schema, parentIndex?: number) {\n        const typeid = this.schemas.get(schema) ?? this.schemas.size;\n\n        let key = `${typeid}`;\n        if (parentType) { key += `-${this.schemas.get(parentType)}`; }\n\n        key += `-${parentIndex}`;\n        this.parentFiltered[key] = true;\n    }\n\n    debug() {\n        let parentFiltered = \"\";\n\n        for (const key in this.parentFiltered) {\n            const keys: number[] = key.split(\"-\").map(Number);\n            const fieldIndex = keys.pop();\n\n            parentFiltered += `\\n\\t\\t`;\n            parentFiltered += `${key}: ${keys.reverse().map((id, i) => {\n                const klass = this.types[id];\n                const metadata: Metadata = klass[Symbol.metadata];\n                let txt = klass.name;\n                if (i === 0) { txt += `[${metadata[fieldIndex].name}]`; }\n                return `${txt}`;\n            }).join(\" -> \")}`;\n        }\n\n        return `TypeContext ->\\n` +\n            `\\tSchema types: ${this.schemas.size}\\n` +\n            `\\thasFilters: ${this.hasFilters}\\n` +\n            `\\tparentFiltered:${parentFiltered}`;\n    }\n\n}\n", "import { DefinitionType, getPropertyDescriptor } from \"./annotations\";\nimport { Schema } from \"./Schema\";\nimport { getType } from \"./types/registry\";\nimport { $decoder, $descriptors, $encoder, $fieldIndexesByViewTag, $numFields, $refTypeFieldIndexes, $track, $viewFieldIndexes } from \"./types/symbols\";\nimport { TypeContext } from \"./types/TypeContext\";\n\nexport type MetadataField = {\n    type: DefinitionType,\n    name: string,\n    index: number,\n    tag?: number,\n    unreliable?: boolean,\n    deprecated?: boolean,\n};\n\nexport type Metadata =\n    { [$numFields]: number; } & // number of fields\n    { [$viewFieldIndexes]: number[]; } & // all field indexes with \"view\" tag\n    { [$fieldIndexesByViewTag]: {[tag: number]: number[]}; } & // field indexes by \"view\" tag\n    { [$refTypeFieldIndexes]: number[]; } & // all field indexes containing Ref types (Schema, ArraySchema, MapSchema, etc)\n    { [field: number]: MetadataField; } & // index => field name\n    { [field: string]: number; } & // field name => field metadata\n    { [$descriptors]: { [field: string]: PropertyDescriptor } }  // property descriptors\n\nexport function getNormalizedType(type: DefinitionType): DefinitionType  {\n    return (Array.isArray(type))\n        ? { array: type[0] }\n        : (typeof(type['type']) !== \"undefined\")\n            ? type['type']\n            : type;\n}\n\nexport const Metadata = {\n\n    addField(metadata: any, index: number, name: string, type: DefinitionType, descriptor?: PropertyDescriptor) {\n        if (index > 64) {\n            throw new Error(`Can't define field '${name}'.\\nSchema instances may only have up to 64 fields.`);\n        }\n\n        metadata[index] = Object.assign(\n            metadata[index] || {}, // avoid overwriting previous field metadata (@owned / @deprecated)\n            {\n                type: getNormalizedType(type),\n                index,\n                name,\n            }\n        );\n\n        // create \"descriptors\" map\n        Object.defineProperty(metadata, $descriptors, {\n            value: metadata[$descriptors] || {},\n            enumerable: false,\n            configurable: true,\n        });\n\n        if (descriptor) {\n            // for encoder\n            metadata[$descriptors][name] = descriptor;\n            metadata[$descriptors][`_${name}`] = {\n                value: undefined,\n                writable: true,\n                enumerable: false,\n                configurable: true,\n            };\n        } else {\n            // for decoder\n            metadata[$descriptors][name] = {\n                value: undefined,\n                writable: true,\n                enumerable: true,\n                configurable: true,\n            };\n        }\n\n        // map -1 as last field index\n        Object.defineProperty(metadata, $numFields, {\n            value: index,\n            enumerable: false,\n            configurable: true\n        });\n\n        // map field name => index (non enumerable)\n        Object.defineProperty(metadata, name, {\n            value: index,\n            enumerable: false,\n            configurable: true,\n        });\n\n        // if child Ref/complex type, add to -4\n        if (typeof (metadata[index].type) !== \"string\") {\n            if (metadata[$refTypeFieldIndexes] === undefined) {\n                Object.defineProperty(metadata, $refTypeFieldIndexes, {\n                    value: [],\n                    enumerable: false,\n                    configurable: true,\n                });\n            }\n            metadata[$refTypeFieldIndexes].push(index);\n        }\n    },\n\n    setTag(metadata: Metadata, fieldName: string, tag: number) {\n        const index = metadata[fieldName];\n        const field = metadata[index];\n\n        // add 'tag' to the field\n        field.tag = tag;\n\n        if (!metadata[$viewFieldIndexes]) {\n            // -2: all field indexes with \"view\" tag\n            Object.defineProperty(metadata, $viewFieldIndexes, {\n                value: [],\n                enumerable: false,\n                configurable: true\n            });\n\n            // -3: field indexes by \"view\" tag\n            Object.defineProperty(metadata, $fieldIndexesByViewTag, {\n                value: {},\n                enumerable: false,\n                configurable: true\n            });\n        }\n\n        metadata[$viewFieldIndexes].push(index);\n\n        if (!metadata[$fieldIndexesByViewTag][tag]) {\n            metadata[$fieldIndexesByViewTag][tag] = [];\n        }\n\n        metadata[$fieldIndexesByViewTag][tag].push(index);\n    },\n\n    setFields(target: any, fields: { [field: string]: DefinitionType }) {\n        // for inheritance support\n        const constructor = target.prototype.constructor;\n        TypeContext.register(constructor);\n\n        const parentClass = Object.getPrototypeOf(constructor);\n        const parentMetadata = parentClass && parentClass[Symbol.metadata];\n        const metadata = Metadata.initialize(constructor);\n\n        // Use Schema's methods if not defined in the class\n        if (!constructor[$track]) { constructor[$track] = Schema[$track]; }\n        if (!constructor[$encoder]) { constructor[$encoder] = Schema[$encoder]; }\n        if (!constructor[$decoder]) { constructor[$decoder] = Schema[$decoder]; }\n        if (!constructor.prototype.toJSON) { constructor.prototype.toJSON = Schema.prototype.toJSON; }\n\n        //\n        // detect index for this field, considering inheritance\n        //\n        let fieldIndex = metadata[$numFields] // current structure already has fields defined\n            ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n            ?? -1; // no fields defined\n\n        fieldIndex++;\n\n        for (const field in fields) {\n            const type = fields[field];\n\n            // FIXME: this code is duplicated from @type() annotation\n            const complexTypeKlass = (Array.isArray(type))\n                ? getType(\"array\")\n                : (typeof(Object.keys(type)[0]) === \"string\") && getType(Object.keys(type)[0]);\n\n            const childType = (complexTypeKlass)\n                ? Object.values(type)[0]\n                : getNormalizedType(type);\n\n            Metadata.addField(\n                metadata,\n                fieldIndex,\n                field,\n                type,\n                getPropertyDescriptor(`_${field}`, fieldIndex, childType, complexTypeKlass)\n            );\n\n            fieldIndex++;\n        }\n\n        return target;\n    },\n\n    isDeprecated(metadata: any, field: string) {\n        return metadata[field].deprecated === true;\n    },\n\n    init(klass: any) {\n        //\n        // Used only to initialize an empty Schema (Encoder#constructor)\n        // TODO: remove/refactor this...\n        //\n        const metadata = {};\n        klass[Symbol.metadata] = metadata;\n        Object.defineProperty(metadata, $numFields, {\n            value: 0,\n            enumerable: false,\n            configurable: true,\n        });\n    },\n\n    initialize(constructor: any) {\n        const parentClass = Object.getPrototypeOf(constructor);\n        const parentMetadata: Metadata = parentClass[Symbol.metadata];\n\n        let metadata: Metadata = constructor[Symbol.metadata] ?? Object.create(null);\n\n        // make sure inherited classes have their own metadata object.\n        if (parentClass !== Schema && metadata === parentMetadata) {\n            metadata = Object.create(null);\n\n            if (parentMetadata) {\n                //\n                // assign parent metadata to current\n                //\n                Object.setPrototypeOf(metadata, parentMetadata);\n\n                // $numFields\n                Object.defineProperty(metadata, $numFields, {\n                    value: parentMetadata[$numFields],\n                    enumerable: false,\n                    configurable: true,\n                    writable: true,\n                });\n\n                // $viewFieldIndexes / $fieldIndexesByViewTag\n                if (parentMetadata[$viewFieldIndexes] !== undefined) {\n                    Object.defineProperty(metadata, $viewFieldIndexes, {\n                        value: [...parentMetadata[$viewFieldIndexes]],\n                        enumerable: false,\n                        configurable: true,\n                        writable: true,\n                    });\n                    Object.defineProperty(metadata, $fieldIndexesByViewTag, {\n                        value: { ...parentMetadata[$fieldIndexesByViewTag] },\n                        enumerable: false,\n                        configurable: true,\n                        writable: true,\n                    });\n                }\n\n                // $refTypeFieldIndexes\n                if (parentMetadata[$refTypeFieldIndexes] !== undefined) {\n                    Object.defineProperty(metadata, $refTypeFieldIndexes, {\n                        value: [...parentMetadata[$refTypeFieldIndexes]],\n                        enumerable: false,\n                        configurable: true,\n                        writable: true,\n                    });\n                }\n\n                // $descriptors\n                Object.defineProperty(metadata, $descriptors, {\n                    value: { ...parentMetadata[$descriptors] },\n                    enumerable: false,\n                    configurable: true,\n                    writable: true,\n                });\n            }\n        }\n\n        constructor[Symbol.metadata] = metadata;\n\n        return metadata;\n    },\n\n    isValidInstance(klass: any) {\n        return (\n            klass.constructor[Symbol.metadata] &&\n            Object.prototype.hasOwnProperty.call(klass.constructor[Symbol.metadata], $numFields) as boolean\n        );\n    },\n\n    getFields(klass: any) {\n        const metadata: Metadata = klass[Symbol.metadata];\n        const fields = {};\n        for (let i = 0; i <= metadata[$numFields]; i++) {\n            fields[metadata[i].name] = metadata[i].type;\n        }\n        return fields;\n    }\n}", "import { OPERATION } from \"../encoding/spec\";\nimport { Schema } from \"../Schema\";\nimport { $changes, $childType, $decoder, $onEncodeEnd, $encoder, $getByIndex, $refTypeFieldIndexes, $viewFieldIndexes } from \"../types/symbols\";\n\nimport type { MapSchema } from \"../types/custom/MapSchema\";\nimport type { ArraySchema } from \"../types/custom/ArraySchema\";\nimport type { CollectionSchema } from \"../types/custom/CollectionSchema\";\nimport type { SetSchema } from \"../types/custom/SetSchema\";\n\nimport { Root } from \"./Root\";\nimport { Metadata } from \"../Metadata\";\nimport type { EncodeOperation } from \"./EncodeOperation\";\nimport type { DecodeOperation } from \"../decoder/DecodeOperation\";\n\ndeclare global {\n    interface Object {\n        // FIXME: not a good practice to extend globals here\n        [$changes]?: ChangeTree;\n        [$encoder]?: EncodeOperation,\n        [$decoder]?: DecodeOperation,\n    }\n}\n\nexport type Ref = Schema\n    | ArraySchema\n    | MapSchema\n    | CollectionSchema\n    | SetSchema;\n\nexport type ChangeSetName = \"changes\"\n    | \"allChanges\"\n    | \"filteredChanges\"\n    | \"allFilteredChanges\";\n\nexport interface IndexedOperations {\n    [index: number]: OPERATION;\n}\n\nexport interface ChangeSet {\n    // field index -> operation index\n    indexes: { [index: number]: number };\n    operations: OPERATION[]\n    queueRootIndex?: number; // index of ChangeTree structure in `root.changes` or `root.filteredChanges`\n}\n\nexport function setOperationAtIndex(changeSet: ChangeSet, index: number) {\n    const operationsIndex = changeSet.indexes[index];\n    if (operationsIndex === undefined) {\n        changeSet.indexes[index] = changeSet.operations.push(index) - 1;\n    } else {\n        changeSet.operations[operationsIndex] = index;\n    }\n}\n\nexport function deleteOperationAtIndex(changeSet: ChangeSet, index: number) {\n    const operationsIndex = changeSet.indexes[index];\n    if (operationsIndex !== undefined) {\n        changeSet.operations[operationsIndex] = undefined;\n    }\n    delete changeSet.indexes[index];\n}\n\nexport function enqueueChangeTree(\n    root: Root,\n    changeTree: ChangeTree,\n    changeSet: 'changes' | 'filteredChanges' | 'allFilteredChanges',\n    queueRootIndex = changeTree[changeSet].queueRootIndex\n) {\n    if (root && root[changeSet][queueRootIndex] !== changeTree) {\n        changeTree[changeSet].queueRootIndex = root[changeSet].push(changeTree) - 1;\n    }\n}\n\nexport class ChangeTree<T extends Ref=any> {\n    ref: T;\n    refId: number;\n\n    root?: Root;\n    parent?: Ref;\n    parentIndex?: number;\n\n    /**\n     * Whether this structure is parent of a filtered structure.\n     */\n    isFiltered: boolean = false;\n\n    indexedOperations: IndexedOperations = {};\n\n    //\n    // TODO:\n    //   try storing the index + operation per item.\n    //   example: 1024 & 1025 => ADD, 1026 => DELETE\n    //\n    // => https://chatgpt.com/share/67107d0c-bc20-8004-8583-83b17dd7c196\n    //\n    changes: ChangeSet = { indexes: {}, operations: [] };\n    allChanges: ChangeSet = { indexes: {}, operations: [] };\n    filteredChanges: ChangeSet;\n    allFilteredChanges: ChangeSet;\n\n    indexes: {[index: string]: any}; // TODO: remove this, only used by MapSchema/SetSchema/CollectionSchema (`encodeKeyValueOperation`)\n\n    /**\n     * Is this a new instance? Used on ArraySchema to determine OPERATION.MOVE_AND_ADD operation.\n     */\n    isNew = true;\n\n    constructor(ref: T) {\n        this.ref = ref;\n\n        //\n        // Does this structure have \"filters\" declared?\n        //\n        const metadata = ref.constructor[Symbol.metadata];\n        if (metadata?.[$viewFieldIndexes]) {\n            this.allFilteredChanges = { indexes: {}, operations: [] };\n            this.filteredChanges = { indexes: {}, operations: [] };\n        }\n    }\n\n    setRoot(root: Root) {\n        this.root = root;\n        this.checkIsFiltered(this.parent, this.parentIndex);\n\n        // Recursively set root on child structures\n        const metadata: Metadata = this.ref.constructor[Symbol.metadata];\n        if (metadata) {\n            metadata[$refTypeFieldIndexes]?.forEach((index) => {\n                const field = metadata[index as any as number];\n                const value = this.ref[field.name];\n                value?.[$changes].setRoot(root);\n            });\n\n        } else if (this.ref[$childType] && typeof(this.ref[$childType]) !== \"string\") {\n            // MapSchema / ArraySchema, etc.\n            (this.ref as MapSchema).forEach((value, key) => {\n                value[$changes].setRoot(root);\n            });\n        }\n\n    }\n\n    setParent(\n        parent: Ref,\n        root?: Root,\n        parentIndex?: number,\n    ) {\n        this.parent = parent;\n        this.parentIndex = parentIndex;\n\n        // avoid setting parents with empty `root`\n        if (!root) { return; }\n\n        // skip if parent is already set\n        if (root !== this.root) {\n            this.root = root;\n            this.checkIsFiltered(parent, parentIndex);\n\n        } else {\n            root.add(this);\n        }\n\n        // assign same parent on child structures\n        const metadata: Metadata = this.ref.constructor[Symbol.metadata];\n        if (metadata) {\n            metadata[$refTypeFieldIndexes]?.forEach((index) => {\n                const field = metadata[index as any as number];\n                const value = this.ref[field.name];\n                value?.[$changes].setParent(this.ref, root, index);\n            });\n\n        } else if (this.ref[$childType] && typeof(this.ref[$childType]) !== \"string\") {\n            // MapSchema / ArraySchema, etc.\n            (this.ref as MapSchema).forEach((value, key) => {\n                value[$changes].setParent(this.ref, root, this.indexes[key] ?? key);\n            });\n        }\n\n    }\n\n    forEachChild(callback: (change: ChangeTree, atIndex: number) => void) {\n        //\n        // assign same parent on child structures\n        //\n        const metadata: Metadata = this.ref.constructor[Symbol.metadata];\n        if (metadata) {\n            metadata[$refTypeFieldIndexes]?.forEach((index) => {\n                const field = metadata[index as any as number];\n                const value = this.ref[field.name];\n                if (value) {\n                    callback(value[$changes], index);\n                }\n            });\n\n        } else if (this.ref[$childType] && typeof(this.ref[$childType]) !== \"string\") {\n            // MapSchema / ArraySchema, etc.\n            (this.ref as MapSchema).forEach((value, key) => {\n                callback(value[$changes], this.indexes[key] ?? key);\n            });\n        }\n    }\n\n    operation(op: OPERATION) {\n        // operations without index use negative values to represent them\n        // this is checked during .encode() time.\n        this.changes.operations.push(-op);\n\n        enqueueChangeTree(this.root, this, 'changes');\n    }\n\n    change(index: number, operation: OPERATION = OPERATION.ADD) {\n        const metadata = this.ref.constructor[Symbol.metadata] as Metadata;\n\n        const isFiltered = this.isFiltered || (metadata?.[index]?.tag !== undefined);\n        const changeSet = (isFiltered)\n            ? this.filteredChanges\n            : this.changes;\n\n        const previousOperation = this.indexedOperations[index];\n        if (!previousOperation || previousOperation === OPERATION.DELETE) {\n            const op = (!previousOperation)\n                ? operation\n                : (previousOperation === OPERATION.DELETE)\n                    ? OPERATION.DELETE_AND_ADD\n                    : operation\n            //\n            // TODO: are DELETE operations being encoded as ADD here ??\n            //\n            this.indexedOperations[index] = op;\n        }\n\n        setOperationAtIndex(changeSet, index);\n\n        if (isFiltered) {\n            setOperationAtIndex(this.allFilteredChanges, index);\n\n            if (this.root) {\n                enqueueChangeTree(this.root, this, 'filteredChanges');\n                enqueueChangeTree(this.root, this, 'allFilteredChanges');\n            }\n\n        } else {\n            setOperationAtIndex(this.allChanges, index);\n            enqueueChangeTree(this.root, this, 'changes');\n        }\n    }\n\n    shiftChangeIndexes(shiftIndex: number) {\n        //\n        // Used only during:\n        //\n        // - ArraySchema#unshift()\n        //\n        const changeSet = (this.isFiltered)\n            ? this.filteredChanges\n            : this.changes;\n\n        const newIndexedOperations = {};\n        const newIndexes = {};\n        for (const index in this.indexedOperations) {\n            newIndexedOperations[Number(index) + shiftIndex] = this.indexedOperations[index];\n            newIndexes[Number(index) + shiftIndex] = changeSet[index];\n        }\n        this.indexedOperations = newIndexedOperations;\n        changeSet.indexes = newIndexes;\n\n        changeSet.operations = changeSet.operations.map((index) => index + shiftIndex);\n    }\n\n    shiftAllChangeIndexes(shiftIndex: number, startIndex: number = 0) {\n        //\n        // Used only during:\n        //\n        // - ArraySchema#splice()\n        //\n        if (this.filteredChanges !== undefined) {\n            this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allFilteredChanges);\n            this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allChanges);\n\n        } else {\n            this._shiftAllChangeIndexes(shiftIndex, startIndex, this.allChanges);\n        }\n    }\n\n    private _shiftAllChangeIndexes(shiftIndex: number, startIndex: number = 0, changeSet: ChangeSet) {\n        const newIndexes = {};\n\n        for (const key in changeSet.indexes) {\n            const index = changeSet.indexes[key];\n            if (index > startIndex) {\n                newIndexes[Number(key) + shiftIndex] = index;\n            } else {\n                newIndexes[key] = index;\n            }\n        }\n        changeSet.indexes = newIndexes;\n\n        for (let i = 0; i < changeSet.operations.length; i++) {\n            const index = changeSet.operations[i];\n            if (index > startIndex) {\n                changeSet.operations[i] = index + shiftIndex;\n            }\n        }\n    }\n\n    indexedOperation(index: number, operation: OPERATION, allChangesIndex: number = index) {\n        this.indexedOperations[index] = operation;\n\n        if (this.filteredChanges !== undefined) {\n            setOperationAtIndex(this.allFilteredChanges, allChangesIndex);\n            setOperationAtIndex(this.filteredChanges, index);\n            enqueueChangeTree(this.root, this, 'filteredChanges');\n\n        } else {\n            setOperationAtIndex(this.allChanges, allChangesIndex);\n            setOperationAtIndex(this.changes, index);\n            enqueueChangeTree(this.root, this, 'changes');\n        }\n    }\n\n    getType(index?: number) {\n        if (Metadata.isValidInstance(this.ref)) {\n            const metadata = this.ref.constructor[Symbol.metadata] as Metadata;\n            return metadata[index].type;\n\n        } else {\n            //\n            // Get the child type from parent structure.\n            // - [\"string\"] => \"string\"\n            // - { map: \"string\" } => \"string\"\n            // - { set: \"string\" } => \"string\"\n            //\n            return this.ref[$childType];\n        }\n    }\n\n    getChange(index: number) {\n        return this.indexedOperations[index];\n    }\n\n    //\n    // used during `.encode()`\n    //\n    getValue(index: number, isEncodeAll: boolean = false) {\n        //\n        // `isEncodeAll` param is only used by ArraySchema\n        //\n        return this.ref[$getByIndex](index, isEncodeAll);\n    }\n\n    delete(index: number, operation?: OPERATION, allChangesIndex = index) {\n        if (index === undefined) {\n            try {\n                throw new Error(`@colyseus/schema ${this.ref.constructor.name}: trying to delete non-existing index '${index}'`);\n            } catch (e) {\n                console.warn(e);\n            }\n            return;\n        }\n\n        const changeSet = (this.filteredChanges !== undefined)\n            ? this.filteredChanges\n            : this.changes;\n\n        this.indexedOperations[index] = operation ?? OPERATION.DELETE;\n        setOperationAtIndex(changeSet, index);\n\n        const previousValue = this.getValue(index);\n\n        // remove `root` reference\n        if (previousValue && previousValue[$changes]) {\n            //\n            // FIXME: this.root is \"undefined\"\n            //\n            // This method is being called at decoding time when a DELETE operation is found.\n            //\n            // - This is due to using the concrete Schema class at decoding time.\n            // - \"Reflected\" structures do not have this problem.\n            //\n            // (The property descriptors should NOT be used at decoding time. only at encoding time.)\n            //\n            this.root?.remove(previousValue[$changes]);\n        }\n\n        deleteOperationAtIndex(this.allChanges, allChangesIndex);\n\n        //\n        // FIXME: this is looking a ugly and repeated\n        //\n        if (this.filteredChanges !== undefined) {\n            deleteOperationAtIndex(this.allFilteredChanges, allChangesIndex);\n            enqueueChangeTree(this.root, this, 'filteredChanges');\n\n        } else {\n            enqueueChangeTree(this.root, this, 'changes');\n        }\n\n        return previousValue;\n    }\n\n    endEncode() {\n        this.indexedOperations = {};\n\n        // // clear changes\n        // this.changes.indexes = {};\n        // this.changes.operations.length = 0;\n\n        // ArraySchema and MapSchema have a custom \"encode end\" method\n        this.ref[$onEncodeEnd]?.();\n\n        // Not a new instance anymore\n        this.isNew = false;\n    }\n\n    discard(discardAll: boolean = false) {\n        //\n        // > MapSchema:\n        //      Remove cached key to ensure ADD operations is unsed instead of\n        //      REPLACE in case same key is used on next patches.\n        //\n        this.ref[$onEncodeEnd]?.();\n\n        this.indexedOperations = {};\n\n        this.changes.indexes = {};\n        this.changes.operations.length = 0;\n        this.changes.queueRootIndex = undefined;\n\n        if (this.filteredChanges !== undefined) {\n            this.filteredChanges.indexes = {};\n            this.filteredChanges.operations.length = 0;\n            this.filteredChanges.queueRootIndex = undefined;\n        }\n\n        if (discardAll) {\n            this.allChanges.indexes = {};\n            this.allChanges.operations.length = 0;\n\n            if (this.allFilteredChanges !== undefined) {\n                this.allFilteredChanges.indexes = {};\n                this.allFilteredChanges.operations.length = 0;\n            }\n\n            // remove children references\n            this.forEachChild((changeTree, _) =>\n                this.root?.remove(changeTree));\n        }\n    }\n\n    /**\n     * Recursively discard all changes from this, and child structures.\n     */\n    discardAll() {\n        const keys = Object.keys(this.indexedOperations);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const value = this.getValue(Number(keys[i]));\n\n            if (value && value[$changes]) {\n                value[$changes].discardAll();\n            }\n        }\n\n        this.discard();\n    }\n\n    ensureRefId() {\n        // skip if refId is already set.\n        if (this.refId !== undefined) {\n            return;\n        }\n\n        this.refId = this.root.getNextUniqueId();\n    }\n\n    get changed() {\n        return (Object.entries(this.indexedOperations).length > 0);\n    }\n\n    protected checkIsFiltered(parent: Ref, parentIndex: number) {\n        const isNewChangeTree = this.root.add(this);\n\n        if (this.root.types.hasFilters) {\n            //\n            // At Schema initialization, the \"root\" structure might not be available\n            // yet, as it only does once the \"Encoder\" has been set up.\n            //\n            // So the \"parent\" may be already set without a \"root\".\n            //\n            this._checkFilteredByParent(parent, parentIndex);\n\n            if (this.filteredChanges !== undefined) {\n                enqueueChangeTree(this.root, this, 'filteredChanges');\n                if (isNewChangeTree) {\n                    this.root.allFilteredChanges.push(this);\n                }\n            }\n        }\n\n        if (!this.isFiltered) {\n            enqueueChangeTree(this.root, this, 'changes');\n            if (isNewChangeTree) {\n                this.root.allChanges.push(this);\n            }\n        }\n    }\n\n    protected _checkFilteredByParent(parent: Ref, parentIndex: number) {\n        // skip if parent is not set\n        if (!parent) { return; }\n\n        //\n        // ArraySchema | MapSchema - get the child type\n        // (if refType is typeof string, the parentFiltered[key] below will always be invalid)\n        //\n        const refType = Metadata.isValidInstance(this.ref)\n            ? this.ref.constructor\n            :  this.ref[$childType];\n\n        if (!Metadata.isValidInstance(parent)) {\n            const parentChangeTree = parent[$changes];\n            parent = parentChangeTree.parent;\n            parentIndex = parentChangeTree.parentIndex;\n        }\n\n        const parentConstructor = parent.constructor as typeof Schema;\n\n        let key = `${this.root.types.getTypeId(refType as typeof Schema)}`;\n        if (parentConstructor) {\n            key += `-${this.root.types.schemas.get(parentConstructor)}`;\n        }\n        key += `-${parentIndex}`;\n\n        this.isFiltered = parent[$changes].isFiltered // in case parent is already filtered\n            || this.root.types.parentFiltered[key];\n\n        // const parentMetadata = parentConstructor?.[Symbol.metadata];\n        // this.isFiltered = parentMetadata?.[$viewFieldIndexes]?.includes(parentIndex) || this.root.types.parentFiltered[key];\n\n        //\n        // TODO: refactor this!\n        //\n        //      swapping `changes` and `filteredChanges` is required here\n        //      because \"isFiltered\" may not be imedialely available on `change()`\n        //      (this happens when instance is detached from root or parent)\n        //\n        if (this.isFiltered) {\n            this.filteredChanges = { indexes: {}, operations: [] };\n            this.allFilteredChanges = { indexes: {}, operations: [] };\n\n            if (this.changes.operations.length > 0) {\n                // swap changes reference\n                const changes = this.changes;\n                this.changes = this.filteredChanges;\n                this.filteredChanges = changes;\n\n                // swap \"all changes\" reference\n                const allFilteredChanges = this.allFilteredChanges;\n                this.allFilteredChanges = this.allChanges;\n                this.allChanges = allFilteredChanges;\n            }\n        }\n    }\n\n}\n", "import { OPERATION } from \"../encoding/spec\";\nimport { $changes, $childType, $getByIndex } from \"../types/symbols\";\n\nimport { encode } from \"../encoding/encode\";\n\nimport type { ChangeTree, Ref } from \"./ChangeTree\";\nimport type { Encoder } from \"./Encoder\";\nimport type { Schema } from \"../Schema\";\n\nimport type { Iterator } from \"../encoding/decode\";\nimport type { ArraySchema } from \"../types/custom/ArraySchema\";\nimport type { Metadata } from \"../Metadata\";\n\nexport type EncodeOperation<T extends Ref = any> = (\n    encoder: Encoder,\n    bytes: Buffer,\n    changeTree: ChangeTree<T>,\n    index: number,\n    operation: OPERATION,\n    it: Iterator,\n    isEncodeAll: boolean,\n    hasView: boolean,\n    metadata?: Metadata,\n) => void;\n\nexport function encodeValue(\n    encoder: Encoder,\n    bytes: Buffer,\n    type: any,\n    value: any,\n    operation: OPERATION,\n    it: Iterator,\n) {\n    if (typeof (type) === \"string\") {\n        encode[type]?.(bytes, value, it);\n\n    } else if (type[Symbol.metadata] !== undefined) {\n        //\n        // Encode refId for this instance.\n        // The actual instance is going to be encoded on next `changeTree` iteration.\n        //\n        encode.number(bytes, value[$changes].refId, it);\n\n        // Try to encode inherited TYPE_ID if it's an ADD operation.\n        if ((operation & OPERATION.ADD) === OPERATION.ADD) {\n            encoder.tryEncodeTypeId(bytes, type as typeof Schema, value.constructor as typeof Schema, it);\n        }\n\n    } else {\n        //\n        // Encode refId for this instance.\n        // The actual instance is going to be encoded on next `changeTree` iteration.\n        //\n        encode.number(bytes, value[$changes].refId, it);\n    }\n}\n\n/**\n * Used for Schema instances.\n * @private\n */\nexport const encodeSchemaOperation: EncodeOperation = function (\n    encoder: Encoder,\n    bytes: Buffer,\n    changeTree: ChangeTree<Schema>,\n    index: number,\n    operation: OPERATION,\n    it: Iterator,\n    _: any,\n    __: any,\n    metadata: Metadata,\n) {\n    // \"compress\" field index + operation\n    bytes[it.offset++] = (index | operation) & 255;\n\n    // Do not encode value for DELETE operations\n    if (operation === OPERATION.DELETE) {\n        return;\n    }\n\n    const ref = changeTree.ref;\n    const field = metadata[index];\n\n    // TODO: inline this function call small performance gain\n    encodeValue(\n        encoder,\n        bytes,\n        metadata[index].type,\n        ref[field.name],\n        operation,\n        it\n    );\n}\n\n/**\n * Used for collections (MapSchema, CollectionSchema, SetSchema)\n * @private\n */\nexport const encodeKeyValueOperation: EncodeOperation = function (\n    encoder: Encoder,\n    bytes: Buffer,\n    changeTree: ChangeTree,\n    index: number,\n    operation: OPERATION,\n    it: Iterator,\n) {\n    // encode operation\n    bytes[it.offset++] = operation & 255;\n\n    // custom operations\n    if (operation === OPERATION.CLEAR) {\n        return;\n    }\n\n    // encode index\n    encode.number(bytes, index, it);\n\n    // Do not encode value for DELETE operations\n    if (operation === OPERATION.DELETE) {\n        return;\n    }\n\n    const ref = changeTree.ref;\n\n    //\n    // encode \"alias\" for dynamic fields (maps)\n    //\n    if ((operation & OPERATION.ADD) === OPERATION.ADD) { // ADD or DELETE_AND_ADD\n        if (typeof(ref['set']) === \"function\") {\n            //\n            // MapSchema dynamic key\n            //\n            const dynamicIndex = changeTree.ref['$indexes'].get(index);\n            encode.string(bytes, dynamicIndex, it);\n        }\n    }\n\n    const type = ref[$childType];\n    const value = ref[$getByIndex](index);\n\n    // try { throw new Error(); } catch (e) {\n    //     // only print if not coming from Reflection.ts\n    //     if (!e.stack.includes(\"src/Reflection.ts\")) {\n    //         console.log(\"encodeKeyValueOperation -> \", {\n    //             ref: changeTree.ref.constructor.name,\n    //             field,\n    //             operation: OPERATION[operation],\n    //             value: value?.toJSON(),\n    //             items: ref.toJSON(),\n    //         });\n    //     }\n    // }\n\n    // TODO: inline this function call small performance gain\n    encodeValue(\n        encoder,\n        bytes,\n        type,\n        value,\n        operation,\n        it\n    );\n}\n\n/**\n * Used for collections (MapSchema, ArraySchema, etc.)\n * @private\n */\nexport const encodeArray: EncodeOperation = function (\n    encoder: Encoder,\n    bytes: Buffer,\n    changeTree: ChangeTree<ArraySchema>,\n    field: number,\n    operation: OPERATION,\n    it: Iterator,\n    isEncodeAll: boolean,\n    hasView: boolean,\n) {\n    const ref = changeTree.ref;\n    const useOperationByRefId = hasView && changeTree.isFiltered && (typeof (changeTree.getType(field)) !== \"string\");\n\n    let refOrIndex: number;\n\n    if (useOperationByRefId) {\n        refOrIndex = ref['tmpItems'][field][$changes].refId;\n\n        if (operation === OPERATION.DELETE) {\n            operation = OPERATION.DELETE_BY_REFID;\n\n        } else if (operation === OPERATION.ADD) {\n            operation = OPERATION.ADD_BY_REFID;\n        }\n\n    } else {\n        refOrIndex = field;\n    }\n\n    // encode operation\n    bytes[it.offset++] = operation & 255;\n\n    // custom operations\n    if (\n        operation === OPERATION.CLEAR ||\n        operation === OPERATION.REVERSE\n    ) {\n        return;\n    }\n\n    // encode index\n    encode.number(bytes, refOrIndex, it);\n\n    // Do not encode value for DELETE operations\n    if (operation === OPERATION.DELETE) {\n        return;\n    }\n\n    const type = changeTree.getType(field);\n    const value = changeTree.getValue(field, isEncodeAll);\n\n    // console.log(\"encodeArray -> \", {\n    //     ref: changeTree.ref.constructor.name,\n    //     field,\n    //     operation: OPERATION[operation],\n    //     value: value?.toJSON(),\n    //     items: ref.toJSON(),\n    // });\n\n    // TODO: inline this function call small performance gain\n    encodeValue(\n        encoder,\n        bytes,\n        type,\n        value,\n        operation,\n        it\n    );\n}", "import { OPERATION } from \"../encoding/spec\";\nimport { Metadata } from \"../Metadata\";\nimport { Schema } from \"../Schema\";\nimport type { Ref } from \"../encoder/ChangeTree\";\nimport type { Decoder } from \"./Decoder\";\nimport { Iterator, decode } from \"../encoding/decode\";\nimport { $childType, $deleteByIndex, $getByIndex } from \"../types/symbols\";\n\nimport type { MapSchema } from \"../types/custom/MapSchema\";\nimport type { ArraySchema } from \"../types/custom/ArraySchema\";\nimport type { CollectionSchema } from \"../types/custom/CollectionSchema\";\n\nimport { getType } from \"../types/registry\";\nimport { Collection } from \"../types/HelperTypes\";\n\nexport interface DataChange<T = any, F = string> {\n    ref: Ref,\n    refId: number,\n    op: OPERATION,\n    field: F;\n    dynamicIndex?: number | string;\n    value: T;\n    previousValue: T;\n}\n\nexport const DEFINITION_MISMATCH = -1;\n\nexport type DecodeOperation<T extends Schema = any> = (\n    decoder: Decoder<T>,\n    bytes: Buffer,\n    it: Iterator,\n    ref: Ref,\n    allChanges: DataChange[],\n) => number | void;\n\nexport function decodeValue(\n    decoder: Decoder,\n    operation: OPERATION,\n    ref: Ref,\n    index: number,\n    type: any,\n    bytes: Buffer,\n    it: Iterator,\n    allChanges: DataChange[],\n) {\n    const $root = decoder.root;\n    const previousValue = ref[$getByIndex](index);\n\n    let value: any;\n\n    if ((operation & OPERATION.DELETE) === OPERATION.DELETE)\n    {\n        // Flag `refId` for garbage collection.\n        const previousRefId = $root.refIds.get(previousValue);\n        if (previousRefId !== undefined) { $root.removeRef(previousRefId); }\n\n        //\n        // Delete operations\n        //\n        if (operation !== OPERATION.DELETE_AND_ADD) {\n            ref[$deleteByIndex](index);\n        }\n\n        value = undefined;\n    }\n\n    if (operation === OPERATION.DELETE) {\n        //\n        // Don't do anything\n        //\n\n    } else if (Schema.is(type)) {\n        const refId = decode.number(bytes, it);\n        value = $root.refs.get(refId);\n\n        if (previousValue) {\n            const previousRefId = $root.refIds.get(previousValue);\n            if (\n                previousRefId &&\n                refId !== previousRefId &&\n                // FIXME: we may need to check for REPLACE operation as well\n                ((operation & OPERATION.DELETE) === OPERATION.DELETE)\n            ) {\n                $root.removeRef(previousRefId);\n            }\n        }\n\n        if ((operation & OPERATION.ADD) === OPERATION.ADD) {\n            const childType = decoder.getInstanceType(bytes, it, type);\n            if (!value) {\n                value = decoder.createInstanceOfType(childType);\n            }\n\n            $root.addRef(\n                refId,\n                value,\n                (\n                    value !== previousValue || // increment ref count if value has changed\n                    (operation === OPERATION.DELETE_AND_ADD && value === previousValue) // increment ref count if the same instance is being added again\n                )\n            );\n        }\n\n\n    } else if (typeof(type) === \"string\") {\n        //\n        // primitive value (number, string, boolean, etc)\n        //\n        value = decode[type as string](bytes, it);\n\n    } else {\n        const typeDef = getType(Object.keys(type)[0]);\n        const refId = decode.number(bytes, it);\n\n        const valueRef: Ref = ($root.refs.has(refId))\n            ? previousValue || $root.refs.get(refId)\n            : new typeDef.constructor();\n\n        value = valueRef.clone(true);\n        value[$childType] = Object.values(type)[0]; // cache childType for ArraySchema and MapSchema\n\n        if (previousValue) {\n            let previousRefId = $root.refIds.get(previousValue);\n\n            if (previousRefId !== undefined && refId !== previousRefId) {\n                $root.removeRef(previousRefId);\n\n                //\n                // enqueue onRemove if structure has been replaced.\n                //\n                const entries: IterableIterator<[any, any]> = previousValue.entries();\n                let iter: IteratorResult<[any, any]>;\n                while ((iter = entries.next()) && !iter.done) {\n                    const [key, value] = iter.value;\n\n                    // if value is a schema, remove its reference\n                    // FIXME: not sure if this is necessary, add more tests to confirm\n                    if (typeof(value) === \"object\") {\n                        previousRefId = $root.refIds.get(value);\n                        $root.removeRef(previousRefId);\n                    }\n\n                    allChanges.push({\n                        ref: previousValue,\n                        refId: previousRefId,\n                        op: OPERATION.DELETE,\n                        field: key,\n                        value: undefined,\n                        previousValue: value,\n                    });\n                }\n\n            }\n        }\n\n        $root.addRef(refId, value, (valueRef !== previousValue));\n    }\n\n    return { value, previousValue };\n}\n\nexport const decodeSchemaOperation: DecodeOperation = function (\n    decoder: Decoder<any>,\n    bytes: Buffer,\n    it: Iterator,\n    ref: Ref,\n    allChanges: DataChange[],\n) {\n    const first_byte = bytes[it.offset++];\n    const metadata: Metadata = ref.constructor[Symbol.metadata];\n\n    // \"compressed\" index + operation\n    const operation = (first_byte >> 6) << 6\n    const index = first_byte % (operation || 255);\n\n    // skip early if field is not defined\n    const field = metadata[index];\n    if (field === undefined) {\n        console.warn(\"@colyseus/schema: field not defined at\", { index, ref: ref.constructor.name, metadata });\n        return DEFINITION_MISMATCH;\n    }\n\n    const { value, previousValue } = decodeValue(\n        decoder,\n        operation,\n        ref,\n        index,\n        field.type,\n        bytes,\n        it,\n        allChanges,\n    );\n\n    if (value !== null && value !== undefined) {\n        ref[field.name] = value;\n    }\n\n    // add change\n    if (previousValue !== value) {\n        allChanges.push({\n            ref,\n            refId: decoder.currentRefId,\n            op: operation,\n            field: field.name,\n            value,\n            previousValue,\n        });\n    }\n}\n\nexport const decodeKeyValueOperation: DecodeOperation = function (\n    decoder: Decoder<any>,\n    bytes: Buffer,\n    it: Iterator,\n    ref: Ref,\n    allChanges: DataChange[]\n) {\n    // \"uncompressed\" index + operation (array/map items)\n    const operation = bytes[it.offset++];\n\n    if (operation === OPERATION.CLEAR) {\n        //\n        // When decoding:\n        // - enqueue items for DELETE callback.\n        // - flag child items for garbage collection.\n        //\n        decoder.removeChildRefs(ref as unknown as Collection, allChanges);\n\n        (ref as any).clear();\n        return;\n    }\n\n    const index = decode.number(bytes, it);\n    const type = ref[$childType];\n\n    let dynamicIndex: number | string;\n\n    if ((operation & OPERATION.ADD) === OPERATION.ADD) { // ADD or DELETE_AND_ADD\n        if (typeof(ref['set']) === \"function\") {\n            dynamicIndex = decode.string(bytes, it); // MapSchema\n            ref['setIndex'](index, dynamicIndex);\n        } else {\n            dynamicIndex = index; // ArraySchema\n        }\n    } else {\n        // get dynamic index from \"ref\"\n        dynamicIndex = ref['getIndex'](index);\n    }\n\n\n    const { value, previousValue } = decodeValue(\n        decoder,\n        operation,\n        ref,\n        index,\n        type,\n        bytes,\n        it,\n        allChanges,\n    );\n\n    if (value !== null && value !== undefined) {\n        if (typeof(ref['set']) === \"function\") {\n            // MapSchema\n            (ref as MapSchema)['$items'].set(dynamicIndex as string, value);\n\n        } else if (typeof(ref['$setAt']) === \"function\") {\n            // ArraySchema\n            (ref as ArraySchema)['$setAt'](index, value, operation);\n\n        } else if (typeof(ref['add']) === \"function\") {\n            // CollectionSchema && SetSchema\n            const index = (ref as CollectionSchema).add(value);\n\n            if (typeof(index) === \"number\") {\n                ref['setIndex'](index, index);\n            }\n        }\n    }\n\n    // add change\n    if (previousValue !== value) {\n        allChanges.push({\n            ref,\n            refId: decoder.currentRefId,\n            op: operation,\n            field: \"\", // FIXME: remove this\n            dynamicIndex,\n            value,\n            previousValue,\n        });\n    }\n}\n\nexport const decodeArray: DecodeOperation = function (\n    decoder: Decoder<any>,\n    bytes: Buffer,\n    it: Iterator,\n    ref: ArraySchema,\n    allChanges: DataChange[]\n) {\n    // \"uncompressed\" index + operation (array/map items)\n    let operation = bytes[it.offset++];\n    let index: number;\n\n    if (operation === OPERATION.CLEAR) {\n        //\n        // When decoding:\n        // - enqueue items for DELETE callback.\n        // - flag child items for garbage collection.\n        //\n        decoder.removeChildRefs(ref as unknown as Collection, allChanges);\n        (ref as ArraySchema).clear();\n        return;\n\n    } else if (operation === OPERATION.REVERSE) {\n        (ref as ArraySchema).reverse();\n        return;\n\n    } else if (operation === OPERATION.DELETE_BY_REFID) {\n        // TODO: refactor here, try to follow same flow as below\n        const refId = decode.number(bytes, it);\n        const previousValue = decoder.root.refs.get(refId);\n        index = ref.findIndex((value) => value === previousValue);\n        ref[$deleteByIndex](index);\n        allChanges.push({\n            ref,\n            refId: decoder.currentRefId,\n            op: OPERATION.DELETE,\n            field: \"\", // FIXME: remove this\n            dynamicIndex: index,\n            value: undefined,\n            previousValue,\n        });\n\n        return;\n\n    } else if (operation === OPERATION.ADD_BY_REFID) {\n        const refId = decode.number(bytes, it);\n        const itemByRefId = decoder.root.refs.get(refId);\n\n        // use existing index, or push new value\n        index = (itemByRefId)\n            ? ref.findIndex((value) => value === itemByRefId)\n            : ref.length;\n\n    } else {\n        index = decode.number(bytes, it);\n    }\n\n    const type = ref[$childType];\n\n    let dynamicIndex: number | string = index;\n\n    const { value, previousValue } = decodeValue(\n        decoder,\n        operation,\n        ref,\n        index,\n        type,\n        bytes,\n        it,\n        allChanges,\n    );\n\n    if (\n        value !== null && value !== undefined &&\n        value !== previousValue // avoid setting same value twice (if index === 0 it will result in a \"unshift\" for ArraySchema)\n    ) {\n        // ArraySchema\n        (ref as ArraySchema)['$setAt'](index, value, operation);\n    }\n\n    // add change\n    if (previousValue !== value) {\n        allChanges.push({\n            ref,\n            refId: decoder.currentRefId,\n            op: operation,\n            field: \"\", // FIXME: remove this\n            dynamicIndex,\n            value,\n            previousValue,\n        });\n    }\n}", "import type { Schema } from \"../Schema\";\nimport type { CollectionSchema } from \"../types/custom/CollectionSchema\";\nimport type { MapSchema } from \"../types/custom/MapSchema\";\nimport type { SetSchema } from \"../types/custom/SetSchema\";\nimport type { ArraySchema } from \"../types/custom/ArraySchema\";\nimport type { Ref } from \"../encoder/ChangeTree\";\n\nexport class EncodeSchemaError extends Error {}\n\nexport function assertType(value: any, type: string, klass: Schema, field: string | number) {\n    let typeofTarget: string;\n    let allowNull: boolean = false;\n\n    switch (type) {\n        case \"number\":\n        case \"int8\":\n        case \"uint8\":\n        case \"int16\":\n        case \"uint16\":\n        case \"int32\":\n        case \"uint32\":\n        case \"int64\":\n        case \"uint64\":\n        case \"float32\":\n        case \"float64\":\n            typeofTarget = \"number\";\n            if (isNaN(value)) {\n                console.log(`trying to encode \"NaN\" in ${klass.constructor.name}#${field}`);\n            }\n            break;\n        case \"bigint64\":\n        case \"biguint64\":\n            typeofTarget = \"bigint\";\n            break;\n        case \"string\":\n            typeofTarget = \"string\";\n            allowNull = true;\n            break;\n        case \"boolean\":\n            // boolean is always encoded as true/false based on truthiness\n            return;\n        default:\n            // skip assertion for custom types\n            // TODO: allow custom types to define their own assertions\n            return;\n    }\n\n    if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {\n        let foundValue = `'${JSON.stringify(value)}'${(value && value.constructor && ` (${value.constructor.name})`) || ''}`;\n        throw new EncodeSchemaError(`a '${typeofTarget}' was expected, but ${foundValue} was provided in ${klass.constructor.name}#${field}`);\n    }\n}\n\nexport function assertInstanceType(\n    value: Ref,\n    type: typeof Schema\n        | typeof ArraySchema\n        | typeof MapSchema\n        | typeof CollectionSchema\n        | typeof SetSchema,\n    instance: Ref,\n    field: string | number,\n) {\n    if (!(value instanceof type)) {\n        throw new EncodeSchemaError(`a '${type.name}' was expected, but '${value && (value as any).constructor.name}' was provided in ${instance.constructor.name}#${field}`);\n    }\n}", "import { $changes, $childType, $decoder, $deleteByIndex, $onEncodeEnd, $encoder, $filter, $getByIndex, $onDecodeEnd } from \"../symbols\";\nimport type { Schema } from \"../../Schema\";\nimport { ChangeTree, setOperationAtIndex } from \"../../encoder/ChangeTree\";\nimport { OPERATION } from \"../../encoding/spec\";\nimport { registerType } from \"../registry\";\nimport { Collection } from \"../HelperTypes\";\n\nimport { encodeArray } from \"../../encoder/EncodeOperation\";\nimport { decodeArray } from \"../../decoder/DecodeOperation\";\nimport type { StateView } from \"../../encoder/StateView\";\nimport { assertInstanceType } from \"../../encoding/assert\";\n\nconst DEFAULT_SORT = (a: any, b: any) => {\n    const A = a.toString();\n    const B = b.toString();\n    if (A < B) return -1;\n    else if (A > B) return 1;\n    else return 0\n}\n\nexport class ArraySchema<V = any> implements Array<V>, Collection<number, V> {\n    [n: number]: V;\n\n    protected items: V[] = [];\n    protected tmpItems: V[] = [];\n    protected deletedIndexes: {[index: number]: boolean} = {};\n\n    static [$encoder] = encodeArray;\n    static [$decoder] = decodeArray;\n\n    /**\n     * Determine if a property must be filtered.\n     * - If returns false, the property is NOT going to be encoded.\n     * - If returns true, the property is going to be encoded.\n     *\n     * Encoding with \"filters\" happens in two steps:\n     * - First, the encoder iterates over all \"not owned\" properties and encodes them.\n     * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\n     */\n    static [$filter] (ref: ArraySchema, index: number, view: StateView) {\n        return (\n            !view ||\n            typeof (ref[$childType]) === \"string\" ||\n            // view.items.has(ref[$getByIndex](index)[$changes])\n            view.items.has(ref['tmpItems'][index]?.[$changes])\n        );\n    }\n\n    static is(type: any) {\n        return (\n            // type format: [\"string\"]\n            Array.isArray(type) ||\n\n            // type format: { array: \"string\" }\n            (type['array'] !== undefined)\n        );\n    }\n\n    static from<T>(iterable: Iterable<T> | ArrayLike<T>) {\n        return new ArraySchema<T>(...Array.from(iterable));\n    }\n\n    constructor (...items: V[]) {\n\n        Object.defineProperty(this, $childType, {\n            value: undefined,\n            enumerable: false,\n            writable: true,\n            configurable: true,\n        });\n\n        const proxy = new Proxy(this, {\n            get: (obj, prop) => {\n                if (\n                    typeof (prop) !== \"symbol\" &&\n                    // FIXME: d8 accuses this as low performance\n                    !isNaN(prop as any) // https://stackoverflow.com/a/175787/892698\n                ) {\n                    return this.items[prop];\n\n                } else {\n                    return Reflect.get(obj, prop);\n                }\n            },\n\n            set: (obj, key, setValue) => {\n                if (typeof (key) !== \"symbol\" && !isNaN(key as any)) {\n                    if (setValue === undefined || setValue === null) {\n                        obj.$deleteAt(key as unknown as number);\n\n                    } else {\n                        if (setValue[$changes]) {\n                            assertInstanceType(setValue, obj[$childType] as typeof Schema, obj, key);\n\n                            const previousValue = obj.items[key as unknown as number];\n                            if (previousValue !== undefined) {\n                                if (setValue[$changes].isNew) {\n                                    this[$changes].indexedOperation(Number(key), OPERATION.MOVE_AND_ADD);\n\n                                } else {\n                                    if ((obj[$changes].getChange(Number(key)) & OPERATION.DELETE) === OPERATION.DELETE) {\n                                        this[$changes].indexedOperation(Number(key), OPERATION.DELETE_AND_MOVE);\n                                    } else {\n                                        this[$changes].indexedOperation(Number(key), OPERATION.MOVE);\n                                    }\n                                }\n\n                                // remove root reference from previous value\n                                previousValue[$changes].root?.remove(previousValue[$changes]);\n\n                            } else if (setValue[$changes].isNew) {\n                                this[$changes].indexedOperation(Number(key), OPERATION.ADD);\n                            }\n\n                            setValue[$changes].setParent(this, obj[$changes].root, key);\n\n                        } else {\n                            obj.$changeAt(Number(key), setValue);\n                        }\n\n                        this.items[key as unknown as number] = setValue;\n                        this.tmpItems[key as unknown as number] = setValue;\n                    }\n\n                    return true;\n                } else {\n                    return Reflect.set(obj, key, setValue);\n                }\n            },\n\n            deleteProperty: (obj, prop) => {\n                if (typeof (prop) === \"number\") {\n                    obj.$deleteAt(prop);\n\n                } else {\n                    delete obj[prop];\n                }\n\n                return true;\n            },\n\n            has: (obj, key) => {\n                if (typeof (key) !== \"symbol\" && !isNaN(Number(key))) {\n                    return Reflect.has(this.items, key);\n                }\n                return Reflect.has(obj, key)\n            }\n        });\n\n        this[$changes] = new ChangeTree(proxy);\n        this[$changes].indexes = {};\n\n        if (items.length > 0) {\n            this.push(...items);\n        }\n\n        return proxy;\n    }\n\n    set length (newLength: number) {\n        if (newLength === 0) {\n            this.clear();\n        } else if (newLength < this.items.length) {\n            this.splice(newLength, this.length - newLength);\n        } else {\n            console.warn(\"ArraySchema: can't set .length to a higher value than its length.\");\n        }\n    }\n\n    get length() {\n        return this.items.length;\n    }\n\n    push(...values: V[]) {\n        let length = this.tmpItems.length;\n\n        const changeTree = this[$changes];\n\n        // values.forEach((value, i) => {\n\n        for (let i = 0, l = values.length; i < values.length; i++, length++) {\n            const value = values[i];\n\n            if (value === undefined || value === null) {\n                // skip null values\n                return;\n\n            } else if (typeof (value) === \"object\" && this[$childType]) {\n                assertInstanceType(value as any, this[$childType] as typeof Schema, this, i);\n                // TODO: move value[$changes]?.setParent() to this block.\n            }\n\n            changeTree.indexedOperation(length, OPERATION.ADD, this.items.length);\n\n            this.items.push(value);\n            this.tmpItems.push(value);\n\n            //\n            // set value's parent after the value is set\n            // (to avoid encoding \"refId\" operations before parent's \"ADD\" operation)\n            //\n            value[$changes]?.setParent(this, changeTree.root, length);\n        }\n\n        //     length++;\n        // });\n\n        return length;\n    }\n\n    /**\n     * Removes the last element from an array and returns it.\n     */\n    pop(): V | undefined {\n        let index: number = -1;\n\n        // find last non-undefined index\n        for (let i = this.tmpItems.length - 1; i >= 0; i--) {\n            // if (this.tmpItems[i] !== undefined) {\n            if (this.deletedIndexes[i] !== true) {\n                index = i;\n                break;\n            }\n        }\n\n        if (index < 0) {\n            return undefined;\n        }\n\n        this[$changes].delete(index, undefined, this.items.length - 1);\n\n        // this.tmpItems[index] = undefined;\n        // this.tmpItems.pop();\n\n        this.deletedIndexes[index] = true;\n\n        return this.items.pop();\n    }\n\n    at(index: number) {\n        // Allow negative indexing from the end\n        if (index < 0) index += this.length;\n        return this.items[index];\n    }\n\n    // encoding only\n    protected $changeAt(index: number, value: V) {\n        if (value === undefined || value === null) {\n            console.error(\"ArraySchema items cannot be null nor undefined; Use `deleteAt(index)` instead.\");\n            return;\n        }\n\n        // skip if the value is the same as cached.\n        if (this.items[index] === value) {\n            return;\n        }\n\n        const changeTree = this[$changes];\n        const operation = changeTree.indexes?.[index]?.op ?? OPERATION.ADD;\n\n        changeTree.change(index, operation);\n\n        //\n        // set value's parent after the value is set\n        // (to avoid encoding \"refId\" operations before parent's \"ADD\" operation)\n        //\n        value[$changes]?.setParent(this, changeTree.root, index);\n    }\n\n    // encoding only\n    protected $deleteAt(index: number, operation?: OPERATION) {\n        this[$changes].delete(index, operation);\n    }\n\n    // decoding only\n    protected $setAt(index: number, value: V, operation: OPERATION) {\n        if (\n            index === 0 &&\n            operation === OPERATION.ADD &&\n            this.items[index] !== undefined\n        ) {\n            // handle decoding unshift\n            this.items.unshift(value);\n\n        } else if (operation === OPERATION.DELETE_AND_MOVE) {\n            this.items.splice(index, 1);\n            this.items[index] = value;\n\n        } else {\n            this.items[index] = value;\n        }\n    }\n\n    clear() {\n        // skip if already clear\n        if (this.items.length === 0) {\n            return;\n        }\n\n        // discard previous operations.\n        const changeTree = this[$changes];\n\n        // discard children\n        changeTree.forEachChild((changeTree, _) => {\n            changeTree.discard(true);\n\n            //\n            // TODO: add tests with instance sharing + .clear()\n            // FIXME: this.root? is required because it is being called at decoding time.\n            //\n            // TODO: do not use [$changes] at decoding time.\n            //\n            const root = changeTree.root;\n            if (root !== undefined) {\n                root.removeChangeFromChangeSet(\"changes\", changeTree);\n                root.removeChangeFromChangeSet(\"allChanges\", changeTree);\n                root.removeChangeFromChangeSet(\"allFilteredChanges\", changeTree);\n            }\n        });\n\n        changeTree.discard(true);\n        changeTree.operation(OPERATION.CLEAR);\n\n        this.items.length = 0;\n        this.tmpItems.length = 0;\n    }\n\n    /**\n     * Combines two or more arrays.\n     * @param items Additional items to add to the end of array1.\n     */\n    // @ts-ignore\n    concat(...items: (V | ConcatArray<V>)[]): ArraySchema<V> {\n        return new ArraySchema(...this.items.concat(...items));\n    }\n\n    /**\n     * Adds all the elements of an array separated by the specified separator string.\n     * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.\n     */\n    join(separator?: string): string {\n        return this.items.join(separator);\n    }\n\n    /**\n     * Reverses the elements in an Array.\n     */\n    // @ts-ignore\n    reverse(): ArraySchema<V> {\n        this[$changes].operation(OPERATION.REVERSE);\n        this.items.reverse();\n        this.tmpItems.reverse();\n        return this;\n    }\n\n    /**\n     * Removes the first element from an array and returns it.\n     */\n    shift(): V | undefined {\n        if (this.items.length === 0) { return undefined; }\n\n        // const index = Number(Object.keys(changeTree.indexes)[0]);\n        const index = this.tmpItems.findIndex((item, i) => item === this.items[0]);\n        const changeTree = this[$changes];\n\n        changeTree.delete(index);\n        changeTree.shiftAllChangeIndexes(-1, index);\n\n        // this.deletedIndexes[index] = true;\n\n        return this.items.shift();\n    }\n\n    /**\n     * Returns a section of an array.\n     * @param start The beginning of the specified portion of the array.\n     * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.\n     */\n    slice(start?: number, end?: number): V[] {\n        const sliced = new ArraySchema<V>();\n        sliced.push(...this.items.slice(start, end));\n        return sliced as unknown as V[];\n    }\n\n    /**\n     * Sorts an array.\n     * @param compareFn Function used to determine the order of the elements. It is expected to return\n     * a negative value if first argument is less than second argument, zero if they're equal and a positive\n     * value otherwise. If omitted, the elements are sorted in ascending, ASCII character order.\n     * ```ts\n     * [11,2,22,1].sort((a, b) => a - b)\n     * ```\n     */\n    sort(compareFn: (a: V, b: V) => number = DEFAULT_SORT): this {\n        const changeTree = this[$changes];\n        const sortedItems = this.items.sort(compareFn);\n\n        // wouldn't OPERATION.MOVE make more sense here?\n        sortedItems.forEach((_, i) => changeTree.change(i, OPERATION.REPLACE));\n\n        this.tmpItems.sort(compareFn);\n        return this;\n    }\n\n    /**\n     * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.\n     * @param start The zero-based location in the array from which to start removing elements.\n     * @param deleteCount The number of elements to remove.\n     * @param insertItems Elements to insert into the array in place of the deleted elements.\n     */\n    splice(\n        start: number,\n        deleteCount: number = this.items.length - start,\n        ...insertItems: V[]\n    ): V[] {\n        const changeTree = this[$changes];\n\n        const tmpItemsLength = this.tmpItems.length;\n        const insertCount = insertItems.length;\n\n        // build up-to-date list of indexes, excluding removed values.\n        const indexes: number[] = [];\n        for (let i = 0; i < tmpItemsLength; i++) {\n            // if (this.tmpItems[i] !== undefined) {\n            if (this.deletedIndexes[i] !== true) {\n                indexes.push(i);\n            }\n        }\n\n        // delete operations at correct index\n        for (let i = start; i < start + deleteCount; i++) {\n            const index = indexes[i];\n            changeTree.delete(index);\n            // this.tmpItems[index] = undefined;\n            this.deletedIndexes[index] = true;\n        }\n\n        // force insert operations\n        for (let i = 0; i < insertCount; i++) {\n            const addIndex = indexes[start] + i;\n            changeTree.indexedOperation(addIndex, OPERATION.ADD);\n\n            // set value's parent/root\n            insertItems[i][$changes]?.setParent(this, changeTree.root, addIndex);\n        }\n\n        //\n        // delete exceeding indexes from \"allChanges\"\n        // (prevent .encodeAll() from encoding non-existing items)\n        //\n        if (deleteCount > insertCount) {\n            changeTree.shiftAllChangeIndexes(-(deleteCount - insertCount), indexes[start + insertCount]);\n        }\n\n        return this.items.splice(start, deleteCount, ...insertItems);\n    }\n\n    /**\n     * Inserts new elements at the start of an array.\n     * @param items  Elements to insert at the start of the Array.\n     */\n    unshift(...items: V[]): number {\n        const changeTree = this[$changes];\n\n        // shift indexes\n        changeTree.shiftChangeIndexes(items.length);\n\n        // new index\n        if (changeTree.isFiltered) {\n            setOperationAtIndex(changeTree.filteredChanges, this.items.length);\n            // changeTree.filteredChanges[this.items.length] = OPERATION.ADD;\n        } else {\n            setOperationAtIndex(changeTree.allChanges, this.items.length);\n            // changeTree.allChanges[this.items.length] = OPERATION.ADD;\n        }\n\n        // FIXME: should we use OPERATION.MOVE here instead?\n        items.forEach((_, index) => {\n            changeTree.change(index, OPERATION.ADD)\n        });\n\n        this.tmpItems.unshift(...items);\n\n        return this.items.unshift(...items);\n    }\n\n    /**\n     * Returns the index of the first occurrence of a value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n     */\n    indexOf(searchElement: V, fromIndex?: number): number {\n        return this.items.indexOf(searchElement, fromIndex);\n    }\n\n    /**\n     * Returns the index of the last occurrence of a specified value in an array.\n     * @param searchElement The value to locate in the array.\n     * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.\n     */\n    lastIndexOf(searchElement: V, fromIndex: number = this.length - 1): number {\n        return this.items.lastIndexOf(searchElement, fromIndex);\n    }\n\n    /**\n     * Determines whether all the members of an array satisfy the specified test.\n     * @param callbackfn A function that accepts up to three arguments. The every method calls\n     * the callbackfn function for each element in the array until the callbackfn returns a value\n     * which is coercible to the Boolean value false, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    every<S extends V>(predicate: (value: V, index: number, array: V[]) => value is S, thisArg?: any): this is S[];\n    every(callbackfn: (value: V, index: number, array: V[]) => unknown, thisArg?: any): boolean;\n    every(callbackfn: (value: V, index: number, array: V[]) => unknown, thisArg?: any): boolean {\n        return this.items.every(callbackfn, thisArg);\n    }\n\n    /**\n     * Determines whether the specified callback function returns true for any element of an array.\n     * @param callbackfn A function that accepts up to three arguments. The some method calls\n     * the callbackfn function for each element in the array until the callbackfn returns a value\n     * which is coercible to the Boolean value true, or until the end of the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function.\n     * If thisArg is omitted, undefined is used as the this value.\n     */\n    some(callbackfn: (value: V, index: number, array: V[]) => unknown, thisArg?: any): boolean {\n        return this.items.some(callbackfn, thisArg);\n    }\n\n    /**\n     * Performs the specified action for each element in an array.\n     * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.\n     * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    forEach(callbackfn: (value: V, index: number, array: V[]) => void, thisArg?: any): void {\n        return this.items.forEach(callbackfn, thisArg);\n    }\n\n    /**\n     * Calls a defined callback function on each element of an array, and returns an array that contains the results.\n     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    map<U>(callbackfn: (value: V, index: number, array: V[]) => U, thisArg?: any): U[] {\n        return this.items.map(callbackfn, thisArg);\n    }\n\n    /**\n     * Returns the elements of an array that meet the condition specified in a callback function.\n     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.\n     */\n    filter(callbackfn: (value: V, index: number, array: V[]) => unknown, thisArg?: any): V[]\n    filter<S extends V>(callbackfn: (value: V, index: number, array: V[]) => value is S, thisArg?: any): V[] {\n        return this.items.filter(callbackfn, thisArg);\n    }\n\n    /**\n     * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n     */\n    reduce<U=V>(callbackfn: (previousValue: U, currentValue: V, currentIndex: number, array: V[]) => U, initialValue?: U): U {\n        return this.items.reduce(callbackfn, initialValue);\n    }\n\n    /**\n     * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n     * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.\n     * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n     */\n    reduceRight<U=V>(callbackfn: (previousValue: U, currentValue: V, currentIndex: number, array: V[]) => U, initialValue?: U): U {\n        return this.items.reduceRight(callbackfn, initialValue);\n    }\n\n    /**\n     * Returns the value of the first element in the array where predicate is true, and undefined\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found, find\n     * immediately returns that element value. Otherwise, find returns undefined.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    find(predicate: (value: V, index: number, obj: V[]) => boolean, thisArg?: any): V | undefined {\n        return this.items.find(predicate, thisArg);\n    }\n\n    /**\n     * Returns the index of the first element in the array where predicate is true, and -1\n     * otherwise.\n     * @param predicate find calls predicate once for each element of the array, in ascending\n     * order, until it finds one where predicate returns true. If such an element is found,\n     * findIndex immediately returns that element index. Otherwise, findIndex returns -1.\n     * @param thisArg If provided, it will be used as the this value for each invocation of\n     * predicate. If it is not provided, undefined is used instead.\n     */\n    findIndex(predicate: (value: V, index: number, obj: V[]) => unknown, thisArg?: any): number {\n        return this.items.findIndex(predicate, thisArg);\n    }\n\n    /**\n     * Returns the this object after filling the section identified by start and end with value\n     * @param value value to fill array section with\n     * @param start index to start filling the array at. If start is negative, it is treated as\n     * length+start where length is the length of the array.\n     * @param end index to stop filling the array at. If end is negative, it is treated as\n     * length+end.\n     */\n    fill(value: V, start?: number, end?: number): this {\n        //\n        // TODO\n        //\n        throw new Error(\"ArraySchema#fill() not implemented\");\n        // this.$items.fill(value, start, end);\n\n        return this;\n    }\n\n    /**\n     * Returns the this object after copying a section of the array identified by start and end\n     * to the same array starting at position target\n     * @param target If target is negative, it is treated as length+target where length is the\n     * length of the array.\n     * @param start If start is negative, it is treated as length+start. If end is negative, it\n     * is treated as length+end.\n     * @param end If not specified, length of the this object is used as its default value.\n     */\n    copyWithin(target: number, start: number, end?: number): this {\n        //\n        // TODO\n        //\n        throw new Error(\"ArraySchema#copyWithin() not implemented\");\n        return this;\n    }\n\n    /**\n     * Returns a string representation of an array.\n     */\n    toString(): string {\n        return this.items.toString();\n    }\n\n    /**\n     * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.\n     */\n    toLocaleString(): string {\n        return this.items.toLocaleString()\n    };\n\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<V> {\n        return this.items[Symbol.iterator]();\n    }\n\n    static get [Symbol.species]() {\n        return ArraySchema;\n    }\n\n    // WORKAROUND for compatibility\n    // - TypeScript 4 defines @@unscopables as a function\n    // - TypeScript 5 defines @@unscopables as an object\n    [Symbol.unscopables]: any;\n\n    /**\n     * Returns an iterable of key, value pairs for every entry in the array\n     */\n    entries(): IterableIterator<[number, V]> { return this.items.entries(); }\n\n    /**\n     * Returns an iterable of keys in the array\n     */\n    keys(): IterableIterator<number> { return this.items.keys(); }\n\n    /**\n     * Returns an iterable of values in the array\n     */\n    values(): IterableIterator<V> { return this.items.values(); }\n\n    /**\n     * Determines whether an array includes a certain element, returning true or false as appropriate.\n     * @param searchElement The element to search for.\n     * @param fromIndex The position in this array at which to begin searching for searchElement.\n     */\n    includes(searchElement: V, fromIndex?: number): boolean {\n        return this.items.includes(searchElement, fromIndex);\n    }\n\n    //\n    // ES2022\n    //\n\n    /**\n     * Calls a defined callback function on each element of an array. Then, flattens the result into\n     * a new array.\n     * This is identical to a map followed by flat with depth 1.\n     *\n     * @param callback A function that accepts up to three arguments. The flatMap method calls the\n     * callback function one time for each element in the array.\n     * @param thisArg An object to which the this keyword can refer in the callback function. If\n     * thisArg is omitted, undefined is used as the this value.\n     */\n    // @ts-ignore\n    flatMap<U, This = undefined>(callback: (this: This, value: V, index: number, array: V[]) => U | ReadonlyArray<U>, thisArg?: This): U[] {\n        // @ts-ignore\n        throw new Error(\"ArraySchema#flatMap() is not supported.\");\n    }\n\n    /**\n     * Returns a new array with all sub-array elements concatenated into it recursively up to the\n     * specified depth.\n     *\n     * @param depth The maximum recursion depth\n     */\n    // @ts-ignore\n    flat<A, D extends number = 1>(this: A, depth?: D): any {\n        throw new Error(\"ArraySchema#flat() is not supported.\");\n    }\n\n    findLast() {\n        // @ts-ignore\n        return this.items.findLast.apply(this.items, arguments);\n    }\n\n    findLastIndex(...args) {\n        // @ts-ignore\n        return this.items.findLastIndex.apply(this.items, arguments);\n    }\n\n    //\n    // ES2023\n    //\n    with(index: number, value: V): ArraySchema<V> {\n        const copy = this.items.slice();\n        // Allow negative indexing from the end\n        if (index < 0) index += this.length;\n        copy[index] = value;\n        return new ArraySchema(...copy);\n    }\n    toReversed(): V[] {\n        return this.items.slice().reverse();\n    }\n    toSorted(compareFn?: (a: V, b: V) => number): V[] {\n        return this.items.slice().sort(compareFn);\n    }\n    toSpliced(start: number, deleteCount: number, ...items: V[]): V[];\n    toSpliced(start: number, deleteCount?: number): V[];\n    // @ts-ignore\n    toSpliced(start: unknown, deleteCount?: unknown, ...items?: unknown[]): V[] {\n        // @ts-ignore\n        return this.items.toSpliced.apply(copy, arguments);\n    }\n\n    protected [$getByIndex](index: number, isEncodeAll: boolean = false) {\n        //\n        // TODO: avoid unecessary `this.tmpItems` check during decoding.\n        //\n        //    ENCODING uses `this.tmpItems` (or `this.items` if `isEncodeAll` is true)\n        //    DECODING uses `this.items`\n        //\n\n        return (isEncodeAll)\n            ? this.items[index]\n            : this.deletedIndexes[index]\n                ? this.items[index]\n                : this.tmpItems[index] || this.items[index];\n\n        // return (isEncodeAll)\n        //     ? this.items[index]\n        //     : this.tmpItems[index] ?? this.items[index];\n    }\n\n    protected [$deleteByIndex](index: number) {\n        this.items[index] = undefined;\n        this.tmpItems[index] = undefined; // TODO: do not try to get \"tmpItems\" at decoding time.\n    }\n\n    protected [$onEncodeEnd]() {\n        this.tmpItems = this.items.slice();\n        this.deletedIndexes = {};\n    }\n\n    protected [$onDecodeEnd]() {\n        this.items = this.items.filter((item) => item !== undefined);\n        this.tmpItems = this.items.slice(); // TODO: do no use \"tmpItems\" at decoding time.\n    }\n\n    toArray() {\n        return this.items.slice(0);\n    }\n\n    toJSON() {\n        return this.toArray().map((value) => {\n            return (typeof (value['toJSON']) === \"function\")\n                ? value['toJSON']()\n                : value;\n        });\n    }\n\n    //\n    // Decoding utilities\n    //\n    clone(isDecoding?: boolean): ArraySchema<V> {\n        let cloned: ArraySchema;\n\n        if (isDecoding) {\n            cloned = new ArraySchema();\n            cloned.push(...this.items);\n\n        } else {\n            cloned = new ArraySchema(...this.map(item => (\n                (item[$changes])\n                    ? (item as any as Schema).clone()\n                    : item\n            )));\n        }\n\n        return cloned;\n    };\n\n}\n\nregisterType(\"array\", { constructor: ArraySchema });", "import { $changes, $childType, $decoder, $deleteByIndex, $onEncodeEnd, $encoder, $filter, $getByIndex, $numFields } from \"../symbols\";\nimport { ChangeTree } from \"../../encoder/ChangeTree\";\nimport { OPERATION } from \"../../encoding/spec\";\nimport { registerType } from \"../registry\";\nimport { Collection } from \"../HelperTypes\";\nimport { decodeKeyValueOperation } from \"../../decoder/DecodeOperation\";\nimport { encodeKeyValueOperation } from \"../../encoder/EncodeOperation\";\nimport type { StateView } from \"../../encoder/StateView\";\nimport type { Schema } from \"../../Schema\";\nimport { assertInstanceType } from \"../../encoding/assert\";\n\nexport class MapSchema<V=any, K extends string = string> implements Map<K, V>, Collection<K, V, [K, V]> {\n    protected childType: new () => V;\n\n    protected $items: Map<K, V> = new Map<K, V>();\n    protected $indexes: Map<number, K> = new Map<number, K>();\n    protected deletedItems: { [field: string]: V } = {};\n\n    protected [$changes]: ChangeTree;\n\n    static [$encoder] = encodeKeyValueOperation;\n    static [$decoder] = decodeKeyValueOperation;\n\n    /**\n     * Determine if a property must be filtered.\n     * - If returns false, the property is NOT going to be encoded.\n     * - If returns true, the property is going to be encoded.\n     *\n     * Encoding with \"filters\" happens in two steps:\n     * - First, the encoder iterates over all \"not owned\" properties and encodes them.\n     * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\n     */\n    static [$filter] (ref: MapSchema, index: number, view: StateView) {\n        return (\n            !view ||\n            typeof (ref[$childType]) === \"string\" ||\n            view.items.has((ref[$getByIndex](index) ?? ref.deletedItems[index])[$changes])\n        );\n    }\n\n    static is(type: any) {\n        return type['map'] !== undefined;\n    }\n\n    constructor (initialValues?: Map<K, V> | Record<K, V>) {\n        this[$changes] = new ChangeTree(this);\n        this[$changes].indexes = {};\n\n        if (initialValues) {\n            if (\n                initialValues instanceof Map ||\n                initialValues instanceof MapSchema\n            ) {\n                initialValues.forEach((v, k) => this.set(k, v));\n\n            } else {\n                for (const k in initialValues) {\n                    this.set(k, initialValues[k]);\n                }\n            }\n        }\n\n        Object.defineProperty(this, $childType, {\n            value: undefined,\n            enumerable: false,\n            writable: true,\n            configurable: true,\n        });\n    }\n\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<[K, V]> { return this.$items[Symbol.iterator](); }\n    get [Symbol.toStringTag]() { return this.$items[Symbol.toStringTag] }\n\n    static get [Symbol.species]() { return MapSchema; }\n\n    set(key: K, value: V) {\n        if (value === undefined || value === null) {\n            throw new Error(`MapSchema#set('${key}', ${value}): trying to set ${value} value on '${key}'.`);\n\n        } else if (typeof(value) === \"object\" && this[$childType]) {\n            assertInstanceType(value as any, this[$childType] as typeof Schema, this, key);\n        }\n\n        // Force \"key\" as string\n        // See: https://github.com/colyseus/colyseus/issues/561#issuecomment-1646733468\n        key = key.toString() as K;\n\n        const changeTree = this[$changes];\n        const isRef = (value[$changes]) !== undefined;\n\n        let index: number;\n        let operation: OPERATION;\n\n        // IS REPLACE?\n        if (typeof(changeTree.indexes[key]) !== \"undefined\") {\n            index = changeTree.indexes[key];\n            operation = OPERATION.REPLACE;\n\n            const previousValue = this.$items.get(key);\n            if (previousValue === value) {\n                // if value is the same, avoid re-encoding it.\n                return;\n\n            } else if (isRef) {\n                // if is schema, force ADD operation if value differ from previous one.\n                operation = OPERATION.DELETE_AND_ADD;\n\n                // remove reference from previous value\n                if (previousValue !== undefined) {\n                    previousValue[$changes].root?.remove(previousValue[$changes]);\n                }\n            }\n\n        } else {\n            index = changeTree.indexes[$numFields] ?? 0;\n            operation = OPERATION.ADD;\n\n            this.$indexes.set(index, key);\n            changeTree.indexes[key] = index;\n            changeTree.indexes[$numFields] = index + 1;\n        }\n\n        this.$items.set(key, value);\n\n        changeTree.change(index, operation);\n\n        //\n        // set value's parent after the value is set\n        // (to avoid encoding \"refId\" operations before parent's \"ADD\" operation)\n        //\n        if (isRef) {\n            value[$changes].setParent(this, changeTree.root, index);\n        }\n\n        return this;\n    }\n\n    get(key: K): V | undefined {\n        return this.$items.get(key);\n    }\n\n    delete(key: K) {\n        const index = this[$changes].indexes[key];\n\n        this.deletedItems[index] = this[$changes].delete(index);;\n\n        return this.$items.delete(key);\n    }\n\n    clear() {\n        const changeTree = this[$changes];\n\n        // discard previous operations.\n        changeTree.discard(true);\n        changeTree.indexes = {};\n\n        // clear previous indexes\n        this.$indexes.clear();\n\n        // clear items\n        this.$items.clear();\n\n        changeTree.operation(OPERATION.CLEAR);\n    }\n\n    has (key: K) {\n        return this.$items.has(key);\n    }\n\n    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void) {\n        this.$items.forEach(callbackfn);\n    }\n\n    entries () {\n        return this.$items.entries();\n    }\n\n    keys () {\n        return this.$items.keys();\n    }\n\n    values() {\n        return this.$items.values();\n    }\n\n    get size () {\n        return this.$items.size;\n    }\n\n    protected setIndex(index: number, key: K) {\n        this.$indexes.set(index, key);\n    }\n\n    protected getIndex(index: number) {\n        return this.$indexes.get(index);\n    }\n\n    protected [$getByIndex](index: number) {\n        return this.$items.get(this.$indexes.get(index));\n    }\n\n    protected [$deleteByIndex](index: number) {\n        const key = this.$indexes.get(index);\n        this.$items.delete(key);\n        this.$indexes.delete(index);\n    }\n\n    protected [$onEncodeEnd]() {\n        this.deletedItems = {};\n    }\n\n    toJSON() {\n        const map: any = {};\n\n        this.forEach((value, key) => {\n            map[key] = (typeof (value['toJSON']) === \"function\")\n                ? value['toJSON']()\n                : value;\n        });\n\n        return map;\n    }\n\n    //\n    // Decoding utilities\n    //\n    // @ts-ignore\n    clone(isDecoding?: boolean): MapSchema<V> {\n        let cloned: MapSchema<V>;\n\n        if (isDecoding) {\n            // client-side\n            cloned = Object.assign(new MapSchema(), this);\n\n        } else {\n            // server-side\n            cloned = new MapSchema();\n\n            this.forEach((value, key) => {\n                if (value[$changes]) {\n                    cloned.set(key, value['clone']());\n                } else {\n                    cloned.set(key, value);\n                }\n            })\n\n        }\n\n        return cloned;\n    }\n\n}\n\nregisterType(\"map\", { constructor: MapSchema });", "import \"./symbol.shim\";\nimport { Schema } from './Schema';\nimport { ArraySchema } from './types/custom/ArraySchema';\nimport { MapSchema } from './types/custom/MapSchema';\nimport { Metadata } from \"./Metadata\";\nimport { $changes, $childType, $descriptors, $numFields, $track } from \"./types/symbols\";\nimport { TypeDefinition, getType } from \"./types/registry\";\nimport { OPERATION } from \"./encoding/spec\";\nimport { TypeContext } from \"./types/TypeContext\";\nimport { assertInstanceType, assertType } from \"./encoding/assert\";\nimport type { Ref } from \"./encoder/ChangeTree\";\nimport type { DefinedSchemaType, InferValueType } from \"./types/HelperTypes\";\nimport type { CollectionSchema } from \"./types/custom/CollectionSchema\";\nimport type { SetSchema } from \"./types/custom/SetSchema\";\n\nexport type RawPrimitiveType = \"string\" |\n    \"number\" |\n    \"boolean\" |\n    \"int8\" |\n    \"uint8\" |\n    \"int16\" |\n    \"uint16\" |\n    \"int32\" |\n    \"uint32\" |\n    \"int64\" |\n    \"uint64\" |\n    \"float32\" |\n    \"float64\" |\n    \"bigint64\" |\n    \"biguint64\";\n\nexport type PrimitiveType = RawPrimitiveType | typeof Schema | object;\n\n// TODO: infer \"default\" value type correctly.\nexport type DefinitionType<T extends PrimitiveType = PrimitiveType> = T\n    | T[]\n    | { type: T, default?: InferValueType<T>, view?: boolean | number }\n    | { array: T, default?: ArraySchema<InferValueType<T>>, view?: boolean | number }\n    | { map: T, default?: MapSchema<InferValueType<T>>, view?: boolean | number }\n    | { collection: T, default?: CollectionSchema<InferValueType<T>>, view?: boolean | number }\n    | { set: T, default?: SetSchema<InferValueType<T>>, view?: boolean | number };\n\nexport type Definition = { [field: string]: DefinitionType };\n\nexport interface TypeOptions {\n    manual?: boolean,\n}\n\nexport const DEFAULT_VIEW_TAG = -1;\n\nexport function entity(constructor) {\n    TypeContext.register(constructor);\n    return constructor;\n}\n\n/**\n * [See documentation](https://docs.colyseus.io/state/schema/)\n *\n * Annotate a Schema property to be serializeable.\n * \\@type()'d fields are automatically flagged as \"dirty\" for the next patch.\n *\n * @example Standard usage, with automatic change tracking.\n * ```\n * \\@type(\"string\") propertyName: string;\n * ```\n *\n * @example You can provide the \"manual\" option if you'd like to manually control your patches via .setDirty().\n * ```\n * \\@type(\"string\", { manual: true })\n * ```\n */\n// export function type(type: DefinitionType, options?: TypeOptions) {\n//     return function ({ get, set }, context: ClassAccessorDecoratorContext): ClassAccessorDecoratorResult<Schema, any> {\n//         if (context.kind !== \"accessor\") {\n//             throw new Error(\"@type() is only supported for class accessor properties\");\n//         }\n\n//         const field = context.name.toString();\n\n//         //\n//         // detect index for this field, considering inheritance\n//         //\n//         const parent = Object.getPrototypeOf(context.metadata);\n//         let fieldIndex: number = context.metadata[$numFields] // current structure already has fields defined\n//             ?? (parent && parent[$numFields]) // parent structure has fields defined\n//             ?? -1; // no fields defined\n//         fieldIndex++;\n\n//         if (\n//             !parent && // the parent already initializes the `$changes` property\n//             !Metadata.hasFields(context.metadata)\n//         ) {\n//             context.addInitializer(function (this: Ref) {\n//                 Object.defineProperty(this, $changes, {\n//                     value: new ChangeTree(this),\n//                     enumerable: false,\n//                     writable: true\n//                 });\n//             });\n//         }\n\n//         Metadata.addField(context.metadata, fieldIndex, field, type);\n\n//         const isArray = ArraySchema.is(type);\n//         const isMap = !isArray && MapSchema.is(type);\n\n//         // if (options && options.manual) {\n//         //     // do not declare getter/setter descriptor\n//         //     definition.descriptors[field] = {\n//         //         enumerable: true,\n//         //         configurable: true,\n//         //         writable: true,\n//         //     };\n//         //     return;\n//         // }\n\n//         return {\n//             init(value) {\n//                 // TODO: may need to convert ArraySchema/MapSchema here\n\n//                 // do not flag change if value is undefined.\n//                 if (value !== undefined) {\n//                     this[$changes].change(fieldIndex);\n\n//                     // automaticallty transform Array into ArraySchema\n//                     if (isArray) {\n//                         if (!(value instanceof ArraySchema)) {\n//                             value = new ArraySchema(...value);\n//                         }\n//                         value[$childType] = Object.values(type)[0];\n//                     }\n\n//                     // automaticallty transform Map into MapSchema\n//                     if (isMap) {\n//                         if (!(value instanceof MapSchema)) {\n//                             value = new MapSchema(value);\n//                         }\n//                         value[$childType] = Object.values(type)[0];\n//                     }\n\n//                     // try to turn provided structure into a Proxy\n//                     if (value['$proxy'] === undefined) {\n//                         if (isMap) {\n//                             value = getMapProxy(value);\n//                         }\n//                     }\n\n//                 }\n\n//                 return value;\n//             },\n\n//             get() {\n//                 return get.call(this);\n//             },\n\n//             set(value: any) {\n//                 /**\n//                  * Create Proxy for array or map items\n//                  */\n\n//                 // skip if value is the same as cached.\n//                 if (value === get.call(this)) {\n//                     return;\n//                 }\n\n//                 if (\n//                     value !== undefined &&\n//                     value !== null\n//                 ) {\n//                     // automaticallty transform Array into ArraySchema\n//                     if (isArray) {\n//                         if (!(value instanceof ArraySchema)) {\n//                             value = new ArraySchema(...value);\n//                         }\n//                         value[$childType] = Object.values(type)[0];\n//                     }\n\n//                     // automaticallty transform Map into MapSchema\n//                     if (isMap) {\n//                         if (!(value instanceof MapSchema)) {\n//                             value = new MapSchema(value);\n//                         }\n//                         value[$childType] = Object.values(type)[0];\n//                     }\n\n//                     // try to turn provided structure into a Proxy\n//                     if (value['$proxy'] === undefined) {\n//                         if (isMap) {\n//                             value = getMapProxy(value);\n//                         }\n//                     }\n\n//                     // flag the change for encoding.\n//                     this[$changes].change(fieldIndex);\n\n//                     //\n//                     // call setParent() recursively for this and its child\n//                     // structures.\n//                     //\n//                     if (value[$changes]) {\n//                         value[$changes].setParent(\n//                             this,\n//                             this[$changes].root,\n//                             Metadata.getIndex(context.metadata, field),\n//                         );\n//                     }\n\n//                 } else if (get.call(this)) {\n//                     //\n//                     // Setting a field to `null` or `undefined` will delete it.\n//                     //\n//                     this[$changes].delete(field);\n//                 }\n\n//                 set.call(this, value);\n//             },\n//         };\n//     }\n// }\n\nexport function view<T> (tag: number = DEFAULT_VIEW_TAG) {\n    return function(target: T, fieldName: string) {\n        const constructor = target.constructor as typeof Schema;\n\n        const parentClass = Object.getPrototypeOf(constructor);\n        const parentMetadata = parentClass[Symbol.metadata];\n\n        // TODO: use Metadata.initialize()\n        const metadata: Metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\n        // const fieldIndex = metadata[fieldName];\n\n        // if (!metadata[fieldIndex]) {\n        //     //\n        //     // detect index for this field, considering inheritance\n        //     //\n        //     metadata[fieldIndex] = {\n        //         type: undefined,\n        //         index: (metadata[$numFields] // current structure already has fields defined\n        //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n        //             ?? -1) + 1 // no fields defined\n        //     }\n        // }\n\n        Metadata.setTag(metadata, fieldName, tag);\n    }\n}\n\nexport function unreliable<T> (target: T, field: string) {\n    //\n    // FIXME: the following block of code is repeated across `@type()`, `@deprecated()` and `@unreliable()` decorators.\n    //\n    const constructor = target.constructor as typeof Schema;\n\n    const parentClass = Object.getPrototypeOf(constructor);\n    const parentMetadata = parentClass[Symbol.metadata];\n\n    // TODO: use Metadata.initialize()\n    const metadata: Metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\n\n    // if (!metadata[field]) {\n    //     //\n    //     // detect index for this field, considering inheritance\n    //     //\n    //     metadata[field] = {\n    //         type: undefined,\n    //         index: (metadata[$numFields] // current structure already has fields defined\n    //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n    //             ?? -1) + 1 // no fields defined\n    //     }\n    // }\n\n    // add owned flag to the field\n    metadata[metadata[field]].unreliable = true;\n}\n\nexport function type (\n    type: DefinitionType,\n    options?: TypeOptions\n): PropertyDecorator {\n    return function (target: typeof Schema, field: string) {\n        const constructor = target.constructor as typeof Schema;\n\n        if (!type) {\n            throw new Error(`${constructor.name}: @type() reference provided for \"${field}\" is undefined. Make sure you don't have any circular dependencies.`);\n        }\n\n        // for inheritance support\n        TypeContext.register(constructor);\n\n        const parentClass = Object.getPrototypeOf(constructor);\n        const parentMetadata =  parentClass[Symbol.metadata];\n        const metadata = Metadata.initialize(constructor);\n\n        let fieldIndex: number = metadata[field];\n\n        /**\n         * skip if descriptor already exists for this field (`@deprecated()`)\n         */\n        if (metadata[fieldIndex] !== undefined) {\n            if (metadata[fieldIndex].deprecated) {\n                // do not create accessors for deprecated properties.\n                return;\n\n            } else if (metadata[fieldIndex].type !== undefined) {\n                // trying to define same property multiple times across inheritance.\n                // https://github.com/colyseus/colyseus-unity3d/issues/131#issuecomment-814308572\n                try {\n                    throw new Error(`@colyseus/schema: Duplicate '${field}' definition on '${constructor.name}'.\\nCheck @type() annotation`);\n\n                } catch (e) {\n                    const definitionAtLine = e.stack.split(\"\\n\")[4].trim();\n                    throw new Error(`${e.message} ${definitionAtLine}`);\n                }\n            }\n\n        } else {\n            //\n            // detect index for this field, considering inheritance\n            //\n            fieldIndex = metadata[$numFields] // current structure already has fields defined\n                ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n                ?? -1; // no fields defined\n            fieldIndex++;\n        }\n\n        if (options && options.manual) {\n            Metadata.addField(\n                metadata,\n                fieldIndex,\n                field,\n                type,\n                {\n                    // do not declare getter/setter descriptor\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                }\n            );\n\n        } else {\n            const complexTypeKlass = (Array.isArray(type))\n                ? getType(\"array\")\n                : (typeof(Object.keys(type)[0]) === \"string\") && getType(Object.keys(type)[0]);\n\n            const childType = (complexTypeKlass)\n                ? Object.values(type)[0]\n                : type;\n\n            Metadata.addField(\n                metadata,\n                fieldIndex,\n                field,\n                type,\n                getPropertyDescriptor(`_${field}`, fieldIndex, childType, complexTypeKlass)\n            );\n        }\n    }\n}\n\nexport function getPropertyDescriptor(\n    fieldCached: string,\n    fieldIndex: number,\n    type: DefinitionType,\n    complexTypeKlass: TypeDefinition,\n) {\n    return {\n        get: function () { return this[fieldCached]; },\n        set: function (this: Schema, value: any) {\n            const previousValue = this[fieldCached] ?? undefined;\n\n            // skip if value is the same as cached.\n            if (value === previousValue) { return; }\n\n            if (\n                value !== undefined &&\n                value !== null\n            ) {\n                if (complexTypeKlass) {\n                    // automaticallty transform Array into ArraySchema\n                    if (complexTypeKlass.constructor === ArraySchema && !(value instanceof ArraySchema)) {\n                        value = new ArraySchema(...value);\n                    }\n\n                    // automaticallty transform Map into MapSchema\n                    if (complexTypeKlass.constructor === MapSchema && !(value instanceof MapSchema)) {\n                        value = new MapSchema(value);\n                    }\n\n                    value[$childType] = type;\n\n                } else if (typeof (type) !== \"string\") {\n                    assertInstanceType(value, type as typeof Schema, this, fieldCached.substring(1));\n\n                } else {\n                    assertType(value, type, this, fieldCached.substring(1));\n                }\n\n                const changeTree = this[$changes];\n\n                //\n                // Replacing existing \"ref\", remove it from root.\n                //\n                if (previousValue !== undefined && previousValue[$changes]) {\n                    changeTree.root?.remove(previousValue[$changes]);\n                    this.constructor[$track](changeTree, fieldIndex, OPERATION.DELETE_AND_ADD);\n\n                } else {\n                    this.constructor[$track](changeTree, fieldIndex, OPERATION.ADD);\n                }\n\n                //\n                // call setParent() recursively for this and its child\n                // structures.\n                //\n                (value as Ref)[$changes]?.setParent(this, changeTree.root, fieldIndex);\n\n            } else if (previousValue !== undefined) {\n                //\n                // Setting a field to `null` or `undefined` will delete it.\n                //\n                this[$changes].delete(fieldIndex);\n            }\n\n            this[fieldCached] = value;\n        },\n\n        enumerable: true,\n        configurable: true\n    };\n}\n\n/**\n * `@deprecated()` flag a field as deprecated.\n * The previous `@type()` annotation should remain along with this one.\n */\n\nexport function deprecated(throws: boolean = true): PropertyDecorator {\n    return function (klass: typeof Schema, field: string) {\n        //\n        // FIXME: the following block of code is repeated across `@type()`, `@deprecated()` and `@unreliable()` decorators.\n        //\n        const constructor = klass.constructor as typeof Schema;\n\n        const parentClass = Object.getPrototypeOf(constructor);\n        const parentMetadata = parentClass[Symbol.metadata];\n        const metadata: Metadata = (constructor[Symbol.metadata] ??= Object.assign({}, constructor[Symbol.metadata], parentMetadata ?? Object.create(null)));\n        const fieldIndex = metadata[field];\n\n        // if (!metadata[field]) {\n        //     //\n        //     // detect index for this field, considering inheritance\n        //     //\n        //     metadata[field] = {\n        //         type: undefined,\n        //         index: (metadata[$numFields] // current structure already has fields defined\n        //             ?? (parentMetadata && parentMetadata[$numFields]) // parent structure has fields defined\n        //             ?? -1) + 1 // no fields defined\n        //     }\n        // }\n\n        metadata[fieldIndex].deprecated = true;\n\n        if (throws) {\n            metadata[$descriptors] ??= {};\n            metadata[$descriptors][field] = {\n                get: function () { throw new Error(`${field} is deprecated.`); },\n                set: function (this: Schema, value: any) { /* throw new Error(`${field} is deprecated.`); */ },\n                enumerable: false,\n                configurable: true\n            };\n        }\n\n        // flag metadata[field] as non-enumerable\n        Object.defineProperty(metadata, fieldIndex, {\n            value: metadata[fieldIndex],\n            enumerable: false,\n            configurable: true\n        });\n    }\n}\n\nexport function defineTypes(\n    target: typeof Schema,\n    fields: Definition,\n    options?: TypeOptions\n) {\n    for (let field in fields) {\n        type(fields[field], options)(target.prototype, field);\n    }\n    return target;\n}\n\nexport interface SchemaWithExtends<T extends Definition, P extends typeof Schema> extends DefinedSchemaType<T, P> {\n    extends: <T2 extends Definition>(\n        fields: T2,\n        name?: string\n    ) => SchemaWithExtends<T & T2, typeof this>;\n}\n\nexport function schema<T extends Definition, P extends typeof Schema = typeof Schema>(\n    fields: T,\n    name?: string,\n    inherits: P = Schema as P\n): SchemaWithExtends<T, P> {\n    const defaultValues: any = {};\n    const viewTagFields: any = {};\n\n    for (let fieldName in fields) {\n        const field = fields[fieldName] as DefinitionType;\n        if (typeof (field) === \"object\") {\n            if (field['default'] !== undefined) {\n                defaultValues[fieldName] = field['default'];\n            }\n            if (field['view'] !== undefined) {\n                viewTagFields[fieldName] = (typeof (field['view']) === \"boolean\")\n                    ? DEFAULT_VIEW_TAG\n                    : field['view'];\n            }\n        }\n    }\n\n    const klass = Metadata.setFields(class extends inherits {\n        constructor (...args: any[]) {\n            args[0] = Object.assign({}, defaultValues, args[0]);\n            super(...args);\n        }\n    }, fields) as SchemaWithExtends<T, P>;\n\n    for (let fieldName in viewTagFields) {\n        view(viewTagFields[fieldName])(klass.prototype, fieldName);\n    }\n\n    if (name) {\n        Object.defineProperty(klass, \"name\", { value: name });\n    }\n\n    klass.extends = (fields, name) => schema(fields, name, klass);\n\n    return klass;\n}", "import type { Schema } from \"./Schema\";\nimport { OPERATION } from \"./encoding/spec\";\nimport { $changes } from \"./types/symbols\";\n\ntype ChangeItem = [string, number | string, any?];\n\ninterface ChangeDump {\n    ops: {\n        ADD?: number;\n        REMOVE?: number;\n        REPLACE?: number;\n    },\n    refs: string[],\n}\n\nexport function getIndent(level: number) {\n    return (new Array(level).fill(0)).map((_, i) =>\n        (i === level - 1) ? ` ` : `   `\n    ).join(\"\");\n}\n\nexport function dumpChanges(schema: Schema) {\n    const $root = schema[$changes].root;\n\n    const dump: ChangeDump = {\n        ops: {},\n        refs: []\n    };\n\n    // for (const refId in $root.changes) {\n    $root.changes.forEach(changeTree => {\n        const changes = changeTree.indexedOperations;\n\n        dump.refs.push(`refId#${changeTree.refId}`);\n        for (const index in changes) {\n            const op = changes[index];\n            const opName = OPERATION[op];\n            if (!dump.ops[opName]) { dump.ops[opName] = 0; }\n            dump.ops[OPERATION[op]]++;\n        }\n    });\n\n    return dump;\n}\n\nexport function getNextPowerOf2(number: number) {\n    // If number is already a power of 2, return it\n    if ((number & (number - 1)) === 0) {\n        return number;\n    }\n\n    // Find the position of the most significant bit\n    let msbPosition = 0;\n    while (number > 0) {\n        number >>= 1;\n        msbPosition++;\n    }\n\n    // Return the next power of 2\n    return 1 << msbPosition;\n}", "import { OPERATION } from './encoding/spec';\nimport { DEFAULT_VIEW_TAG, type DefinitionType } from \"./annotations\";\n\nimport { NonFunctionPropNames, ToJSON } from './types/HelperTypes';\n\nimport { ChangeSet, ChangeTree, Ref } from './encoder/ChangeTree';\nimport { $changes, $decoder, $deleteByIndex, $descriptors, $encoder, $filter, $getByIndex, $track } from './types/symbols';\nimport { StateView } from './encoder/StateView';\n\nimport { encodeSchemaOperation } from './encoder/EncodeOperation';\nimport { decodeSchemaOperation } from './decoder/DecodeOperation';\nimport type { Metadata } from './Metadata';\nimport { getIndent } from './utils';\n\n/**\n * Schema encoder / decoder\n */\nexport class Schema {\n    static [$encoder] = encodeSchemaOperation;\n    static [$decoder] = decodeSchemaOperation;\n\n    /**\n     * Assign the property descriptors required to track changes on this instance.\n     * @param instance\n     */\n    static initialize(instance: any) {\n        Object.defineProperty(instance, $changes, {\n            value: new ChangeTree(instance),\n            enumerable: false,\n            writable: true\n        });\n\n        Object.defineProperties(instance, instance.constructor[Symbol.metadata]?.[$descriptors] || {});\n    }\n\n    static is(type: DefinitionType) {\n        return typeof(type[Symbol.metadata]) === \"object\";\n        // const metadata = type[Symbol.metadata];\n        // return metadata && Object.prototype.hasOwnProperty.call(metadata, -1);\n    }\n\n    /**\n     * Track property changes\n     */\n    static [$track] (changeTree: ChangeTree, index: number, operation: OPERATION = OPERATION.ADD) {\n        changeTree.change(index, operation);\n    }\n\n    /**\n     * Determine if a property must be filtered.\n     * - If returns false, the property is NOT going to be encoded.\n     * - If returns true, the property is going to be encoded.\n     *\n     * Encoding with \"filters\" happens in two steps:\n     * - First, the encoder iterates over all \"not owned\" properties and encodes them.\n     * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\n     */\n    static [$filter] (ref: Schema, index: number, view: StateView) {\n        const metadata: Metadata = ref.constructor[Symbol.metadata];\n        const tag = metadata[index]?.tag;\n\n        if (view === undefined) {\n            // shared pass/encode: encode if doesn't have a tag\n            return tag === undefined;\n\n        } else if (tag === undefined) {\n            // view pass: no tag\n            return true;\n\n        } else if (tag === DEFAULT_VIEW_TAG) {\n            // view pass: default tag\n            return view.items.has(ref[$changes]);\n\n        } else {\n            // view pass: custom tag\n            const tags = view.tags?.get(ref[$changes]);\n            return tags && tags.has(tag);\n        }\n    }\n\n    // allow inherited classes to have a constructor\n    constructor(...args: any[]) {\n        //\n        // inline\n        // Schema.initialize(this);\n        //\n        Schema.initialize(this);\n\n        //\n        // Assign initial values\n        //\n        if (args[0]) {\n            Object.assign(this, args[0]);\n        }\n    }\n\n    public assign(\n        props: { [prop in NonFunctionPropNames<this>]?: this[prop] } | ToJSON<this>,\n    ) {\n        Object.assign(this, props);\n        return this;\n    }\n\n    /**\n     * (Server-side): Flag a property to be encoded for the next patch.\n     * @param instance Schema instance\n     * @param property string representing the property name, or number representing the index of the property.\n     * @param operation OPERATION to perform (detected automatically)\n     */\n    public setDirty<K extends NonFunctionPropNames<this>>(property: K | number, operation?: OPERATION) {\n        const metadata: Metadata = this.constructor[Symbol.metadata];\n        this[$changes].change(\n            metadata[metadata[property as string]].index,\n            operation\n        );\n    }\n\n    clone (): this {\n        const cloned = new ((this as any).constructor);\n        const metadata: Metadata = this.constructor[Symbol.metadata];\n\n        //\n        // TODO: clone all properties, not only annotated ones\n        //\n        // for (const field in this) {\n        for (const fieldIndex in metadata) {\n            // const field = metadata[metadata[fieldIndex]].name;\n            const field = metadata[fieldIndex as any as number].name;\n\n            if (\n                typeof (this[field]) === \"object\" &&\n                typeof (this[field]?.clone) === \"function\"\n            ) {\n                // deep clone\n                cloned[field] = this[field].clone();\n\n            } else {\n                // primitive values\n                cloned[field] = this[field];\n            }\n        }\n\n        return cloned;\n    }\n\n    toJSON () {\n        const obj: unknown = {};\n        const metadata = this.constructor[Symbol.metadata];\n        for (const index in metadata) {\n            const field = metadata[index];\n            const fieldName = field.name;\n            if (!field.deprecated && this[fieldName] !== null && typeof (this[fieldName]) !== \"undefined\") {\n                obj[fieldName] = (typeof (this[fieldName]['toJSON']) === \"function\")\n                    ? this[fieldName]['toJSON']()\n                    : this[fieldName];\n            }\n        }\n        return obj as ToJSON<typeof this>;\n    }\n\n    discardAllChanges() {\n        this[$changes].discardAll();\n    }\n\n    protected [$getByIndex](index: number) {\n        const metadata: Metadata = this.constructor[Symbol.metadata];\n        return this[metadata[index].name];\n    }\n\n    protected [$deleteByIndex](index: number) {\n        const metadata: Metadata = this.constructor[Symbol.metadata];\n        this[metadata[index].name] = undefined;\n    }\n\n    /**\n     * Inspect the `refId` of all Schema instances in the tree. Optionally display the contents of the instance.\n     *\n     * @param ref Schema instance\n     * @param showContents display JSON contents of the instance\n     * @returns\n     */\n    static debugRefIds(ref: Ref, showContents: boolean = false, level: number = 0) {\n        const contents = (showContents) ? ` - ${JSON.stringify(ref.toJSON())}` : \"\";\n\n        const changeTree: ChangeTree = ref[$changes];\n        const refId = changeTree.refId;\n\n        let output = \"\";\n        output += `${getIndent(level)}${ref.constructor.name} (refId: ${refId})${contents}\\n`;\n\n        changeTree.forEachChild((childChangeTree) =>\n            output += this.debugRefIds(childChangeTree.ref, showContents, level + 1));\n\n        return output;\n    }\n\n    /**\n     * Return a string representation of the changes on a Schema instance.\n     * The list of changes is cleared after each encode.\n     *\n     * @param instance Schema instance\n     * @param isEncodeAll Return \"full encode\" instead of current change set.\n     * @returns\n     */\n    static debugChanges(instance: Ref, isEncodeAll: boolean = false) {\n        const changeTree: ChangeTree = instance[$changes];\n\n        const changeSet = (isEncodeAll) ? changeTree.allChanges : changeTree.changes;\n        const changeSetName = (isEncodeAll) ? \"allChanges\" : \"changes\";\n\n        let output = `${instance.constructor.name} (${changeTree.refId}) -> .${changeSetName}:\\n`;\n\n        function dumpChangeSet(changeSet: ChangeSet) {\n            changeSet.operations\n                .filter(op => op)\n                .forEach((index) => {\n                    const operation = changeTree.indexedOperations[index];\n                    console.log({ index, operation })\n                    output += `- [${index}]: ${OPERATION[operation]} (${JSON.stringify(changeTree.getValue(Number(index), isEncodeAll))})\\n`\n                });\n        }\n\n        dumpChangeSet(changeSet);\n\n        // display filtered changes\n        if (\n            !isEncodeAll &&\n            changeTree.filteredChanges &&\n            (changeTree.filteredChanges.operations).filter(op => op).length > 0\n        ) {\n            output += `${instance.constructor.name} (${changeTree.refId}) -> .filteredChanges:\\n`;\n            dumpChangeSet(changeTree.filteredChanges);\n        }\n\n        // display filtered changes\n        if (\n            isEncodeAll &&\n            changeTree.allFilteredChanges &&\n            (changeTree.allFilteredChanges.operations).filter(op => op).length > 0\n        ) {\n            output += `${instance.constructor.name} (${changeTree.refId}) -> .allFilteredChanges:\\n`;\n            dumpChangeSet(changeTree.allFilteredChanges);\n        }\n\n        return output;\n    }\n\n    static debugChangesDeep(ref: Ref, changeSetName: \"changes\" | \"allChanges\" | \"allFilteredChanges\" | \"filteredChanges\" = \"changes\") {\n        let output = \"\";\n\n        const rootChangeTree = ref[$changes];\n        const root = rootChangeTree.root;\n        const changeTrees: Map<ChangeTree, ChangeTree[]> = new Map();\n\n        const instanceRefIds = [];\n        let totalOperations = 0;\n\n        for (const [refId, changes] of Object.entries(root[changeSetName])) {\n            const changeTree = root.changeTrees[refId];\n\n            let includeChangeTree = false;\n            let parentChangeTrees: ChangeTree[] = [];\n            let parentChangeTree = changeTree.parent?.[$changes];\n\n            if (changeTree === rootChangeTree) {\n                includeChangeTree = true;\n\n            } else {\n                while (parentChangeTree !== undefined) {\n                    parentChangeTrees.push(parentChangeTree);\n                    if (parentChangeTree.ref === ref) {\n                        includeChangeTree = true;\n                        break;\n                    }\n                    parentChangeTree = parentChangeTree.parent?.[$changes];\n                }\n            }\n\n            if (includeChangeTree) {\n                instanceRefIds.push(changeTree.refId);\n                totalOperations += Object.keys(changes).length;\n                changeTrees.set(changeTree, parentChangeTrees.reverse());\n            }\n        }\n\n        output += \"---\\n\"\n        output += `root refId: ${rootChangeTree.refId}\\n`;\n        output += `Total instances: ${instanceRefIds.length} (refIds: ${instanceRefIds.join(\", \")})\\n`;\n        output += `Total changes: ${totalOperations}\\n`;\n        output += \"---\\n\"\n\n        // based on root.changes, display a tree of changes that has the \"ref\" instance as parent\n        const visitedParents = new WeakSet<ChangeTree>();\n        for (const [changeTree, parentChangeTrees] of changeTrees.entries()) {\n            parentChangeTrees.forEach((parentChangeTree, level) => {\n                if (!visitedParents.has(parentChangeTree)) {\n                    output += `${getIndent(level)}${parentChangeTree.ref.constructor.name} (refId: ${parentChangeTree.refId})\\n`;\n                    visitedParents.add(parentChangeTree);\n                }\n            });\n\n            const changes = changeTree.indexedOperations;\n            const level = parentChangeTrees.length;\n            const indent = getIndent(level);\n\n            const parentIndex = (level > 0) ? `(${changeTree.parentIndex}) ` : \"\";\n            output += `${indent}${parentIndex}${changeTree.ref.constructor.name} (refId: ${changeTree.refId}) - changes: ${Object.keys(changes).length}\\n`;\n\n            for (const index in changes) {\n                const operation = changes[index];\n                output += `${getIndent(level + 1)}${OPERATION[operation]}: ${index}\\n`;\n            }\n        }\n\n        return `${output}`;\n    }\n\n\n}\n\n", "import { $changes, $childType, $decoder, $deleteByIndex, $encoder, $filter, $getByIndex } from \"../symbols\";\nimport { ChangeTree } from \"../../encoder/ChangeTree\";\nimport { OPERATION } from \"../../encoding/spec\";\nimport { registerType } from \"../registry\";\nimport { Collection } from \"../HelperTypes\";\nimport { decodeKeyValueOperation } from \"../../decoder/DecodeOperation\";\nimport { encodeKeyValueOperation } from \"../../encoder/EncodeOperation\";\nimport type { StateView } from \"../../encoder/StateView\";\n\ntype K = number; // TODO: allow to specify K generic on MapSchema.\n\nexport class CollectionSchema<V=any> implements Collection<K, V>{\n    protected $items: Map<number, V> = new Map<number, V>();\n    protected $indexes: Map<number, number> = new Map<number, number>();\n\n    protected $refId: number = 0;\n\n    static [$encoder] = encodeKeyValueOperation;\n    static [$decoder] = decodeKeyValueOperation;\n\n    /**\n     * Determine if a property must be filtered.\n     * - If returns false, the property is NOT going to be encoded.\n     * - If returns true, the property is going to be encoded.\n     *\n     * Encoding with \"filters\" happens in two steps:\n     * - First, the encoder iterates over all \"not owned\" properties and encodes them.\n     * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\n     */\n    static [$filter] (ref: CollectionSchema, index: number, view: StateView) {\n        return (\n            !view ||\n            typeof (ref[$childType]) === \"string\" ||\n            view.items.has(ref[$getByIndex](index)[$changes])\n        );\n    }\n\n    static is(type: any) {\n        return type['collection'] !== undefined;\n    }\n\n    constructor (initialValues?: Array<V>) {\n        this[$changes] = new ChangeTree(this);\n        this[$changes].indexes = {};\n\n        if (initialValues) {\n            initialValues.forEach((v) => this.add(v));\n        }\n\n        Object.defineProperty(this, $childType, {\n            value: undefined,\n            enumerable: false,\n            writable: true,\n            configurable: true,\n        });\n    }\n\n    add(value: V) {\n        // set \"index\" for reference.\n        const index = this.$refId++;\n\n        const isRef = (value[$changes]) !== undefined;\n        if (isRef) {\n            value[$changes].setParent(this, this[$changes].root, index);\n        }\n\n        this[$changes].indexes[index] = index;\n\n        this.$indexes.set(index, index);\n        this.$items.set(index, value);\n\n        this[$changes].change(index);\n\n        return index;\n    }\n\n    at(index: number): V | undefined {\n        const key = Array.from(this.$items.keys())[index];\n        return this.$items.get(key);\n    }\n\n    entries() {\n        return this.$items.entries();\n    }\n\n    delete(item: V) {\n        const entries = this.$items.entries();\n\n        let index: K;\n        let entry: IteratorResult<[number, V]>;\n        while (entry = entries.next()) {\n            if (entry.done) { break; }\n\n            if (item === entry.value[1]) {\n                index = entry.value[0];\n                break;\n            }\n        }\n\n        if (index === undefined) {\n            return false;\n        }\n\n        this[$changes].delete(index);\n        this.$indexes.delete(index);\n\n        return this.$items.delete(index);\n    }\n\n    clear() {\n        const changeTree = this[$changes];\n\n        // discard previous operations.\n        changeTree.discard(true);\n        changeTree.indexes = {};\n\n        // clear previous indexes\n        this.$indexes.clear();\n\n        // clear items\n        this.$items.clear();\n\n        changeTree.operation(OPERATION.CLEAR);\n    }\n\n    has (value: V): boolean {\n        return Array.from(this.$items.values()).some((v) => v === value);\n    }\n\n    forEach(callbackfn: (value: V, key: K, collection: CollectionSchema<V>) => void) {\n        this.$items.forEach((value, key, _) => callbackfn(value, key, this));\n    }\n\n    values() {\n        return this.$items.values();\n    }\n\n    get size () {\n        return this.$items.size;\n    }\n\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<V> {\n        return this.$items.values();\n    }\n\n    protected setIndex(index: number, key: number) {\n        this.$indexes.set(index, key);\n    }\n\n    protected getIndex(index: number) {\n        return this.$indexes.get(index);\n    }\n\n    protected [$getByIndex](index: number) {\n        return this.$items.get(this.$indexes.get(index));\n    }\n\n    protected [$deleteByIndex](index: number) {\n        const key = this.$indexes.get(index);\n        this.$items.delete(key);\n        this.$indexes.delete(index);\n    }\n\n    toArray() {\n        return Array.from(this.$items.values());\n    }\n\n    toJSON() {\n        const values: V[] = [];\n\n        this.forEach((value, key) => {\n            values.push(\n                (typeof (value['toJSON']) === \"function\")\n                    ? value['toJSON']()\n                    : value\n            );\n        });\n\n        return values;\n    }\n\n    //\n    // Decoding utilities\n    //\n    clone(isDecoding?: boolean): CollectionSchema<V> {\n        let cloned: CollectionSchema;\n\n        if (isDecoding) {\n            // client-side\n            cloned = Object.assign(new CollectionSchema(), this);\n\n        } else {\n            // server-side\n            cloned = new CollectionSchema();\n            this.forEach((value) => {\n                if (value[$changes]) {\n                    cloned.add(value['clone']());\n                } else {\n                    cloned.add(value);\n                }\n            })\n        }\n\n        return cloned;\n    }\n\n}\n\nregisterType(\"collection\", { constructor: CollectionSchema, });", "import { OPERATION } from \"../../encoding/spec\";\nimport { registerType } from \"../registry\";\nimport { $changes, $childType, $decoder, $deleteByIndex, $encoder, $filter, $getByIndex } from \"../symbols\";\nimport { Collection } from \"../HelperTypes\";\nimport { ChangeTree } from \"../../encoder/ChangeTree\";\nimport { encodeKeyValueOperation } from \"../../encoder/EncodeOperation\";\nimport { decodeKeyValueOperation } from \"../../decoder/DecodeOperation\";\nimport type { StateView } from \"../../encoder/StateView\";\n\nexport class SetSchema<V=any> implements Collection<number, V> {\n\n    protected $items: Map<number, V> = new Map<number, V>();\n    protected $indexes: Map<number, number> = new Map<number, number>();\n\n    protected $refId: number = 0;\n\n    static [$encoder] = encodeKeyValueOperation;\n    static [$decoder] = decodeKeyValueOperation;\n\n    /**\n     * Determine if a property must be filtered.\n     * - If returns false, the property is NOT going to be encoded.\n     * - If returns true, the property is going to be encoded.\n     *\n     * Encoding with \"filters\" happens in two steps:\n     * - First, the encoder iterates over all \"not owned\" properties and encodes them.\n     * - Then, the encoder iterates over all \"owned\" properties per instance and encodes them.\n     */\n    static [$filter] (ref: SetSchema, index: number, view: StateView) {\n        return (\n            !view ||\n            typeof (ref[$childType]) === \"string\" ||\n            view.items.has(ref[$getByIndex](index)[$changes])\n        );\n    }\n\n    static is(type: any) {\n        return type['set'] !== undefined;\n    }\n\n    constructor (initialValues?: Array<V>) {\n        this[$changes] = new ChangeTree(this);\n        this[$changes].indexes = {};\n\n        if (initialValues) {\n            initialValues.forEach((v) => this.add(v));\n        }\n\n        Object.defineProperty(this, $childType, {\n            value: undefined,\n            enumerable: false,\n            writable: true,\n            configurable: true,\n        });\n    }\n\n    add(value: V) {\n        // immediatelly return false if value already added.\n        if (this.has(value)) { return false; }\n\n        // set \"index\" for reference.\n        const index = this.$refId++;\n\n        if ((value[$changes]) !== undefined) {\n            value[$changes].setParent(this, this[$changes].root, index);\n        }\n\n        const operation = this[$changes].indexes[index]?.op ?? OPERATION.ADD;\n\n        this[$changes].indexes[index] = index;\n\n        this.$indexes.set(index, index);\n        this.$items.set(index, value);\n\n        this[$changes].change(index, operation);\n        return index;\n    }\n\n    entries () {\n        return this.$items.entries();\n    }\n\n    delete(item: V) {\n        const entries = this.$items.entries();\n\n        let index: number;\n        let entry: IteratorResult<[number, V]>;\n        while (entry = entries.next()) {\n            if (entry.done) { break; }\n\n            if (item === entry.value[1]) {\n                index = entry.value[0];\n                break;\n            }\n        }\n\n        if (index === undefined) {\n            return false;\n        }\n\n        this[$changes].delete(index);\n        this.$indexes.delete(index);\n\n        return this.$items.delete(index);\n    }\n\n    clear() {\n        const changeTree = this[$changes];\n\n        // discard previous operations.\n        changeTree.discard(true);\n        changeTree.indexes = {};\n\n        // clear previous indexes\n        this.$indexes.clear();\n\n        // clear items\n        this.$items.clear();\n\n        changeTree.operation(OPERATION.CLEAR);\n    }\n\n    has (value: V): boolean {\n        const values = this.$items.values();\n\n        let has = false;\n        let entry: IteratorResult<V>;\n\n        while (entry = values.next()) {\n            if (entry.done) { break; }\n            if (value === entry.value) {\n                has = true;\n                break;\n            }\n        }\n\n        return has;\n    }\n\n    forEach(callbackfn: (value: V, key: number, collection: SetSchema<V>) => void) {\n        this.$items.forEach((value, key, _) => callbackfn(value, key, this));\n    }\n\n    values() {\n        return this.$items.values();\n    }\n\n    get size () {\n        return this.$items.size;\n    }\n\n    /** Iterator */\n    [Symbol.iterator](): IterableIterator<V> {\n        return this.$items.values();\n    }\n\n    protected setIndex(index: number, key: number) {\n        this.$indexes.set(index, key);\n    }\n\n    protected getIndex(index: number) {\n        return this.$indexes.get(index);\n    }\n\n    protected [$getByIndex](index: number) {\n        return this.$items.get(this.$indexes.get(index));\n    }\n\n    protected [$deleteByIndex](index: number) {\n        const key = this.$indexes.get(index);\n        this.$items.delete(key);\n        this.$indexes.delete(index);\n    }\n\n    toArray() {\n        return Array.from(this.$items.values());\n    }\n\n    toJSON() {\n        const values: V[] = [];\n\n        this.forEach((value, key) => {\n            values.push(\n                (typeof (value['toJSON']) === \"function\")\n                    ? value['toJSON']()\n                    : value\n            );\n        });\n\n        return values;\n    }\n\n    //\n    // Decoding utilities\n    //\n    clone(isDecoding?: boolean): SetSchema<V> {\n        let cloned: SetSchema;\n\n        if (isDecoding) {\n            // client-side\n            cloned = Object.assign(new SetSchema(), this);\n\n        } else {\n            // server-side\n            cloned = new SetSchema();\n            this.forEach((value) => {\n                if (value[$changes]) {\n                    cloned.add(value['clone']());\n                } else {\n                    cloned.add(value);\n                }\n            })\n        }\n\n        return cloned;\n    }\n\n}\n\nregisterType(\"set\", { constructor: SetSchema });", "/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n", "export function spliceOne(arr: any[], index: number): boolean {\n    // manually splice an array\n    if (index === -1 || index >= arr.length) {\n        return false;\n    }\n\n    const len = arr.length - 1;\n\n    for (let i = index; i < len; i++) {\n        arr[i] = arr[i + 1];\n    }\n\n    arr.length = len;\n\n    return true;\n}", "import { OPERATION } from \"../encoding/spec\";\nimport { TypeContext } from \"../types/TypeContext\";\nimport { spliceOne } from \"../types/utils\";\nimport { ChangeTree, enqueueChangeTree, setOperationAtIndex } from \"./ChangeTree\";\n\nexport class Root {\n    protected nextUniqueId: number = 0;\n\n    refCount: {[id: number]: number} = {};\n    changeTrees: {[refId: number]: ChangeTree} = {};\n\n    // all changes\n    allChanges: ChangeTree[] = [];\n    allFilteredChanges: ChangeTree[] = [];// TODO: do not initialize it if filters are not used\n\n    // pending changes to be encoded\n    changes: ChangeTree[] = [];\n    filteredChanges: ChangeTree[] = [];// TODO: do not initialize it if filters are not used\n\n    constructor(public types: TypeContext) { }\n\n    getNextUniqueId() {\n        return this.nextUniqueId++;\n    }\n\n    add(changeTree: ChangeTree) {\n        // FIXME: move implementation of `ensureRefId` to `Root` class\n        changeTree.ensureRefId();\n\n        const isNewChangeTree = (this.changeTrees[changeTree.refId] === undefined);\n        if (isNewChangeTree) { this.changeTrees[changeTree.refId] = changeTree; }\n\n        const previousRefCount = this.refCount[changeTree.refId];\n        if (previousRefCount === 0) {\n            //\n            // When a ChangeTree is re-added, it means that it was previously removed.\n            // We need to re-add all changes to the `changes` map.\n            //\n            const ops = changeTree.allChanges.operations;\n            let len = ops.length;\n            while (len--) {\n                changeTree.indexedOperations[ops[len]] = OPERATION.ADD;\n                setOperationAtIndex(changeTree.changes, len);\n            }\n        }\n\n        this.refCount[changeTree.refId] = (previousRefCount || 0) + 1;\n\n        return isNewChangeTree;\n    }\n\n    remove(changeTree: ChangeTree) {\n        const refCount = (this.refCount[changeTree.refId]) - 1;\n\n        if (refCount <= 0) {\n            //\n            // Only remove \"root\" reference if it's the last reference\n            //\n            changeTree.root = undefined;\n            delete this.changeTrees[changeTree.refId];\n\n            this.removeChangeFromChangeSet(\"allChanges\", changeTree);\n            this.removeChangeFromChangeSet(\"changes\", changeTree);\n\n            if (changeTree.filteredChanges) {\n                this.removeChangeFromChangeSet(\"allFilteredChanges\", changeTree);\n                this.removeChangeFromChangeSet(\"filteredChanges\", changeTree);\n            }\n\n            this.refCount[changeTree.refId] = 0;\n\n        } else {\n            this.refCount[changeTree.refId] = refCount;\n\n            //\n            // When losing a reference to an instance, it is best to move the\n            // ChangeTree to the end of the encoding queue.\n            //\n            // This way, at decoding time, the instance that contains the\n            // ChangeTree will be available before the ChangeTree itself. If the\n            // containing instance is not available, the Decoder will throw\n            // \"refId not found\" error.\n            //\n            if (changeTree.filteredChanges !== undefined) {\n                this.removeChangeFromChangeSet(\"filteredChanges\", changeTree);\n                enqueueChangeTree(this, changeTree, \"filteredChanges\");\n            } else {\n                this.removeChangeFromChangeSet(\"changes\", changeTree);\n                enqueueChangeTree(this, changeTree, \"changes\");\n            }\n        }\n\n        changeTree.forEachChild((child, _) => this.remove(child));\n\n        return refCount;\n    }\n\n    removeChangeFromChangeSet(changeSetName: \"allChanges\" | \"changes\" | \"filteredChanges\" | \"allFilteredChanges\", changeTree: ChangeTree) {\n        const changeSet = this[changeSetName];\n        if (spliceOne(changeSet, changeSet.indexOf(changeTree))) {\n            changeTree[changeSetName].queueRootIndex = -1;\n            // changeSet[index] = undefined;\n            return true;\n        }\n    }\n\n    clear() {\n        this.changes.length = 0;\n    }\n}\n", "import type { Schema } from \"../Schema\";\nimport { TypeContext } from \"../types/TypeContext\";\nimport { $changes, $encoder, $filter, $getByIndex } from \"../types/symbols\";\n\nimport { encode } from \"../encoding/encode\";\nimport type { Iterator } from \"../encoding/decode\";\n\nimport { OPERATION, SWITCH_TO_STRUCTURE, TYPE_ID } from '../encoding/spec';\nimport { Root } from \"./Root\";\n\nimport type { StateView } from \"./StateView\";\nimport type { Metadata } from \"../Metadata\";\nimport type { ChangeTree } from \"./ChangeTree\";\n\nexport class Encoder<T extends Schema = any> {\n    static BUFFER_SIZE = (typeof(Buffer) !== \"undefined\") && Buffer.poolSize || 8 * 1024; // 8KB\n    sharedBuffer = Buffer.allocUnsafe(Encoder.BUFFER_SIZE);\n\n    context: TypeContext;\n    state: T;\n\n    root: Root;\n\n    constructor(state: T) {\n        //\n        // TODO: cache and restore \"Context\" based on root schema\n        // (to avoid creating a new context for every new room)\n        //\n        this.context = new TypeContext(state.constructor as typeof Schema);\n        this.root = new Root(this.context);\n\n        this.setState(state);\n\n        // console.log(\">>>>>>>>>>>>>>>> Encoder types\");\n        // this.context.schemas.forEach((id, schema) => {\n        //     console.log(\"type:\", id, schema.name, Object.keys(schema[Symbol.metadata]));\n        // });\n    }\n\n    protected setState(state: T) {\n        this.state = state;\n        this.state[$changes].setRoot(this.root);\n    }\n\n    encode(\n        it: Iterator = { offset: 0 },\n        view?: StateView,\n        buffer = this.sharedBuffer,\n        changeSetName: \"changes\" | \"allChanges\" | \"filteredChanges\" | \"allFilteredChanges\" = \"changes\",\n        isEncodeAll = changeSetName === \"allChanges\",\n        initialOffset = it.offset // cache current offset in case we need to resize the buffer\n    ): Buffer {\n        const hasView = (view !== undefined);\n        const rootChangeTree = this.state[$changes];\n\n        const shouldDiscardChanges = !isEncodeAll && !hasView;\n        const changeTrees = this.root[changeSetName];\n\n        for (let i = 0, numChangeTrees = changeTrees.length; i < numChangeTrees; i++) {\n            const changeTree = changeTrees[i];\n\n            if (hasView) {\n                if (!view.items.has(changeTree)) {\n                    view.invisible.add(changeTree);\n                    continue; // skip this change tree\n\n                } else if (view.invisible.has(changeTree)) {\n                    view.invisible.delete(changeTree); // remove from invisible list\n                }\n            }\n\n            const operations = changeTree[changeSetName];\n            const ref = changeTree.ref;\n\n            // TODO: avoid iterating over change tree if no changes were made\n            const numChanges = operations.operations.length;\n            if (numChanges === 0) { continue; }\n\n            const ctor = ref.constructor;\n            const encoder = ctor[$encoder];\n            const filter = ctor[$filter];\n            const metadata = ctor[Symbol.metadata];\n\n            // skip root `refId` if it's the first change tree\n            // (unless it \"hasView\", which will need to revisit the root)\n            if (hasView || it.offset > initialOffset || changeTree !== rootChangeTree) {\n                buffer[it.offset++] = SWITCH_TO_STRUCTURE & 255;\n                encode.number(buffer, changeTree.refId, it);\n            }\n\n            for (let j = 0; j < numChanges; j++) {\n                const fieldIndex = operations.operations[j];\n\n                const operation = (fieldIndex < 0)\n                    ? Math.abs(fieldIndex) // \"pure\" operation without fieldIndex (e.g. CLEAR, REVERSE, etc.)\n                    : (isEncodeAll)\n                        ? OPERATION.ADD\n                        : changeTree.indexedOperations[fieldIndex];\n\n                //\n                // first pass (encodeAll), identify \"filtered\" operations without encoding them\n                // they will be encoded per client, based on their view.\n                //\n                // TODO: how can we optimize filtering out \"encode all\" operations?\n                // TODO: avoid checking if no view tags were defined\n                //\n                if (fieldIndex === undefined || operation === undefined || (filter && !filter(ref, fieldIndex, view))) {\n                    // console.log(\"ADD AS INVISIBLE:\", fieldIndex, changeTree.ref.constructor.name)\n                    // view?.invisible.add(changeTree);\n                    continue;\n                }\n\n                encoder(this, buffer, changeTree, fieldIndex, operation, it, isEncodeAll, hasView, metadata);\n            }\n\n            // if (shouldDiscardChanges) {\n            //     changeTree.discard();\n            //     changeTree.isNew = false; // Not a new instance anymore\n            // }\n        }\n\n        if (it.offset > buffer.byteLength) {\n            // we can assume that n + 1 poolSize will suffice given that we are likely done with encoding at this point\n            // multiples of poolSize are faster to allocate than arbitrary sizes\n            // if we are on an older platform that doesn't implement pooling use 8kb as poolSize (that's the default for node)\n            const newSize = Math.ceil(it.offset / (Buffer.poolSize ?? 8 * 1024)) * (Buffer.poolSize ?? 8 * 1024);\n\n            console.warn(`@colyseus/schema buffer overflow. Encoded state is higher than default BUFFER_SIZE. Use the following to increase default BUFFER_SIZE:\n\n    import { Encoder } from \"@colyseus/schema\";\n    Encoder.BUFFER_SIZE = ${Math.round(newSize / 1024)} * 1024; // ${Math.round(newSize / 1024)} KB\n`);\n\n            //\n            // resize buffer and re-encode (TODO: can we avoid re-encoding here?)\n            // -> No we probably can't unless we catch the need for resize before encoding which is likely more computationally expensive than resizing on demand\n            //\n            buffer = Buffer.alloc(newSize, buffer); // fill with buffer here to memcpy previous encoding steps beyond the initialOffset\n\n            // assign resized buffer to local sharedBuffer\n            if (buffer === this.sharedBuffer) {\n                this.sharedBuffer = buffer;\n            }\n\n            return this.encode({ offset: initialOffset }, view, buffer, changeSetName, isEncodeAll);\n\n        } else {\n            //\n            // only clear changes after making sure buffer resize is not required.\n            //\n            if (shouldDiscardChanges) {\n                //\n                // TODO: avoid iterating over change trees twice.\n                //\n                for (let i = 0, numChangeTrees = changeTrees.length; i < numChangeTrees; i++) {\n                    const changeTree = changeTrees[i];\n                    changeTree.discard();\n                    changeTree.isNew = false; // Not a new instance anymore\n                }\n            }\n\n            return buffer.subarray(0, it.offset);\n        }\n    }\n\n    encodeAll(it: Iterator = { offset: 0 }, buffer: Buffer = this.sharedBuffer) {\n        return this.encode(it, undefined, buffer, \"allChanges\", true);\n    }\n\n    encodeAllView(view: StateView, sharedOffset: number, it: Iterator, bytes = this.sharedBuffer) {\n        const viewOffset = it.offset;\n\n        // try to encode \"filtered\" changes\n        this.encode(it, view, bytes, \"allFilteredChanges\", true, viewOffset);\n\n        return Buffer.concat([\n            bytes.subarray(0, sharedOffset),\n            bytes.subarray(viewOffset, it.offset)\n        ]);\n    }\n\n    debugChanges(field: \"changes\" | \"allFilteredChanges\" | \"allChanges\" | \"filteredChanges\") {\n        const rootChangeSet = (typeof (field) === \"string\")\n            ? this.root[field]\n            : field;\n\n        rootChangeSet.forEach((changeTree) => {\n            const changeSet = changeTree[field];\n\n            const metadata: Metadata = changeTree.ref.constructor[Symbol.metadata];\n            console.log(\"->\", { ref: changeTree.ref.constructor.name, refId: changeTree.refId, changes: Object.keys(changeSet).length });\n            for (const index in changeSet) {\n                const op = changeSet[index];\n                console.log(\"  ->\", {\n                    index,\n                    field: metadata?.[index],\n                    op: OPERATION[op],\n                });\n            }\n        });\n    }\n\n    encodeView(view: StateView, sharedOffset: number, it: Iterator, bytes = this.sharedBuffer) {\n        const viewOffset = it.offset;\n\n        // encode visibility changes (add/remove for this view)\n        for (const [refId, changes] of view.changes) {\n            const changeTree: ChangeTree = this.root.changeTrees[refId];\n\n            if (changeTree === undefined) {\n                // detached instance, remove from view and skip.\n                view.changes.delete(refId);\n                continue;\n            }\n\n            const keys = Object.keys(changes);\n            if (keys.length === 0) {\n                // FIXME: avoid having empty changes if no changes were made\n                // console.log(\"changes.size === 0, skip\", changeTree.ref.constructor.name);\n                continue;\n            }\n\n            const ref = changeTree.ref;\n\n            const ctor = ref.constructor;\n            const encoder = ctor[$encoder];\n            const metadata = ctor[Symbol.metadata];\n\n            bytes[it.offset++] = SWITCH_TO_STRUCTURE & 255;\n            encode.number(bytes, changeTree.refId, it);\n\n            for (let i = 0, numChanges = keys.length; i < numChanges; i++) {\n                const index = Number(keys[i]);\n                // workaround when using view.add() on item that has been deleted from state (see test \"adding to view item that has been removed from state\")\n                const value = changeTree.ref[$getByIndex](index);\n                const operation = (value !== undefined && changes[index]) || OPERATION.DELETE;\n\n                // isEncodeAll = false\n                // hasView = true\n                encoder(this, bytes, changeTree, index, operation, it, false, true, metadata);\n            }\n        }\n\n        //\n        // TODO: only clear view changes after all views are encoded\n        // (to allow re-using StateView's for multiple clients)\n        //\n        // clear \"view\" changes after encoding\n        view.changes.clear();\n\n        // try to encode \"filtered\" changes\n        this.encode(it, view, bytes, \"filteredChanges\", false, viewOffset);\n\n        return Buffer.concat([\n            bytes.subarray(0, sharedOffset),\n            bytes.subarray(viewOffset, it.offset)\n        ]);\n    }\n\n    discardChanges() {\n        // discard shared changes\n        let length = this.root.changes.length;\n        if (length > 0) {\n            while (length--) {\n                this.root.changes[length]?.endEncode();\n            }\n            this.root.changes.length = 0;\n        }\n\n        // discard filtered changes\n        length = this.root.filteredChanges.length;\n        if (length > 0) {\n            while (length--) {\n                this.root.filteredChanges[length]?.endEncode();\n            }\n            this.root.filteredChanges.length = 0;\n        }\n    }\n\n    tryEncodeTypeId (bytes: Buffer, baseType: typeof Schema, targetType: typeof Schema, it: Iterator) {\n        const baseTypeId = this.context.getTypeId(baseType);\n        const targetTypeId = this.context.getTypeId(targetType);\n\n        if (targetTypeId === undefined) {\n            console.warn(`@colyseus/schema WARNING: Class \"${targetType.name}\" is not registered on TypeRegistry - Please either tag the class with @entity or define a @type() field.`);\n            return;\n        }\n\n        if (baseTypeId !== targetTypeId) {\n            bytes[it.offset++] = TYPE_ID & 255;\n            encode.number(bytes, targetTypeId, it);\n        }\n    }\n\n    get hasChanges() {\n        return (\n            this.root.changes.length > 0 ||\n            this.root.filteredChanges.length > 0\n        );\n    }\n}\n", "import { Metadata } from \"../Metadata\";\nimport { $childType } from \"../types/symbols\";\nimport { Ref } from \"../encoder/ChangeTree\";\nimport { spliceOne } from \"../types/utils\";\nimport type { MapSchema } from \"../types/custom/MapSchema\";\nimport { OPERATION } from \"../encoding/spec\";\n\nclass DecodingWarning extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"DecodingWarning\";\n    }\n}\n\n/**\n * Used for decoding only.\n */\n\nexport type SchemaCallbacks = { [field: string | number]: Function[] };\n\nexport class ReferenceTracker {\n    //\n    // Relation of refId => Schema structure\n    // For direct access of structures during decoding time.\n    //\n    public refs = new Map<number, Ref>();\n    public refIds = new WeakMap<Ref, number>();\n\n    public refCounts: { [refId: number]: number; } = {};\n    public deletedRefs = new Set<number>();\n\n    public callbacks: { [refId: number]: SchemaCallbacks } = {};\n    protected nextUniqueId: number = 0;\n\n    getNextUniqueId() {\n        return this.nextUniqueId++;\n    }\n\n    // for decoding\n    addRef(refId: number, ref: Ref, incrementCount: boolean = true) {\n        this.refs.set(refId, ref);\n        this.refIds.set(ref, refId);\n\n        if (incrementCount) {\n            this.refCounts[refId] = (this.refCounts[refId] || 0) + 1;\n        }\n\n        if (this.deletedRefs.has(refId)) {\n            this.deletedRefs.delete(refId);\n        }\n    }\n\n    // for decoding\n    removeRef(refId: number) {\n        const refCount = this.refCounts[refId];\n\n        if (refCount === undefined) {\n            try {\n                throw new DecodingWarning(\"trying to remove refId that doesn't exist: \" + refId);\n            } catch (e) {\n                console.warn(e);\n            }\n            return;\n        }\n\n        if (refCount === 0) {\n            try {\n                const ref = this.refs.get(refId);\n                throw new DecodingWarning(`trying to remove refId '${refId}' with 0 refCount (${ref.constructor.name}: ${JSON.stringify(ref)})`);\n            } catch (e) {\n                console.warn(e);\n            }\n            return;\n        }\n\n        if ((this.refCounts[refId] = refCount - 1) <= 0) {\n            this.deletedRefs.add(refId);\n        }\n    }\n\n    clearRefs() {\n        this.refs.clear();\n        this.deletedRefs.clear();\n        this.callbacks = {};\n        this.refCounts = {};\n    }\n\n    // for decoding\n    garbageCollectDeletedRefs() {\n        this.deletedRefs.forEach((refId) => {\n            //\n            // Skip active references.\n            //\n            if (this.refCounts[refId] > 0) { return; }\n\n            const ref = this.refs.get(refId);\n\n            //\n            // Ensure child schema instances have their references removed as well.\n            //\n            if (Metadata.isValidInstance(ref)) {\n                const metadata: Metadata = ref.constructor[Symbol.metadata];\n                for (const index in metadata) {\n                    const field = metadata[index as any as number].name;\n                    const childRefId = typeof(ref[field]) === \"object\" && this.refIds.get(ref[field]);\n                    if (childRefId) {\n                        this.removeRef(childRefId);\n                    }\n                }\n\n            } else {\n                if (typeof (Object.values(ref[$childType])[0]) === \"function\") {\n                    Array.from((ref as MapSchema).values())\n                        .forEach((child) => this.removeRef(this.refIds.get(child)));\n                }\n            }\n\n            this.refs.delete(refId); // remove ref\n            delete this.refCounts[refId]; // remove ref count\n            delete this.callbacks[refId]; // remove callbacks\n        });\n\n        // clear deleted refs.\n        this.deletedRefs.clear();\n    }\n\n    addCallback(refId: number, fieldOrOperation: string | number, callback: Function) {\n        if (refId === undefined) {\n            const name = (typeof(fieldOrOperation) === \"number\")\n                    ? OPERATION[fieldOrOperation]\n                    : fieldOrOperation\n            throw new Error(\n                `Can't addCallback on '${name}' (refId is undefined)`\n            );\n        }\n        if (!this.callbacks[refId]) {\n            this.callbacks[refId] = {};\n        }\n        if (!this.callbacks[refId][fieldOrOperation]) {\n            this.callbacks[refId][fieldOrOperation] = [];\n        }\n        this.callbacks[refId][fieldOrOperation].push(callback);\n        return () => this.removeCallback(refId, fieldOrOperation, callback);\n    }\n\n    removeCallback(refId: number, field: string | number, callback: Function) {\n        const index = this.callbacks?.[refId]?.[field]?.indexOf(callback);\n        if (index !== -1) {\n            spliceOne(this.callbacks[refId][field], index);\n        }\n    }\n\n}\n", "import { TypeContext } from \"../types/TypeContext\";\nimport { $changes, $childType, $decoder, $onDecodeEnd } from \"../types/symbols\";\nimport { Schema } from \"../Schema\";\n\nimport { decode } from \"../encoding/decode\";\nimport { OPERATION, SWITCH_TO_STRUCTURE, TYPE_ID } from '../encoding/spec';\nimport type { Ref } from \"../encoder/ChangeTree\";\nimport type { Iterator } from \"../encoding/decode\";\nimport { ReferenceTracker } from \"./ReferenceTracker\";\nimport { DEFINITION_MISMATCH, type DataChange, type DecodeOperation } from \"./DecodeOperation\";\nimport { Collection } from \"../types/HelperTypes\";\n\nexport class Decoder<T extends Schema = any> {\n    context: TypeContext;\n\n    state: T;\n    root: ReferenceTracker;\n\n    currentRefId: number = 0;\n\n    triggerChanges?: (allChanges: DataChange[]) => void;\n\n    constructor(root: T, context?: TypeContext) {\n        this.setState(root);\n\n        this.context = context || new TypeContext(root.constructor as typeof Schema);\n\n        // console.log(\">>>>>>>>>>>>>>>> Decoder types\");\n        // this.context.schemas.forEach((id, schema) => {\n        //     console.log(\"type:\", id, schema.name, Object.keys(schema[Symbol.metadata]));\n        // });\n    }\n\n    protected setState(root: T) {\n        this.state = root;\n        this.root = new ReferenceTracker();\n        this.root.addRef(0, root);\n    }\n\n    decode(\n        bytes: Buffer,\n        it: Iterator = { offset: 0 },\n        ref: Ref = this.state,\n    ) {\n        const allChanges: DataChange[] = [];\n\n        const $root = this.root;\n        const totalBytes = bytes.byteLength;\n\n        let decoder: DecodeOperation = ref['constructor'][$decoder];\n\n        this.currentRefId = 0;\n\n        while (it.offset < totalBytes) {\n            //\n            // Peek ahead, check if it's a switch to a different structure\n            //\n            if (bytes[it.offset] == SWITCH_TO_STRUCTURE) {\n                it.offset++;\n\n                this.currentRefId = decode.number(bytes, it);\n                const nextRef = $root.refs.get(this.currentRefId) as Schema;\n\n                //\n                // Trying to access a reference that haven't been decoded yet.\n                //\n                if (!nextRef) { throw new Error(`\"refId\" not found: ${this.currentRefId}`); }\n                ref[$onDecodeEnd]?.()\n                ref = nextRef;\n\n                decoder = ref.constructor[$decoder];\n\n                continue;\n            }\n\n            const result = decoder(this, bytes, it, ref, allChanges);\n\n            if (result === DEFINITION_MISMATCH) {\n                console.warn(\"@colyseus/schema: definition mismatch\");\n\n                //\n                // keep skipping next bytes until reaches a known structure\n                // by local decoder.\n                //\n                const nextIterator: Iterator = { offset: it.offset };\n                while (it.offset < totalBytes) {\n                    if (bytes[it.offset] === SWITCH_TO_STRUCTURE) {\n                        nextIterator.offset = it.offset + 1;\n                        if ($root.refs.has(decode.number(bytes, nextIterator))) {\n                            break;\n                        }\n                    }\n\n                    it.offset++;\n                }\n                continue;\n            }\n        }\n\n        // FIXME: DRY with SWITCH_TO_STRUCTURE block.\n        ref[$onDecodeEnd]?.()\n\n        // trigger changes\n        this.triggerChanges?.(allChanges);\n\n        // drop references of unused schemas\n        $root.garbageCollectDeletedRefs();\n\n        return allChanges;\n    }\n\n    getInstanceType(bytes: Buffer, it: Iterator, defaultType: typeof Schema): typeof Schema {\n        let type: typeof Schema;\n\n        if (bytes[it.offset] === TYPE_ID) {\n            it.offset++;\n            const type_id = decode.number(bytes, it);\n            type = this.context.get(type_id);\n        }\n\n        return type || defaultType;\n    }\n\n    createInstanceOfType (type: typeof Schema): Schema {\n        // let instance: Schema = new (type as any)();\n\n        // // assign root on $changes\n        // instance[$changes].root = this.root[$changes].root;\n\n        // return instance;\n        return new (type as any)();\n    }\n\n    removeChildRefs(ref: Collection, allChanges: DataChange[]) {\n        const needRemoveRef = typeof (ref[$childType]) !== \"string\";\n        const refId = this.root.refIds.get(ref as Ref);\n\n        ref.forEach((value: any, key: any) => {\n            allChanges.push({\n                ref: ref as Ref,\n                refId,\n                op: OPERATION.DELETE,\n                field: key,\n                value: undefined,\n                previousValue: value\n            });\n\n            if (needRemoveRef) {\n                this.root.removeRef(this.root.refIds.get(value));\n            }\n        });\n    }\n\n}\n\n", "import { type, PrimitiveType } from \"./annotations\";\nimport { TypeContext } from \"./types/TypeContext\";\nimport { Metadata } from \"./Metadata\";\nimport { ArraySchema } from \"./types/custom/ArraySchema\";\nimport { Iterator } from \"./encoding/decode\";\nimport { Encoder } from \"./encoder/Encoder\";\nimport { Decoder } from \"./decoder/Decoder\";\nimport { Schema } from \"./Schema\";\n\n/**\n * Reflection\n */\nexport class ReflectionField extends Schema {\n    @type(\"string\") name: string;\n    @type(\"string\") type: string;\n    @type(\"number\") referencedType: number;\n}\n\nexport class ReflectionType extends Schema {\n    @type(\"number\") id: number;\n    @type(\"number\") extendsId: number;\n    @type([ ReflectionField ]) fields = new ArraySchema<ReflectionField>();\n}\n\nexport class Reflection extends Schema {\n    @type([ReflectionType]) types: ArraySchema<ReflectionType> = new ArraySchema<ReflectionType>();\n    @type(\"number\") rootType: number;\n\n    /**\n     * Encodes the TypeContext of an Encoder into a buffer.\n     *\n     * @param encoder Encoder instance\n     * @param it\n     * @returns\n     */\n    static encode(encoder: Encoder, it: Iterator = { offset: 0 }) {\n        const context = encoder.context;\n\n        const reflection = new Reflection();\n        const reflectionEncoder = new Encoder(reflection);\n\n        // rootType is usually the first schema passed to the Encoder\n        // (unless it inherits from another schema)\n        const rootType = context.schemas.get(encoder.state.constructor);\n        if (rootType > 0) { reflection.rootType = rootType; }\n\n        const buildType = (currentType: ReflectionType, metadata: Metadata) => {\n            for (const fieldIndex in metadata) {\n                const index = Number(fieldIndex);\n                const fieldName = metadata[index].name;\n\n                // skip fields from parent classes\n                if (!Object.prototype.hasOwnProperty.call(metadata, fieldName)) {\n                    continue;\n                }\n\n                const field = new ReflectionField();\n                field.name = fieldName;\n\n                let fieldType: string;\n\n                const type = metadata[index].type;\n\n                if (typeof (type) === \"string\") {\n                    fieldType = type;\n\n                } else {\n                    let childTypeSchema: typeof Schema;\n\n                    //\n                    // TODO: refactor below.\n                    //\n                    if (Schema.is(type)) {\n                        fieldType = \"ref\";\n                        childTypeSchema = type as typeof Schema;\n\n                    } else {\n                        fieldType = Object.keys(type)[0];\n\n                        if (typeof(type[fieldType]) === \"string\") {\n                            fieldType += \":\" + type[fieldType]; // array:string\n\n                        } else {\n                            childTypeSchema = type[fieldType];\n                        }\n                    }\n\n                    field.referencedType = (childTypeSchema)\n                        ? context.getTypeId(childTypeSchema)\n                        : -1;\n                }\n\n                field.type = fieldType;\n                currentType.fields.push(field);\n            }\n\n            reflection.types.push(currentType);\n        }\n\n        for (let typeid in context.types) {\n            const klass = context.types[typeid];\n            const type = new ReflectionType();\n            type.id = Number(typeid);\n\n            // support inheritance\n            const inheritFrom = Object.getPrototypeOf(klass);\n            if (inheritFrom !== Schema) {\n                type.extendsId = context.schemas.get(inheritFrom);\n            }\n\n            buildType(type, klass[Symbol.metadata]);\n        }\n\n        const buf = reflectionEncoder.encodeAll(it);\n        return Buffer.from(buf, 0, it.offset);\n    }\n\n    /**\n     * Decodes the TypeContext from a buffer into a Decoder instance.\n     *\n     * @param bytes Reflection.encode() output\n     * @param it\n     * @returns Decoder instance\n     */\n    static decode<T extends Schema = Schema>(bytes: Buffer, it?: Iterator): Decoder<T> {\n        const reflection = new Reflection();\n\n        const reflectionDecoder = new Decoder(reflection);\n        reflectionDecoder.decode(bytes, it);\n\n        const typeContext = new TypeContext();\n\n        // 1st pass, initialize metadata + inheritance\n        reflection.types.forEach((reflectionType) => {\n            const parentClass: typeof Schema = typeContext.get(reflectionType.extendsId) ?? Schema;\n            const schema: typeof Schema = class _ extends parentClass {};\n\n            // register for inheritance support\n            TypeContext.register(schema);\n\n            // // for inheritance support\n            // Metadata.initialize(schema);\n\n            typeContext.add(schema, reflectionType.id);\n        }, {});\n\n        // define fields\n        const addFields = (metadata: Metadata, reflectionType: ReflectionType, parentFieldIndex: number) => {\n            reflectionType.fields.forEach((field, i) => {\n                const fieldIndex = parentFieldIndex + i;\n\n                if (field.referencedType !== undefined) {\n                    let fieldType = field.type;\n                    let refType: PrimitiveType = typeContext.get(field.referencedType);\n\n                    // map or array of primitive type (-1)\n                    if (!refType) {\n                        const typeInfo = field.type.split(\":\");\n                        fieldType = typeInfo[0];\n                        refType = typeInfo[1] as PrimitiveType; // string\n                    }\n\n                    if (fieldType === \"ref\") {\n                        Metadata.addField(metadata, fieldIndex, field.name, refType);\n\n                    } else {\n                        Metadata.addField(metadata, fieldIndex, field.name, { [fieldType]: refType });\n                    }\n\n                } else {\n                    Metadata.addField(metadata, fieldIndex, field.name, field.type as PrimitiveType);\n                }\n            });\n        };\n\n        // 2nd pass, set fields\n        reflection.types.forEach((reflectionType) => {\n            const schema = typeContext.get(reflectionType.id);\n\n            // for inheritance support\n            const metadata = Metadata.initialize(schema);\n\n            const inheritedTypes: ReflectionType[] = [];\n\n            let parentType: ReflectionType = reflectionType;\n            do {\n                inheritedTypes.push(parentType);\n                parentType = reflection.types.find((t) => t.id === parentType.extendsId);\n            } while (parentType);\n\n            let parentFieldIndex = 0;\n\n            inheritedTypes.reverse().forEach((reflectionType) => {\n                // add fields from all inherited classes\n                // TODO: refactor this to avoid adding fields from parent classes\n                addFields(metadata, reflectionType, parentFieldIndex);\n                parentFieldIndex += reflectionType.fields.length;\n            });\n        });\n\n        const state: T = new (typeContext.get(reflection.rootType || 0) as unknown as any)();\n\n        return new Decoder<T>(state, typeContext);\n    }\n}\n", "import { Metadata } from \"../../Metadata\";\nimport { Collection, NonFunctionNonPrimitivePropNames, NonFunctionPropNames } from \"../../types/HelperTypes\";\nimport { Ref } from \"../../encoder/ChangeTree\";\nimport { Decoder } from \"../Decoder\";\nimport { DataChange } from \"../DecodeOperation\";\nimport { OPERATION } from \"../../encoding/spec\";\nimport { Schema } from \"../../Schema\";\nimport type { DefinitionType } from \"../../annotations\";\nimport type { CollectionSchema } from \"../../types/custom/CollectionSchema\";\n\n//\n// Discussion: https://github.com/colyseus/schema/issues/155\n//\n// Main points:\n// - Decouple structures from their callbacks.\n// - Registering deep callbacks can be confusing.\n// - Avoid closures by allowing to pass a context. (https://github.com/colyseus/schema/issues/155#issuecomment-1804694081)\n//\n\nexport type SchemaCallbackProxy<RoomState> = (<T extends Schema>(instance: T) => CallbackProxy<T>);\nexport type GetCallbackProxy = SchemaCallbackProxy<any>; // workaround for compatibility for < colyseus.js0.16.6. Remove me on next major release.\n\nexport type CallbackProxy<T> = unknown extends T // is \"any\"?\n    ? SchemaCallback<T> & CollectionCallback<any, any>\n    : T extends Collection<infer K, infer V, infer _>\n        ? CollectionCallback<K, V>\n        : SchemaCallback<T>;\n\nexport type SchemaCallback<T> = {\n    /**\n     * Trigger callback when value of a property changes.\n     *\n     * @param prop name of the property\n     * @param callback callback to be triggered on property change\n     * @param immediate trigger immediatelly if property has been already set.\n     * @return callback to detach the listener\n     */\n    listen<K extends NonFunctionPropNames<T>>(\n        prop: K,\n        callback: (value: T[K], previousValue: T[K]) => void,\n        immediate?: boolean,\n    ): () => void;\n\n    /**\n     * Trigger callback whenever any property changed within this instance.\n     *\n     * @param prop name of the property\n     * @param callback callback to be triggered on property change\n     * @param immediate trigger immediatelly if property has been already set.\n     * @return callback to detach the listener\n     */\n    onChange(callback: () => void): () => void;\n\n    /**\n     * Bind properties to another object. Changes on the properties will be reflected on the target object.\n     *\n     * @param targetObject object to bind properties to\n     * @param properties list of properties to bind. If not provided, all properties will be bound.\n     */\n    bindTo(targetObject: any, properties?: Array<NonFunctionPropNames<T>>): void;\n} & {\n    [K in NonFunctionNonPrimitivePropNames<T>]: CallbackProxy<T[K]>;\n}\n\nexport type CollectionCallback<K, V> = {\n    /**\n     * Trigger callback when an item has been added to the collection.\n     *\n     * @param callback\n     * @param immediate\n     * @return callback to detach the onAdd listener\n     */\n    onAdd(callback: (item: V, index: K) => void, immediate?: boolean): () => void;\n\n    /**\n     * Trigger callback when an item has been removed to the collection.\n     *\n     * @param callback\n     * @return callback to detach the onRemove listener\n     */\n    onRemove(callback: (item: V, index: K) => void): () => void;\n\n    /**\n     * Trigger callback when the value on a key has changed.\n     *\n     * THIS METHOD IS NOT RECURSIVE!\n     * If you want to listen to changes on individual items, you need to attach callbacks to the them directly inside the `onAdd` callback.\n     *\n     * @param callback\n     */\n    onChange(callback: (item: V, index: K) => void): void;\n};\n\ntype OnInstanceAvailableCallback = (callback: (ref: Ref, existing: boolean) => void) => void;\n\ntype CallContext = {\n    instance?: any,\n    parentInstance?: any,\n    onInstanceAvailable?: OnInstanceAvailableCallback,\n}\n\n\nexport function getDecoderStateCallbacks<T extends Schema>(decoder: Decoder<T>): SchemaCallbackProxy<T> {\n    const $root = decoder.root;\n    const callbacks = $root.callbacks;\n\n    const onAddCalls: WeakMap<Function, boolean> = new WeakMap();\n    let currentOnAddCallback: Function | undefined;\n\n    decoder.triggerChanges = function (allChanges: DataChange[]) {\n        const uniqueRefIds = new Set<number>();\n\n        for (let i = 0, l = allChanges.length; i < l; i++) {\n            const change = allChanges[i];\n            const refId = change.refId;\n            const ref = change.ref;\n            const $callbacks = callbacks[refId];\n\n            if (!$callbacks) { continue; }\n\n            //\n            // trigger onRemove on child structure.\n            //\n            if (\n                (change.op & OPERATION.DELETE) === OPERATION.DELETE &&\n                change.previousValue instanceof Schema\n            ) {\n                const deleteCallbacks = callbacks[$root.refIds.get(change.previousValue)]?.[OPERATION.DELETE];\n                for (let i = deleteCallbacks?.length - 1; i >= 0; i--) {\n                    deleteCallbacks[i]();\n                }\n            }\n\n            if (ref instanceof Schema) {\n                //\n                // Handle schema instance\n                //\n\n                if (!uniqueRefIds.has(refId)) {\n                    // trigger onChange\n                    const replaceCallbacks = $callbacks?.[OPERATION.REPLACE];\n                    for (let i = replaceCallbacks?.length - 1; i >= 0; i--) {\n                        replaceCallbacks[i]();\n                        // try {\n                        // } catch (e) {\n                        //     console.error(e);\n                        // }\n                    }\n                }\n\n                if ($callbacks.hasOwnProperty(change.field)) {\n                    const fieldCallbacks = $callbacks[change.field];\n                    for (let i = fieldCallbacks?.length - 1; i >= 0; i--) {\n                        fieldCallbacks[i](change.value, change.previousValue);\n                        // try {\n                        // } catch (e) {\n                        //     console.error(e);\n                        // }\n                    }\n                }\n\n\n            } else {\n                //\n                // Handle collection of items\n                //\n\n                if ((change.op & OPERATION.DELETE) === OPERATION.DELETE) {\n                    //\n                    // FIXME: `previousValue` should always be available.\n                    //\n                    if (change.previousValue !== undefined) {\n                        // triger onRemove\n                        const deleteCallbacks = $callbacks[OPERATION.DELETE];\n                        for (let i = deleteCallbacks?.length - 1; i >= 0; i--) {\n                            deleteCallbacks[i](change.previousValue, change.dynamicIndex ?? change.field);\n                        }\n                    }\n\n                    // Handle DELETE_AND_ADD operations\n                    if ((change.op & OPERATION.ADD) === OPERATION.ADD) {\n                        const addCallbacks = $callbacks[OPERATION.ADD];\n                        for (let i = addCallbacks?.length - 1; i >= 0; i--) {\n                            addCallbacks[i](change.value, change.dynamicIndex ?? change.field);\n                        }\n                    }\n\n                } else if ((change.op & OPERATION.ADD) === OPERATION.ADD && change.previousValue === undefined) {\n                    // triger onAdd\n                    const addCallbacks = $callbacks[OPERATION.ADD];\n                    for (let i = addCallbacks?.length - 1; i >= 0; i--) {\n                        addCallbacks[i](change.value, change.dynamicIndex ?? change.field);\n                    }\n                }\n\n                // trigger onChange\n                if (\n                    change.value !== change.previousValue &&\n                    // FIXME: see \"should not encode item if added and removed at the same patch\" test case.\n                    // some \"ADD\" + \"DELETE\" operations on same patch are being encoded as \"DELETE\"\n                    (change.value !== undefined || change.previousValue !== undefined)\n                ) {\n                    const replaceCallbacks = $callbacks[OPERATION.REPLACE];\n                    for (let i = replaceCallbacks?.length - 1; i >= 0; i--) {\n                        replaceCallbacks[i](change.value, change.dynamicIndex ?? change.field);\n                    }\n                }\n            }\n\n            uniqueRefIds.add(refId);\n        }\n    };\n\n    function getProxy(\n        metadataOrType: Metadata | DefinitionType,\n        context: CallContext\n    ) {\n        let metadata: Metadata = context.instance?.constructor[Symbol.metadata] || metadataOrType;\n        let isCollection = (\n            (context.instance && typeof (context.instance['forEach']) === \"function\") ||\n            (metadataOrType && typeof (metadataOrType[Symbol.metadata]) === \"undefined\")\n        );\n\n        if (metadata && !isCollection) {\n\n            const onAddListen = function (\n                ref: Ref,\n                prop: string,\n                callback: (value: any, previousValue: any) => void, immediate: boolean\n            ) {\n                // immediate trigger\n                if (\n                    immediate &&\n                    context.instance[prop] !== undefined &&\n                    !onAddCalls.has(currentOnAddCallback) // Workaround for https://github.com/colyseus/schema/issues/147\n                ) {\n                    callback(context.instance[prop], undefined);\n                }\n                return $root.addCallback($root.refIds.get(ref), prop, callback);\n            }\n\n            /**\n             * Schema instances\n             */\n            return new Proxy({\n                listen: function listen(prop: string, callback: (value: any, previousValue: any) => void, immediate: boolean = true) {\n                    if (context.instance) {\n                        return onAddListen(context.instance, prop, callback, immediate);\n\n                    } else {\n                        // collection instance not received yet\n                        let detachCallback = () => {};\n\n                        context.onInstanceAvailable((ref: Ref, existing: boolean) => {\n                            detachCallback = onAddListen(ref, prop, callback, immediate && existing && !onAddCalls.has(currentOnAddCallback))\n                        });\n\n                        return () => detachCallback();\n                    }\n                },\n\n                onChange: function onChange(callback: () => void) {\n                    return $root.addCallback(\n                        $root.refIds.get(context.instance),\n                        OPERATION.REPLACE,\n                        callback\n                    );\n                },\n\n                //\n                // TODO: refactor `bindTo()` implementation.\n                // There is room for improvement.\n                //\n                bindTo: function bindTo(targetObject: any, properties?: string[]) {\n                    if (!properties) {\n                        properties = Object.keys(metadata).map((index) => metadata[index as any as number].name);\n                    }\n                    return $root.addCallback(\n                        $root.refIds.get(context.instance),\n                        OPERATION.REPLACE,\n                        () => {\n                            properties.forEach((prop) =>\n                                targetObject[prop] = context.instance[prop])\n                        }\n                    );\n                }\n            }, {\n                get(target, prop: string) {\n                    const metadataField = metadata[metadata[prop]];\n                    if (metadataField) {\n                        const instance = context.instance?.[prop];\n                        const onInstanceAvailable: OnInstanceAvailableCallback = (\n                            (callback: (ref: Ref, existing: boolean) => void) => {\n                                const unbind = $(context.instance).listen(prop, (value, _) => {\n                                    callback(value, false);\n\n                                    // FIXME: by \"unbinding\" the callback here,\n                                    // it will not support when the server\n                                    // re-instantiates the instance.\n                                    //\n                                    unbind?.();\n                                }, false);\n\n                                // has existing value\n                                if ($root.refIds.get(instance) !== undefined) {\n                                    callback(instance, true);\n                                }\n                            }\n                        );\n\n                        return getProxy(metadataField.type, {\n                            // make sure refId is available, otherwise need to wait for the instance to be available.\n                            instance: ($root.refIds.get(instance) && instance),\n                            parentInstance: context.instance,\n                            onInstanceAvailable,\n                        });\n\n                    } else {\n                        // accessing the function\n                        return target[prop];\n                    }\n                },\n                has(target, prop: string) { return metadata[prop] !== undefined; },\n                set(_, _1, _2) { throw new Error(\"not allowed\"); },\n                deleteProperty(_, _1) { throw new Error(\"not allowed\"); },\n            });\n\n        } else {\n            /**\n             * Collection instances\n             */\n\n            const onAdd = function (ref: Ref, callback: (value: any, key: any) => void, immediate: boolean) {\n                // Trigger callback on existing items\n                if (immediate) {\n                    (ref as CollectionSchema).forEach((v, k) => callback(v, k));\n                }\n\n                return $root.addCallback($root.refIds.get(ref), OPERATION.ADD, (value, key) => {\n                    onAddCalls.set(callback, true);\n                    currentOnAddCallback = callback;\n                    callback(value, key);\n                    onAddCalls.delete(callback)\n                    currentOnAddCallback = undefined;\n                });\n            };\n\n            const onRemove = function (ref: Ref, callback: (value: any, key: any) => void) {\n                return $root.addCallback($root.refIds.get(ref), OPERATION.DELETE, callback);\n            };\n\n            const onChange = function (ref: Ref, callback: (value: any, key: any) => void) {\n                return $root.addCallback($root.refIds.get(ref), OPERATION.REPLACE, callback);\n            };\n\n            return new Proxy({\n                onAdd: function(callback: (value, key) => void, immediate: boolean = true) {\n                    //\n                    // https://github.com/colyseus/schema/issues/147\n                    // If parent instance has \"onAdd\" registered, avoid triggering immediate callback.\n                    //\n\n                    if (context.instance) {\n                        return onAdd(context.instance, callback, immediate && !onAddCalls.has(currentOnAddCallback));\n\n                    } else if (context.onInstanceAvailable) {\n                        // collection instance not received yet\n                        let detachCallback = () => {};\n\n                        context.onInstanceAvailable((ref: Ref, existing: boolean) => {\n                            detachCallback = onAdd(ref, callback, immediate && existing && !onAddCalls.has(currentOnAddCallback));\n                        });\n\n                        return () => detachCallback();\n                    }\n                },\n                onRemove: function(callback: (value, key) => void) {\n                    if (context.instance) {\n                        return onRemove(context.instance, callback);\n\n                    } else if (context.onInstanceAvailable) {\n                        // collection instance not received yet\n                        let detachCallback = () => {};\n\n                        context.onInstanceAvailable((ref: Ref) => {\n                            detachCallback = onRemove(ref, callback)\n                        });\n\n                        return () => detachCallback();\n                    }\n                },\n                onChange: function(callback: (value, key) => void) {\n                    if (context.instance) {\n                        return onChange(context.instance, callback);\n\n                    } else if (context.onInstanceAvailable) {\n                        // collection instance not received yet\n                        let detachCallback = () => {};\n\n                        context.onInstanceAvailable((ref: Ref) => {\n                            detachCallback = onChange(ref, callback)\n                        });\n\n                        return () => detachCallback();\n                    }\n                },\n            }, {\n                get(target, prop: string) {\n                    if (!target[prop]) {\n                        throw new Error(`Can't access '${prop}' through callback proxy. access the instance directly.`);\n                    }\n                    return target[prop];\n                },\n                has(target, prop) { return target[prop] !== undefined; },\n                set(_, _1, _2) { throw new Error(\"not allowed\"); },\n                deleteProperty(_, _1) { throw new Error(\"not allowed\"); },\n            });\n        }\n    }\n\n    function $<T>(instance: T): CallbackProxy<T> {\n        return getProxy(undefined, { instance }) as unknown as CallbackProxy<T>;\n    }\n\n    return $;\n}", "import { DataChange } from \"../DecodeOperation\";\nimport { Decoder } from \"../Decoder\";\n\nexport function getRawChangesCallback(\n    decoder: Decoder,\n    callback: (changes: DataChange[]) => void\n) {\n    decoder.triggerChanges = callback;\n}", "import { ChangeSet, ChangeTree, IndexedOperations, Ref } from \"./ChangeTree\";\nimport { $changes, $fieldIndexesByViewTag, $viewFieldIndexes } from \"../types/symbols\";\nimport { DEFAULT_VIEW_TAG } from \"../annotations\";\nimport { OPERATION } from \"../encoding/spec\";\nimport { Metadata } from \"../Metadata\";\n\nexport function createView() {\n    return new StateView();\n}\n\nexport class StateView {\n    /**\n     * List of ChangeTree's that are visible to this view\n     */\n    items: WeakSet<ChangeTree> = new WeakSet<ChangeTree>();\n\n    /**\n     * List of ChangeTree's that are invisible to this view\n     */\n    invisible: WeakSet<ChangeTree> = new WeakSet<ChangeTree>();\n\n    tags?: WeakMap<ChangeTree, Set<number>>; // TODO: use bit manipulation instead of Set<number> ()\n\n    /**\n     * Manual \"ADD\" operations for changes per ChangeTree, specific to this view.\n     * (This is used to force encoding a property, even if it was not changed)\n     */\n    changes = new Map<number, IndexedOperations>();\n\n    // TODO: allow to set multiple tags at once\n    add(obj: Ref, tag: number = DEFAULT_VIEW_TAG, checkIncludeParent: boolean = true) {\n        if (!obj[$changes]) {\n            console.warn(\"StateView#add(), invalid object:\", obj);\n            return this;\n        }\n\n        // FIXME: ArraySchema/MapSchema do not have metadata\n        const metadata: Metadata = obj.constructor[Symbol.metadata];\n        const changeTree: ChangeTree = obj[$changes];\n        this.items.add(changeTree);\n\n        // add parent ChangeTree's\n        // - if it was invisible to this view\n        // - if it were previously filtered out\n        if (checkIncludeParent && changeTree.parent) {\n            this.addParentOf(changeTree, tag);\n        }\n\n        //\n        // TODO: when adding an item of a MapSchema, the changes may not\n        // be set (only the parent's changes are set)\n        //\n        let changes = this.changes.get(changeTree.refId);\n        if (changes === undefined) {\n            changes = {};\n            this.changes.set(changeTree.refId, changes);\n        }\n\n        // set tag\n        if (tag !== DEFAULT_VIEW_TAG) {\n            if (!this.tags) {\n                this.tags = new WeakMap<ChangeTree, Set<number>>();\n            }\n            let tags: Set<number>;\n            if (!this.tags.has(changeTree)) {\n                tags = new Set<number>();\n                this.tags.set(changeTree, tags);\n            } else {\n                tags = this.tags.get(changeTree);\n            }\n            tags.add(tag);\n\n            // Ref: add tagged properties\n            metadata?.[$fieldIndexesByViewTag]?.[tag]?.forEach((index) => {\n                if (changeTree.getChange(index) !== OPERATION.DELETE) {\n                    changes[index] = OPERATION.ADD;\n                }\n            });\n\n        } else {\n            const isInvisible = this.invisible.has(changeTree);\n            const changeSet = (changeTree.filteredChanges !== undefined)\n                ? changeTree.allFilteredChanges\n                : changeTree.allChanges;\n\n            for (let i = 0, len = changeSet.operations.length; i < len; i++) {\n                const index = changeSet.operations[i];\n                if (index === undefined) { continue; } // skip \"undefined\" indexes\n\n                const op = changeTree.indexedOperations[index] ?? OPERATION.ADD;\n                const tagAtIndex = metadata?.[index].tag;\n                if (\n                    (\n                        isInvisible || // if \"invisible\", include all\n                        tagAtIndex === undefined || // \"all change\" with no tag\n                        tagAtIndex === tag // tagged property\n                    ) &&\n                    op !== OPERATION.DELETE\n                ) {\n                    changes[index] = op;\n                }\n            }\n        }\n\n        // Add children of this ChangeTree to this view\n        changeTree.forEachChild((change, index) => {\n            // Do not ADD children that don't have the same tag\n            if (\n                metadata &&\n                metadata[index].tag !== undefined &&\n                metadata[index].tag !== tag\n            ) {\n                return;\n            }\n            this.add(change.ref, tag, false);\n        });\n\n        return this;\n    }\n\n    protected addParentOf(childChangeTree: ChangeTree, tag: number) {\n        const changeTree = childChangeTree.parent[$changes];\n        const parentIndex = childChangeTree.parentIndex;\n\n        if (!this.items.has(changeTree)) {\n            // view must have all \"changeTree\" parent tree\n            this.items.add(changeTree);\n\n            // add parent's parent\n            const parentChangeTree: ChangeTree = changeTree.parent?.[$changes];\n            if (parentChangeTree && (parentChangeTree.filteredChanges !== undefined)) {\n                this.addParentOf(changeTree, tag);\n            }\n\n            // parent is already available, no need to add it!\n            if (!this.invisible.has(changeTree)) { return; }\n        }\n\n        // add parent's tag properties\n        if (changeTree.getChange(parentIndex) !== OPERATION.DELETE) {\n            let changes = this.changes.get(changeTree.refId);\n            if (changes === undefined) {\n                changes = {};\n                this.changes.set(changeTree.refId, changes);\n            }\n\n            if (!this.tags) {\n                this.tags = new WeakMap<ChangeTree, Set<number>>();\n            }\n\n            let tags: Set<number>;\n            if (!this.tags.has(changeTree)) {\n                tags = new Set<number>();\n                this.tags.set(changeTree, tags);\n            } else {\n                tags = this.tags.get(changeTree);\n            }\n            tags.add(tag);\n\n            changes[parentIndex] = OPERATION.ADD;\n        }\n    }\n\n    remove(obj: Ref, tag: number = DEFAULT_VIEW_TAG) {\n        const changeTree = obj[$changes];\n        if (!changeTree) {\n            console.warn(\"StateView#remove(), invalid object:\", obj);\n            return this;\n        }\n\n        this.items.delete(changeTree);\n\n        const ref = changeTree.ref;\n        const metadata: Metadata = ref.constructor[Symbol.metadata];\n\n        let changes = this.changes.get(changeTree.refId);\n        if (changes === undefined) {\n            changes = {};\n            this.changes.set(changeTree.refId, changes);\n        }\n\n        if (tag === DEFAULT_VIEW_TAG) {\n            // parent is collection (Map/Array)\n            const parent = changeTree.parent;\n            if (!Metadata.isValidInstance(parent)) {\n                const parentChangeTree = parent[$changes];\n                let changes = this.changes.get(parentChangeTree.refId);\n                if (changes === undefined) {\n                    changes = {};\n                    this.changes.set(parentChangeTree.refId, changes);\n                }\n                // DELETE / DELETE BY REF ID\n                changes[changeTree.parentIndex] = OPERATION.DELETE;\n\n            } else {\n                // delete all \"tagged\" properties.\n                metadata[$viewFieldIndexes].forEach((index) =>\n                    changes[index] = OPERATION.DELETE);\n            }\n\n\n        } else {\n            // delete only tagged properties\n            metadata[$fieldIndexesByViewTag][tag].forEach((index) =>\n                changes[index] = OPERATION.DELETE);\n        }\n\n        // remove tag\n        if (this.tags && this.tags.has(changeTree)) {\n            const tags = this.tags.get(changeTree);\n            if (tag === undefined) {\n                // delete all tags\n                this.tags.delete(changeTree);\n            } else {\n                // delete specific tag\n                tags.delete(tag);\n\n                // if tag set is empty, delete it entirely\n                if (tags.size === 0) {\n                    this.tags.delete(changeTree);\n                }\n            }\n        }\n\n        return this;\n    }\n\n    has(obj: Ref) {\n        return this.items.has(obj[$changes]);\n    }\n\n    hasTag(ob: Ref, tag: number = DEFAULT_VIEW_TAG) {\n        const tags = this.tags?.get(ob[$changes]);\n        return tags?.has(tag) ?? false;\n    }\n}", "export { Schema } from \"./Schema\";\nexport type { DataChange } from \"./decoder/DecodeOperation\";\nexport type { ToJSON } from \"./types/HelperTypes\";\n\nimport { MapSchema } from \"./types/custom/MapSchema\"\nexport { MapSchema };\n\nimport { ArraySchema } from \"./types/custom/ArraySchema\";\nexport { ArraySchema };\n\nimport { CollectionSchema } from \"./types/custom/CollectionSchema\";\nexport { CollectionSchema };\n\nimport { SetSchema } from \"./types/custom/SetSchema\";\nexport { SetSchema };\n\nimport { registerType, defineCustomTypes } from \"./types/registry\";\nexport { registerType, defineCustomTypes };\n\nregisterType(\"map\", { constructor: MapSchema });\nregisterType(\"array\", { constructor: ArraySchema });\nregisterType(\"set\", { constructor: SetSchema });\nregisterType(\"collection\", { constructor: CollectionSchema, });\n\n// Utils\nexport { dumpChanges } from \"./utils\";\n\n// Encoder / Decoder\nexport { $track, $encoder, $decoder, $filter, $getByIndex, $deleteByIndex, $changes, $childType } from \"./types/symbols\";\nexport { encode } from \"./encoding/encode\";\nexport { decode, type Iterator } from \"./encoding/decode\";\n\n// Reflection\nexport {\n    Reflection,\n    ReflectionType,\n    ReflectionField,\n} from \"./Reflection\";\n\n// Annotations, Metadata and TypeContext\nexport { Metadata } from \"./Metadata\";\nexport { type, deprecated, defineTypes, view, schema, entity, type SchemaWithExtends, } from \"./annotations\";\nexport { TypeContext } from \"./types/TypeContext\";\n\n// Annotation types\nexport type { DefinitionType, PrimitiveType, Definition, } from \"./annotations\";\n\nexport { getDecoderStateCallbacks, CallbackProxy, SchemaCallback, CollectionCallback, SchemaCallbackProxy } from \"./decoder/strategy/StateCallbacks\";\nexport { getRawChangesCallback } from \"./decoder/strategy/RawChanges\";\n\nexport { Encoder } from \"./encoder/Encoder\";\nexport { encodeSchemaOperation, encodeArray, encodeKeyValueOperation } from \"./encoder/EncodeOperation\";\nexport { ChangeTree, Ref } from \"./encoder/ChangeTree\";\nexport { StateView } from \"./encoder/StateView\";\n\nexport { Decoder } from \"./decoder/Decoder\";\nexport { decodeSchemaOperation, decodeKeyValueOperation } from \"./decoder/DecodeOperation\";\n\nexport { OPERATION } from \"./encoding/spec\";", "// packages/core/src/Protocol.ts\nimport { Packr } from \"@colyseus/msgpackr\";\nimport { encode } from \"@colyseus/schema\";\nvar Protocol = /* @__PURE__ */ ((Protocol2) => {\n  Protocol2[Protocol2[\"JOIN_ROOM\"] = 10] = \"JOIN_ROOM\";\n  Protocol2[Protocol2[\"ERROR\"] = 11] = \"ERROR\";\n  Protocol2[Protocol2[\"LEAVE_ROOM\"] = 12] = \"LEAVE_ROOM\";\n  Protocol2[Protocol2[\"ROOM_DATA\"] = 13] = \"ROOM_DATA\";\n  Protocol2[Protocol2[\"ROOM_STATE\"] = 14] = \"ROOM_STATE\";\n  Protocol2[Protocol2[\"ROOM_STATE_PATCH\"] = 15] = \"ROOM_STATE_PATCH\";\n  Protocol2[Protocol2[\"ROOM_DATA_BYTES\"] = 17] = \"ROOM_DATA_BYTES\";\n  Protocol2[Protocol2[\"WS_CLOSE_NORMAL\"] = 1e3] = \"WS_CLOSE_NORMAL\";\n  Protocol2[Protocol2[\"WS_CLOSE_GOING_AWAY\"] = 1001] = \"WS_CLOSE_GOING_AWAY\";\n  Protocol2[Protocol2[\"WS_CLOSE_CONSENTED\"] = 4e3] = \"WS_CLOSE_CONSENTED\";\n  Protocol2[Protocol2[\"WS_CLOSE_WITH_ERROR\"] = 4002] = \"WS_CLOSE_WITH_ERROR\";\n  Protocol2[Protocol2[\"WS_CLOSE_DEVMODE_RESTART\"] = 4010] = \"WS_CLOSE_DEVMODE_RESTART\";\n  Protocol2[Protocol2[\"WS_SERVER_DISCONNECT\"] = 4201] = \"WS_SERVER_DISCONNECT\";\n  Protocol2[Protocol2[\"WS_TOO_MANY_CLIENTS\"] = 4202] = \"WS_TOO_MANY_CLIENTS\";\n  return Protocol2;\n})(Protocol || {});\nvar ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {\n  ErrorCode2[ErrorCode2[\"MATCHMAKE_NO_HANDLER\"] = 4210] = \"MATCHMAKE_NO_HANDLER\";\n  ErrorCode2[ErrorCode2[\"MATCHMAKE_INVALID_CRITERIA\"] = 4211] = \"MATCHMAKE_INVALID_CRITERIA\";\n  ErrorCode2[ErrorCode2[\"MATCHMAKE_INVALID_ROOM_ID\"] = 4212] = \"MATCHMAKE_INVALID_ROOM_ID\";\n  ErrorCode2[ErrorCode2[\"MATCHMAKE_UNHANDLED\"] = 4213] = \"MATCHMAKE_UNHANDLED\";\n  ErrorCode2[ErrorCode2[\"MATCHMAKE_EXPIRED\"] = 4214] = \"MATCHMAKE_EXPIRED\";\n  ErrorCode2[ErrorCode2[\"AUTH_FAILED\"] = 4215] = \"AUTH_FAILED\";\n  ErrorCode2[ErrorCode2[\"APPLICATION_ERROR\"] = 4216] = \"APPLICATION_ERROR\";\n  ErrorCode2[ErrorCode2[\"INVALID_PAYLOAD\"] = 4217] = \"INVALID_PAYLOAD\";\n  return ErrorCode2;\n})(ErrorCode || {});\nvar IpcProtocol = /* @__PURE__ */ ((IpcProtocol2) => {\n  IpcProtocol2[IpcProtocol2[\"SUCCESS\"] = 0] = \"SUCCESS\";\n  IpcProtocol2[IpcProtocol2[\"ERROR\"] = 1] = \"ERROR\";\n  IpcProtocol2[IpcProtocol2[\"TIMEOUT\"] = 2] = \"TIMEOUT\";\n  return IpcProtocol2;\n})(IpcProtocol || {});\nvar packr = new Packr({\n  useRecords: false\n});\npackr.encode(void 0);\nvar getMessageBytes = {\n  [10 /* JOIN_ROOM */]: (reconnectionToken, serializerId, handshake) => {\n    const it = { offset: 1 };\n    packr.buffer[0] = 10 /* JOIN_ROOM */;\n    packr.buffer[it.offset++] = Buffer.byteLength(reconnectionToken, \"utf8\");\n    encode.utf8Write(packr.buffer, reconnectionToken, it);\n    packr.buffer[it.offset++] = Buffer.byteLength(serializerId, \"utf8\");\n    encode.utf8Write(packr.buffer, serializerId, it);\n    let handshakeLength = handshake?.byteLength || 0;\n    if (handshakeLength > packr.buffer.byteLength - it.offset) {\n      packr.useBuffer(Buffer.alloc(it.offset + handshakeLength, packr.buffer));\n    }\n    if (handshakeLength > 0) {\n      handshake.copy(packr.buffer, it.offset, 0, handshakeLength);\n    }\n    return packr.buffer.subarray(0, it.offset + handshakeLength);\n  },\n  [11 /* ERROR */]: (code, message = \"\") => {\n    const it = { offset: 1 };\n    packr.buffer[0] = 11 /* ERROR */;\n    encode.number(packr.buffer, code, it);\n    encode.string(packr.buffer, message, it);\n    return packr.buffer.subarray(0, it.offset);\n  },\n  [14 /* ROOM_STATE */]: (bytes) => {\n    return [14 /* ROOM_STATE */, ...bytes];\n  },\n  raw: (code, type, message, rawMessage) => {\n    const it = { offset: 1 };\n    packr.buffer[0] = code;\n    if (typeof type === \"string\") {\n      encode.string(packr.buffer, type, it);\n    } else {\n      encode.number(packr.buffer, type, it);\n    }\n    if (message !== void 0) {\n      packr.position = 0;\n      if (process.env.NODE_ENV !== \"production\") {\n        packr.useBuffer(packr.buffer);\n      }\n      const endOfBufferOffset = packr.pack(message, 2048 + it.offset).byteLength;\n      return packr.buffer.subarray(0, endOfBufferOffset);\n    } else if (rawMessage !== void 0) {\n      if (rawMessage.length + it.offset > packr.buffer.byteLength) {\n        packr.useBuffer(Buffer.alloc(it.offset + rawMessage.length, packr.buffer));\n      }\n      packr.buffer.set(rawMessage, it.offset);\n      return packr.buffer.subarray(0, it.offset + rawMessage.byteLength);\n    } else {\n      return packr.buffer.subarray(0, it.offset);\n    }\n  }\n};\nexport {\n  ErrorCode,\n  IpcProtocol,\n  Protocol,\n  getMessageBytes\n};\n", "// packages/core/src/errors/ServerError.ts\nimport { ErrorCode } from \"../Protocol.mjs\";\nvar ServerError = class _ServerError extends Error {\n  constructor(code = ErrorCode.MATCHMAKE_UNHANDLED, message) {\n    super(message);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, _ServerError);\n    }\n    this.name = \"ServerError\";\n    this.code = code;\n  }\n};\nexport {\n  ServerError\n};\n", "// packages/core/src/MatchMaker.ts\nimport { EventEmitter } from \"events\";\nimport { ErrorCode, Protocol } from \"./Protocol.mjs\";\nimport { requestFromIPC, subscribeIPC } from \"./IPC.mjs\";\nimport { Deferred, generateId, merge, retry, MAX_CONCURRENT_CREATE_ROOM_WAIT_TIME, REMOTE_ROOM_SHORT_TIMEOUT } from \"./utils/Utils.mjs\";\nimport { isDevMode, cacheRoomHistory, getPreviousProcessId, getRoomRestoreListKey, reloadFromCache } from \"./utils/DevMode.mjs\";\nimport { RegisteredHandler } from \"./matchmaker/RegisteredHandler.mjs\";\nimport { Room, RoomInternalState } from \"./Room.mjs\";\nimport { LocalPresence } from \"./presence/LocalPresence.mjs\";\nimport { debugAndPrintError, debugMatchMaking } from \"./Debug.mjs\";\nimport { SeatReservationError } from \"./errors/SeatReservationError.mjs\";\nimport { ServerError } from \"./errors/ServerError.mjs\";\nimport { LocalDriver } from \"./matchmaker/driver/local/LocalDriver.mjs\";\nimport controller from \"./matchmaker/controller.mjs\";\nimport * as stats from \"./Stats.mjs\";\nimport { logger } from \"./Logger.mjs\";\nimport { getHostname } from \"./discovery/index.mjs\";\nimport { getLockId } from \"./matchmaker/driver/api.mjs\";\nvar handlers = {};\nvar rooms = {};\nvar events = new EventEmitter();\nvar publicAddress;\nvar processId;\nvar presence;\nvar driver;\nvar selectProcessIdToCreateRoom;\nvar enableHealthChecks = true;\nfunction setHealthChecksEnabled(value) {\n  enableHealthChecks = value;\n}\nvar onReady = new Deferred();\nvar MatchMakerState = /* @__PURE__ */ ((MatchMakerState2) => {\n  MatchMakerState2[MatchMakerState2[\"INITIALIZING\"] = 0] = \"INITIALIZING\";\n  MatchMakerState2[MatchMakerState2[\"READY\"] = 1] = \"READY\";\n  MatchMakerState2[MatchMakerState2[\"SHUTTING_DOWN\"] = 2] = \"SHUTTING_DOWN\";\n  return MatchMakerState2;\n})(MatchMakerState || {});\nvar state;\nasync function setup(_presence, _driver, _publicAddress, _selectProcessIdToCreateRoom) {\n  if (onReady === void 0) {\n    onReady = new Deferred();\n  }\n  state = 0 /* INITIALIZING */;\n  presence = _presence || new LocalPresence();\n  driver = _driver || new LocalDriver();\n  publicAddress = _publicAddress;\n  stats.reset(false);\n  if (isDevMode) {\n    processId = await getPreviousProcessId(await getHostname());\n  }\n  if (!processId) {\n    processId = generateId();\n  }\n  selectProcessIdToCreateRoom = _selectProcessIdToCreateRoom || async function() {\n    return (await stats.fetchAll()).sort((p1, p2) => p1.roomCount > p2.roomCount ? 1 : -1)[0]?.processId || processId;\n  };\n  onReady.resolve();\n}\nasync function accept() {\n  await onReady;\n  await subscribeIPC(presence, processId, getProcessChannel(), (method, args) => {\n    if (method === \"healthcheck\") {\n      return true;\n    } else {\n      return handleCreateRoom.apply(void 0, args);\n    }\n  });\n  if (enableHealthChecks) {\n    await healthCheckAllProcesses();\n    stats.setAutoPersistInterval();\n  }\n  state = 1 /* READY */;\n  await stats.persist();\n  if (isDevMode) {\n    await reloadFromCache();\n  }\n}\nasync function joinOrCreate(roomName, clientOptions = {}, authContext) {\n  return await retry(async () => {\n    const authData = await callOnAuth(roomName, clientOptions, authContext);\n    let room = await findOneRoomAvailable(roomName, clientOptions);\n    if (!room) {\n      const handler = getHandler(roomName);\n      const filterOptions = handler.getFilterOptions(clientOptions);\n      const concurrencyKey = getLockId(filterOptions);\n      await concurrentJoinOrCreateRoomLock(handler, concurrencyKey, async (roomId) => {\n        if (roomId) {\n          room = await driver.findOne({ roomId });\n        }\n        if (!room) {\n          room = await findOneRoomAvailable(roomName, clientOptions);\n        }\n        if (!room) {\n          room = await createRoom(roomName, clientOptions);\n          presence.lpush(`l:${handler.name}:${concurrencyKey}`, room.roomId);\n          presence.expire(`l:${handler.name}:${concurrencyKey}`, MAX_CONCURRENT_CREATE_ROOM_WAIT_TIME * 2);\n        }\n        return room;\n      });\n    }\n    return await reserveSeatFor(room, clientOptions, authData);\n  }, 5, [SeatReservationError]);\n}\nasync function create(roomName, clientOptions = {}, authContext) {\n  const authData = await callOnAuth(roomName, clientOptions, authContext);\n  const room = await createRoom(roomName, clientOptions);\n  return reserveSeatFor(room, clientOptions, authData);\n}\nasync function join(roomName, clientOptions = {}, authContext) {\n  return await retry(async () => {\n    const authData = await callOnAuth(roomName, clientOptions, authContext);\n    const room = await findOneRoomAvailable(roomName, clientOptions);\n    if (!room) {\n      throw new ServerError(ErrorCode.MATCHMAKE_INVALID_CRITERIA, `no rooms found with provided criteria`);\n    }\n    return reserveSeatFor(room, clientOptions, authData);\n  });\n}\nasync function reconnect(roomId, clientOptions = {}) {\n  const room = await driver.findOne({ roomId });\n  if (!room) {\n    if (process.env.NODE_ENV !== \"production\") {\n      logger.info(`\\u274C room \"${roomId}\" has been disposed. Did you missed .allowReconnection()?\n\\u{1F449} https://docs.colyseus.io/server/room/#allowreconnection-client-seconds`);\n    }\n    throw new ServerError(ErrorCode.MATCHMAKE_INVALID_ROOM_ID, `room \"${roomId}\" has been disposed.`);\n  }\n  const reconnectionToken = clientOptions.reconnectionToken;\n  if (!reconnectionToken) {\n    throw new ServerError(ErrorCode.MATCHMAKE_UNHANDLED, `'reconnectionToken' must be provided for reconnection.`);\n  }\n  const sessionId = await remoteRoomCall(room.roomId, \"checkReconnectionToken\", [reconnectionToken]);\n  if (sessionId) {\n    return { room, sessionId };\n  } else {\n    if (process.env.NODE_ENV !== \"production\") {\n      logger.info(`\\u274C reconnection token invalid or expired. Did you missed .allowReconnection()?\n\\u{1F449} https://docs.colyseus.io/server/room/#allowreconnection-client-seconds`);\n    }\n    throw new ServerError(ErrorCode.MATCHMAKE_EXPIRED, `reconnection token invalid or expired.`);\n  }\n}\nasync function joinById(roomId, clientOptions = {}, authContext) {\n  const room = await driver.findOne({ roomId });\n  if (!room) {\n    throw new ServerError(ErrorCode.MATCHMAKE_INVALID_ROOM_ID, `room \"${roomId}\" not found`);\n  } else if (room.locked) {\n    throw new ServerError(ErrorCode.MATCHMAKE_INVALID_ROOM_ID, `room \"${roomId}\" is locked`);\n  }\n  const authData = await callOnAuth(room.name, clientOptions, authContext);\n  return reserveSeatFor(room, clientOptions, authData);\n}\nasync function query(conditions = {}, sortOptions) {\n  return await driver.query(conditions, sortOptions);\n}\nasync function findOneRoomAvailable(roomName, filterOptions, additionalSortOptions) {\n  const handler = getHandler(roomName);\n  const sortOptions = Object.assign({}, handler.sortOptions ?? {});\n  if (additionalSortOptions) {\n    Object.assign(sortOptions, additionalSortOptions);\n  }\n  return await driver.findOne({\n    locked: false,\n    name: roomName,\n    private: false,\n    ...handler.getFilterOptions(filterOptions)\n  }, sortOptions);\n}\nasync function remoteRoomCall(roomId, method, args, rejectionTimeout = REMOTE_ROOM_SHORT_TIMEOUT) {\n  const room = rooms[roomId];\n  if (!room) {\n    try {\n      return await requestFromIPC(presence, getRoomChannel(roomId), method, args, rejectionTimeout);\n    } catch (e) {\n      if (method === \"_reserveSeat\" && e.message === \"ipc_timeout\") {\n        throw e;\n      }\n      const request = `${method}${args && \" with args \" + JSON.stringify(args) || \"\"}`;\n      throw new ServerError(\n        ErrorCode.MATCHMAKE_UNHANDLED,\n        `remote room (${roomId}) timed out, requesting \"${request}\". (${rejectionTimeout}ms exceeded)`\n      );\n    }\n  } else {\n    return !args && typeof room[method] !== \"function\" ? room[method] : await room[method].apply(room, args && JSON.parse(JSON.stringify(args)));\n  }\n}\nfunction defineRoomType(roomName, klass, defaultOptions) {\n  const registeredHandler = new RegisteredHandler(roomName, klass, defaultOptions);\n  handlers[roomName] = registeredHandler;\n  if (klass.prototype[\"onAuth\"] !== Room.prototype[\"onAuth\"]) {\n    if (klass[\"onAuth\"] !== Room[\"onAuth\"]) {\n      logger.info(`\\u274C \"${roomName}\"'s onAuth() defined at the instance level will be ignored.`);\n    }\n  }\n  return registeredHandler;\n}\nfunction removeRoomType(roomName) {\n  delete handlers[roomName];\n}\nfunction hasHandler(roomName) {\n  logger.warn(\"hasHandler() is deprecated. Use getHandler() instead.\");\n  return handlers[roomName] !== void 0;\n}\nfunction getHandler(roomName) {\n  const handler = handlers[roomName];\n  if (!handler) {\n    throw new ServerError(ErrorCode.MATCHMAKE_NO_HANDLER, `provided room name \"${roomName}\" not defined`);\n  }\n  return handler;\n}\nfunction getRoomClass(roomName) {\n  return handlers[roomName]?.klass;\n}\nasync function createRoom(roomName, clientOptions) {\n  const selectedProcessId = state === 1 /* READY */ ? await selectProcessIdToCreateRoom(roomName, clientOptions) : processId;\n  let room;\n  if (selectedProcessId === void 0) {\n    if (isDevMode && processId === void 0) {\n      await onReady;\n      return createRoom(roomName, clientOptions);\n    } else {\n      throw new ServerError(ErrorCode.MATCHMAKE_UNHANDLED, `no processId available to create room ${roomName}`);\n    }\n  } else if (selectedProcessId === processId) {\n    room = await handleCreateRoom(roomName, clientOptions);\n  } else {\n    try {\n      room = await requestFromIPC(\n        presence,\n        getProcessChannel(selectedProcessId),\n        void 0,\n        [roomName, clientOptions],\n        REMOTE_ROOM_SHORT_TIMEOUT\n      );\n    } catch (e) {\n      if (e.message === \"ipc_timeout\") {\n        debugAndPrintError(`${e.message}: create room request timed out for ${roomName} on processId ${selectedProcessId}.`);\n        if (enableHealthChecks) {\n          await stats.excludeProcess(selectedProcessId);\n        }\n        room = await handleCreateRoom(roomName, clientOptions);\n      } else {\n        throw e;\n      }\n    }\n  }\n  if (isDevMode) {\n    presence.hset(getRoomRestoreListKey(), room.roomId, JSON.stringify({\n      \"clientOptions\": clientOptions,\n      \"roomName\": roomName,\n      \"processId\": processId\n    }));\n  }\n  return room;\n}\nasync function handleCreateRoom(roomName, clientOptions, restoringRoomId) {\n  const handler = getHandler(roomName);\n  const room = new handler.klass();\n  if (restoringRoomId && isDevMode) {\n    room.roomId = restoringRoomId;\n  } else {\n    room.roomId = generateId();\n  }\n  room[\"__init\"]();\n  room.roomName = roomName;\n  room.presence = presence;\n  const additionalListingData = handler.getFilterOptions(clientOptions);\n  if (publicAddress) {\n    additionalListingData.publicAddress = publicAddress;\n  }\n  room.listing = driver.createInstance({\n    name: roomName,\n    processId,\n    ...additionalListingData\n  });\n  if (room.onCreate) {\n    try {\n      await room.onCreate(merge({}, clientOptions, handler.options));\n    } catch (e) {\n      debugAndPrintError(e);\n      throw new ServerError(\n        e.code || ErrorCode.MATCHMAKE_UNHANDLED,\n        e.message\n      );\n    }\n  }\n  room[\"_internalState\"] = RoomInternalState.CREATED;\n  room.listing.roomId = room.roomId;\n  room.listing.maxClients = room.maxClients;\n  debugMatchMaking(\"spawning '%s', roomId: %s, processId: %s\", roomName, room.roomId, processId);\n  stats.local.roomCount++;\n  stats.persist();\n  room._events.on(\"lock\", lockRoom.bind(this, room));\n  room._events.on(\"unlock\", unlockRoom.bind(this, room));\n  room._events.on(\"join\", onClientJoinRoom.bind(this, room));\n  room._events.on(\"leave\", onClientLeaveRoom.bind(this, room));\n  room._events.on(\"visibility-change\", onVisibilityChange.bind(this, room));\n  room._events.once(\"dispose\", disposeRoom.bind(this, roomName, room));\n  room._events.once(\"disconnect\", () => {\n    room._events.removeAllListeners(\"lock\");\n    room._events.removeAllListeners(\"unlock\");\n    room._events.removeAllListeners(\"visibility-change\");\n    room._events.removeAllListeners(\"dispose\");\n    if (stats.local.roomCount <= 0) {\n      events.emit(\"no-active-rooms\");\n    }\n  });\n  await createRoomReferences(room, true);\n  if (state !== 2 /* SHUTTING_DOWN */) {\n    await room.listing.save();\n  }\n  handler.emit(\"create\", room);\n  return room.listing;\n}\nfunction getRoomById(roomId) {\n  return driver.findOne({ roomId });\n}\nfunction getLocalRoomById(roomId) {\n  return rooms[roomId];\n}\nfunction disconnectAll(closeCode) {\n  const promises = [];\n  for (const roomId in rooms) {\n    if (!rooms.hasOwnProperty(roomId)) {\n      continue;\n    }\n    promises.push(rooms[roomId].disconnect(closeCode));\n  }\n  return promises;\n}\nasync function lockAndDisposeAll() {\n  await stats.excludeProcess(processId);\n  if (enableHealthChecks) {\n    stats.clearAutoPersistInterval();\n  }\n  const noActiveRooms = new Deferred();\n  if (stats.local.roomCount <= 0) {\n    noActiveRooms.resolve();\n  } else {\n    events.once(\"no-active-rooms\", () => noActiveRooms.resolve());\n  }\n  for (const roomId in rooms) {\n    if (!rooms.hasOwnProperty(roomId)) {\n      continue;\n    }\n    const room = rooms[roomId];\n    room.lock();\n    room.onBeforeShutdown();\n  }\n  await noActiveRooms;\n}\nasync function gracefullyShutdown() {\n  if (state === 2 /* SHUTTING_DOWN */) {\n    return Promise.reject(\"already_shutting_down\");\n  }\n  debugMatchMaking(`${processId} is shutting down!`);\n  state = 2 /* SHUTTING_DOWN */;\n  onReady = void 0;\n  await lockAndDisposeAll();\n  if (isDevMode) {\n    await cacheRoomHistory(rooms);\n  }\n  await removeRoomsByProcessId(processId);\n  presence.unsubscribe(getProcessChannel());\n  return Promise.all(disconnectAll(\n    isDevMode ? Protocol.WS_CLOSE_DEVMODE_RESTART : void 0\n  ));\n}\nasync function reserveSeatFor(room, options, authData) {\n  const sessionId = generateId();\n  debugMatchMaking(\n    \"reserving seat. sessionId: '%s', roomId: '%s', processId: '%s'\",\n    sessionId,\n    room.roomId,\n    processId\n  );\n  let successfulSeatReservation;\n  try {\n    successfulSeatReservation = await remoteRoomCall(\n      room.roomId,\n      \"_reserveSeat\",\n      [sessionId, options, authData],\n      REMOTE_ROOM_SHORT_TIMEOUT\n    );\n  } catch (e) {\n    debugMatchMaking(e);\n    if (e.message === \"ipc_timeout\" && !(enableHealthChecks && await healthCheckProcessId(room.processId))) {\n      throw new SeatReservationError(`process ${room.processId} is not available.`);\n    } else {\n      successfulSeatReservation = false;\n    }\n  }\n  if (!successfulSeatReservation) {\n    throw new SeatReservationError(`${room.roomId} is already full.`);\n  }\n  const response = { room, sessionId };\n  if (isDevMode) {\n    response.devMode = isDevMode;\n  }\n  return response;\n}\nfunction callOnAuth(roomName, clientOptions, authContext) {\n  const roomClass = getRoomClass(roomName);\n  return roomClass && roomClass[\"onAuth\"] && roomClass[\"onAuth\"] !== Room[\"onAuth\"] ? roomClass[\"onAuth\"](authContext.token, clientOptions, authContext) : void 0;\n}\nasync function healthCheckAllProcesses() {\n  const allStats = await stats.fetchAll();\n  if (allStats.length > 0) {\n    await Promise.all(\n      allStats.filter((stat) => stat.processId !== processId).map((stat) => healthCheckProcessId(stat.processId))\n    );\n  }\n}\nvar _healthCheckByProcessId = {};\nfunction healthCheckProcessId(processId2) {\n  if (_healthCheckByProcessId[processId2] !== void 0) {\n    return _healthCheckByProcessId[processId2];\n  }\n  _healthCheckByProcessId[processId2] = new Promise(async (resolve, reject) => {\n    logger.debug(`> Performing health-check against processId: '${processId2}'...`);\n    try {\n      const requestTime = Date.now();\n      await requestFromIPC(\n        presence,\n        getProcessChannel(processId2),\n        \"healthcheck\",\n        [],\n        REMOTE_ROOM_SHORT_TIMEOUT\n      );\n      logger.debug(`\\u2705 Process '${processId2}' successfully responded (${Date.now() - requestTime}ms)`);\n      resolve(true);\n    } catch (e) {\n      logger.debug(`\\u274C Process '${processId2}' failed to respond. Cleaning it up.`);\n      const isProcessExcluded = await stats.excludeProcess(processId2);\n      if (isProcessExcluded && !isDevMode) {\n        await removeRoomsByProcessId(processId2);\n      }\n      resolve(false);\n    } finally {\n      delete _healthCheckByProcessId[processId2];\n    }\n  });\n  return _healthCheckByProcessId[processId2];\n}\nasync function removeRoomsByProcessId(processId2) {\n  await driver.cleanup(processId2);\n}\nasync function createRoomReferences(room, init = false) {\n  rooms[room.roomId] = room;\n  if (init) {\n    await subscribeIPC(\n      presence,\n      processId,\n      getRoomChannel(room.roomId),\n      (method, args) => {\n        return !args && typeof room[method] !== \"function\" ? room[method] : room[method].apply(room, args);\n      }\n    );\n  }\n  return true;\n}\nasync function concurrentJoinOrCreateRoomLock(handler, concurrencyKey, callback) {\n  return new Promise(async (resolve, reject) => {\n    const hkey = getConcurrencyHashKey(handler.name);\n    const concurrency = await presence.hincrbyex(\n      hkey,\n      concurrencyKey,\n      1,\n      // increment by 1\n      MAX_CONCURRENT_CREATE_ROOM_WAIT_TIME * 2\n      // expire in 2x the time of MAX_CONCURRENT_CREATE_ROOM_WAIT_TIME\n    ) - 1;\n    const fulfill = async (roomId) => {\n      try {\n        resolve(await callback(roomId));\n      } catch (e) {\n        reject(e);\n      } finally {\n        await presence.hincrby(hkey, concurrencyKey, -1);\n      }\n    };\n    if (concurrency > 0) {\n      debugMatchMaking(\n        \"receiving %d concurrent joinOrCreate for '%s' (%s)\",\n        concurrency,\n        handler.name,\n        concurrencyKey\n      );\n      const result = await presence.brpop(\n        `l:${handler.name}:${concurrencyKey}`,\n        MAX_CONCURRENT_CREATE_ROOM_WAIT_TIME + Math.min(concurrency, 3) * 0.2\n        // add extra milliseconds for each concurrent request\n      );\n      return await fulfill(result && result[1]);\n    } else {\n      return await fulfill();\n    }\n  });\n}\nfunction onClientJoinRoom(room, client) {\n  stats.local.ccu++;\n  stats.persist();\n  handlers[room.roomName].emit(\"join\", room, client);\n}\nfunction onClientLeaveRoom(room, client, willDispose) {\n  stats.local.ccu--;\n  stats.persist();\n  handlers[room.roomName].emit(\"leave\", room, client, willDispose);\n}\nfunction lockRoom(room) {\n  handlers[room.roomName].emit(\"lock\", room);\n}\nasync function unlockRoom(room) {\n  if (await createRoomReferences(room)) {\n    handlers[room.roomName].emit(\"unlock\", room);\n  }\n}\nfunction onVisibilityChange(room, isInvisible) {\n  handlers[room.roomName].emit(\"visibility-change\", room, isInvisible);\n}\nasync function disposeRoom(roomName, room) {\n  debugMatchMaking(\"disposing '%s' (%s) on processId '%s' (graceful shutdown: %s)\", roomName, room.roomId, processId, state === 2 /* SHUTTING_DOWN */);\n  room.listing.remove();\n  stats.local.roomCount--;\n  if (state !== 2 /* SHUTTING_DOWN */) {\n    stats.persist();\n    if (isDevMode) {\n      await presence.hdel(getRoomRestoreListKey(), room.roomId);\n    }\n  }\n  handlers[roomName].emit(\"dispose\", room);\n  presence.unsubscribe(getRoomChannel(room.roomId));\n  delete rooms[room.roomId];\n}\nfunction getRoomChannel(roomId) {\n  return `$${roomId}`;\n}\nfunction getConcurrencyHashKey(roomName) {\n  return `ch:${roomName}`;\n}\nfunction getProcessChannel(id = processId) {\n  return `p:${id}`;\n}\nexport {\n  MatchMakerState,\n  accept,\n  controller,\n  create,\n  createRoom,\n  defineRoomType,\n  disconnectAll,\n  driver,\n  findOneRoomAvailable,\n  getHandler,\n  getLocalRoomById,\n  getRoomById,\n  getRoomClass,\n  gracefullyShutdown,\n  handleCreateRoom,\n  hasHandler,\n  healthCheckAllProcesses,\n  healthCheckProcessId,\n  join,\n  joinById,\n  joinOrCreate,\n  onReady,\n  presence,\n  processId,\n  publicAddress,\n  query,\n  reconnect,\n  remoteRoomCall,\n  removeRoomType,\n  reserveSeatFor,\n  selectProcessIdToCreateRoom,\n  setHealthChecksEnabled,\n  setup,\n  state,\n  stats\n};\n", "// packages/core/src/utils/Utils.ts\nimport nanoid from \"nanoid\";\nimport { EventEmitter } from \"events\";\nimport { debugAndPrintError } from \"../Debug.mjs\";\nvar REMOTE_ROOM_SHORT_TIMEOUT = Number(process.env.COLYSEUS_PRESENCE_SHORT_TIMEOUT || 2e3);\nvar MAX_CONCURRENT_CREATE_ROOM_WAIT_TIME = Number(process.env.COLYSEUS_MAX_CONCURRENT_CREATE_ROOM_WAIT_TIME || 0.5);\nfunction generateId(length = 9) {\n  return nanoid(length);\n}\nfunction getBearerToken(authHeader) {\n  return authHeader && authHeader.startsWith(\"Bearer \") && authHeader.substring(7, authHeader.length) || void 0;\n}\nvar signals = [\"SIGINT\", \"SIGTERM\", \"SIGUSR2\"];\nfunction registerGracefulShutdown(callback) {\n  process.on(\"uncaughtException\", (err) => {\n    debugAndPrintError(err);\n    callback(err);\n  });\n  signals.forEach((signal) => process.once(signal, () => callback()));\n}\nfunction retry(cb, maxRetries = 3, errorWhiteList = [], retries = 0) {\n  return new Promise((resolve, reject) => {\n    cb().then(resolve).catch((e) => {\n      if (errorWhiteList.indexOf(e.constructor) !== -1 && retries++ < maxRetries) {\n        setTimeout(() => {\n          retry(cb, maxRetries, errorWhiteList, retries).then(resolve).catch((e2) => reject(e2));\n        }, Math.floor(Math.random() * Math.pow(2, retries) * 400));\n      } else {\n        reject(e);\n      }\n    });\n  });\n}\nfunction spliceOne(arr, index) {\n  if (index === -1 || index >= arr.length) {\n    return false;\n  }\n  const len = arr.length - 1;\n  for (let i = index; i < len; i++) {\n    arr[i] = arr[i + 1];\n  }\n  arr.length = len;\n  return true;\n}\nvar Deferred = class _Deferred {\n  constructor(promise) {\n    this.promise = promise ?? new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n  then(func) {\n    return this.promise.then.apply(this.promise, arguments);\n  }\n  catch(func) {\n    return this.promise.catch(func);\n  }\n  static reject(reason) {\n    return new _Deferred(Promise.reject(reason));\n  }\n  static resolve(value) {\n    return new _Deferred(Promise.resolve(value));\n  }\n};\nfunction merge(a, ...objs) {\n  for (let i = 0, len = objs.length; i < len; i++) {\n    const b = objs[i];\n    for (const key in b) {\n      if (b.hasOwnProperty(key)) {\n        a[key] = b[key];\n      }\n    }\n  }\n  return a;\n}\nfunction wrapTryCatch(method, onError, exceptionClass, methodName, rethrow = false, ...additionalErrorArgs) {\n  return (...args) => {\n    try {\n      const result = method(...args);\n      if (typeof result?.catch === \"function\") {\n        return result.catch((e) => {\n          onError(new exceptionClass(e, e.message, ...args, ...additionalErrorArgs), methodName);\n          if (rethrow) {\n            throw e;\n          }\n        });\n      }\n      return result;\n    } catch (e) {\n      onError(new exceptionClass(e, e.message, ...args, ...additionalErrorArgs), methodName);\n      if (rethrow) {\n        throw e;\n      }\n    }\n  };\n}\nvar HttpServerMock = class extends EventEmitter {\n};\nexport {\n  Deferred,\n  HttpServerMock,\n  MAX_CONCURRENT_CREATE_ROOM_WAIT_TIME,\n  REMOTE_ROOM_SHORT_TIMEOUT,\n  generateId,\n  getBearerToken,\n  merge,\n  registerGracefulShutdown,\n  retry,\n  spliceOne,\n  wrapTryCatch\n};\n", "// packages/core/src/utils/DevMode.ts\nimport debug from \"debug\";\nimport { logger } from \"../Logger.mjs\";\nimport { debugAndPrintError } from \"../Debug.mjs\";\nimport { getLocalRoomById, handleCreateRoom, presence, remoteRoomCall } from \"../MatchMaker.mjs\";\nvar debugDevMode = debug(\"colyseus:devmode\");\nvar isDevMode = false;\nfunction setDevMode(bool) {\n  isDevMode = bool;\n}\nasync function reloadFromCache() {\n  const roomHistoryList = Object.entries(await presence.hgetall(getRoomRestoreListKey()));\n  debugDevMode(\"rooms to restore: %i\", roomHistoryList.length);\n  for (const [roomId, value] of roomHistoryList) {\n    const roomHistory = JSON.parse(value);\n    debugDevMode(\"restoring room %s (%s)\", roomHistory.roomName, roomId);\n    const recreatedRoomListing = await handleCreateRoom(roomHistory.roomName, roomHistory.clientOptions, roomId);\n    const recreatedRoom = getLocalRoomById(recreatedRoomListing.roomId);\n    logger.debug(`\\u{1F504} room '${roomId}' has been restored.`);\n    if (roomHistory.hasOwnProperty(\"state\")) {\n      recreatedRoom.state.decode(roomHistory.state);\n      recreatedRoom.setState(recreatedRoom.state.clone());\n      logger.debug(`\\u{1F4CB} room '${roomId}' state =>`, recreatedRoom.state.toJSON());\n    }\n    recreatedRoom.onRestoreRoom?.(roomHistory[\"cache\"]);\n    if (roomHistory.clients) {\n      for (const previousSessionId of roomHistory.clients) {\n        await remoteRoomCall(recreatedRoomListing.roomId, \"_reserveSeat\", [previousSessionId, {}, 20, false, true]);\n      }\n    }\n  }\n  if (roomHistoryList.length > 0) {\n    logger.debug(\"\\u2705\", roomHistoryList.length, \"room(s) have been restored.\");\n  }\n}\nasync function cacheRoomHistory(rooms) {\n  for (const room of Object.values(rooms)) {\n    const roomHistoryResult = await presence.hget(getRoomRestoreListKey(), room.roomId);\n    if (roomHistoryResult) {\n      try {\n        const roomHistory = JSON.parse(roomHistoryResult);\n        roomHistory[\"cache\"] = room.onCacheRoom?.();\n        debugDevMode(\"caching room %s (%s)\", room.roomName, room.roomId);\n        if (room.state) {\n          roomHistory[\"state\"] = room.state.encodeAll();\n        }\n        roomHistory[\"clients\"] = room.clients.map((client) => client.sessionId);\n        for (const sessionId in room[\"reservedSeats\"]) {\n          roomHistory[\"clients\"].push(sessionId);\n        }\n        await presence.hset(getRoomRestoreListKey(), room.roomId, JSON.stringify(roomHistory));\n        logger.debug(`\\u{1F4BE} caching room '${room.roomId}' (clients: ${room.clients.length}, state size: ${(roomHistory[\"state\"] || []).length} bytes)`);\n      } catch (e) {\n        debugAndPrintError(`\\u274C couldn't cache room '${room.roomId}', due to:\n${e.stack}`);\n      }\n    }\n  }\n}\nasync function getPreviousProcessId(hostname) {\n  return await presence.hget(getProcessRestoreKey(), hostname);\n}\nfunction getRoomRestoreListKey() {\n  return \"roomhistory\";\n}\nfunction getProcessRestoreKey() {\n  return \"processhistory\";\n}\nexport {\n  cacheRoomHistory,\n  debugDevMode,\n  getPreviousProcessId,\n  getProcessRestoreKey,\n  getRoomRestoreListKey,\n  isDevMode,\n  reloadFromCache,\n  setDevMode\n};\n", "// packages/core/src/Room.ts\nimport { unpack } from \"@colyseus/msgpackr\";\nimport { decode, $changes } from \"@colyseus/schema\";\nimport Clock from \"@colyseus/timer\";\nimport { EventEmitter } from \"events\";\nimport { logger } from \"./Logger.mjs\";\nimport { NoneSerializer } from \"./serializer/NoneSerializer.mjs\";\nimport { SchemaSerializer } from \"./serializer/SchemaSerializer.mjs\";\nimport { ErrorCode, getMessageBytes, Protocol } from \"./Protocol.mjs\";\nimport { Deferred, generateId, wrapTryCatch } from \"./utils/Utils.mjs\";\nimport { isDevMode } from \"./utils/DevMode.mjs\";\nimport { debugAndPrintError, debugMatchMaking, debugMessage } from \"./Debug.mjs\";\nimport { ServerError } from \"./errors/ServerError.mjs\";\nimport { ClientArray, ClientState } from \"./Transport.mjs\";\nimport { OnAuthException, OnCreateException, OnDisposeException, OnJoinException, OnLeaveException, OnMessageException, SimulationIntervalException, TimedEventException } from \"./errors/RoomExceptions.mjs\";\nvar DEFAULT_PATCH_RATE = 1e3 / 20;\nvar DEFAULT_SIMULATION_INTERVAL = 1e3 / 60;\nvar noneSerializer = new NoneSerializer();\nvar DEFAULT_SEAT_RESERVATION_TIME = Number(process.env.COLYSEUS_SEAT_RESERVATION_TIME || 15);\nvar RoomInternalState = /* @__PURE__ */ ((RoomInternalState2) => {\n  RoomInternalState2[RoomInternalState2[\"CREATING\"] = 0] = \"CREATING\";\n  RoomInternalState2[RoomInternalState2[\"CREATED\"] = 1] = \"CREATED\";\n  RoomInternalState2[RoomInternalState2[\"DISPOSING\"] = 2] = \"DISPOSING\";\n  return RoomInternalState2;\n})(RoomInternalState || {});\nvar Room = class _Room {\n  constructor() {\n    /**\n     * Timing events tied to the room instance.\n     * Intervals and timeouts are cleared when the room is disposed.\n     */\n    this.clock = new Clock();\n    this.#_onLeaveConcurrent = 0;\n    // number of onLeave calls in progress\n    /**\n     * Maximum number of clients allowed to connect into the room. When room reaches this limit,\n     * it is locked automatically. Unless the room was explicitly locked by you via `lock()` method,\n     * the room will be unlocked as soon as a client disconnects from it.\n     */\n    this.maxClients = Infinity;\n    this.#_maxClientsReached = false;\n    /**\n     * Automatically dispose the room when last client disconnects.\n     *\n     * @default true\n     */\n    this.autoDispose = true;\n    /**\n     * Frequency to send the room state to connected clients, in milliseconds.\n     *\n     * @default 50ms (20fps)\n     */\n    this.patchRate = DEFAULT_PATCH_RATE;\n    /**\n     * The array of connected clients.\n     *\n     * @see {@link https://docs.colyseus.io/colyseus/server/room/#client|Client instance}\n     */\n    this.clients = new ClientArray();\n    /** @internal */\n    this._events = new EventEmitter();\n    // seat reservation & reconnection\n    this.seatReservationTime = DEFAULT_SEAT_RESERVATION_TIME;\n    this.reservedSeats = {};\n    this.reservedSeatTimeouts = {};\n    this._reconnections = {};\n    this._reconnectingSessionId = /* @__PURE__ */ new Map();\n    this.onMessageHandlers = {\n      \"__no_message_handler\": {\n        callback: (client, messageType, _) => {\n          const errorMessage = `room onMessage for \"${messageType}\" not registered.`;\n          debugAndPrintError(`${errorMessage} (roomId: ${this.roomId})`);\n          if (isDevMode) {\n            client.error(ErrorCode.INVALID_PAYLOAD, errorMessage);\n          } else {\n            client.leave(Protocol.WS_CLOSE_WITH_ERROR, errorMessage);\n          }\n        }\n      }\n    };\n    this._serializer = noneSerializer;\n    this._afterNextPatchQueue = [];\n    this._internalState = 0 /* CREATING */;\n    this._lockedExplicitly = false;\n    this.#_locked = false;\n    this._events.once(\"dispose\", () => {\n      this._dispose().catch((e) => debugAndPrintError(`onDispose error: ${e && e.stack || e.message || e || \"promise rejected\"} (roomId: ${this.roomId})`)).finally(() => this._events.emit(\"disconnect\"));\n    });\n    if (this.onUncaughtException !== void 0) {\n      this.#registerUncaughtExceptionHandlers();\n    }\n  }\n  /**\n   * This property will change on these situations:\n   * - The maximum number of allowed clients has been reached (`maxClients`)\n   * - You manually locked, or unlocked the room using lock() or `unlock()`.\n   *\n   * @readonly\n   */\n  get locked() {\n    return this.#_locked;\n  }\n  get metadata() {\n    return this.listing.metadata;\n  }\n  #_roomId;\n  #_roomName;\n  #_onLeaveConcurrent;\n  #_maxClientsReached;\n  #_maxClients;\n  #_autoDispose;\n  #_patchRate;\n  #_patchInterval;\n  #_state;\n  #_locked;\n  /**\n   * This method is called by the MatchMaker before onCreate()\n   * @internal\n   */\n  __init() {\n    this.#_state = this.state;\n    this.#_autoDispose = this.autoDispose;\n    this.#_patchRate = this.patchRate;\n    this.#_maxClients = this.maxClients;\n    Object.defineProperties(this, {\n      state: {\n        enumerable: true,\n        get: () => this.#_state,\n        set: (newState) => {\n          if (newState[$changes] !== void 0) {\n            this.setSerializer(new SchemaSerializer());\n          } else if (\"_definition\" in newState) {\n            throw new Error(\"@colyseus/schema v2 compatibility currently missing (reach out if you need it)\");\n          } else if ($changes === void 0) {\n            throw new Error(\"Multiple @colyseus/schema versions detected. Please make sure you don't have multiple versions of @colyseus/schema installed.\");\n          }\n          this._serializer.reset(newState);\n          this.#_state = newState;\n        }\n      },\n      maxClients: {\n        enumerable: true,\n        get: () => this.#_maxClients,\n        set: (value) => {\n          this.#_maxClients = value;\n          if (this._internalState === 1 /* CREATED */) {\n            const hasReachedMaxClients = this.hasReachedMaxClients();\n            if (!this._lockedExplicitly && this.#_maxClientsReached && !hasReachedMaxClients) {\n              this.#_maxClientsReached = false;\n              this.#_locked = false;\n              this.listing.locked = false;\n            }\n            if (hasReachedMaxClients) {\n              this.#_maxClientsReached = true;\n              this.#_locked = true;\n              this.listing.locked = true;\n            }\n            this.listing.maxClients = value;\n            this.listing.save();\n          }\n        }\n      },\n      autoDispose: {\n        enumerable: true,\n        get: () => this.#_autoDispose,\n        set: (value) => {\n          if (value !== this.#_autoDispose && this._internalState !== 2 /* DISPOSING */) {\n            this.#_autoDispose = value;\n            this.resetAutoDisposeTimeout();\n          }\n        }\n      },\n      patchRate: {\n        enumerable: true,\n        get: () => this.#_patchRate,\n        set: (milliseconds) => {\n          this.#_patchRate = milliseconds;\n          if (this.#_patchInterval) {\n            clearInterval(this.#_patchInterval);\n            this.#_patchInterval = void 0;\n          }\n          if (milliseconds !== null && milliseconds !== 0) {\n            this.#_patchInterval = setInterval(() => this.broadcastPatch(), milliseconds);\n          }\n        }\n      }\n    });\n    this.patchRate = this.#_patchRate;\n    if (this.#_state) {\n      this.state = this.#_state;\n    }\n    this.resetAutoDisposeTimeout(this.seatReservationTime);\n    this.clock.start();\n  }\n  /**\n   * The name of the room you provided as first argument for `gameServer.define()`.\n   *\n   * @returns roomName string\n   */\n  get roomName() {\n    return this.#_roomName;\n  }\n  /**\n   * Setting the name of the room. Overwriting this property is restricted.\n   *\n   * @param roomName\n   */\n  set roomName(roomName) {\n    if (this.#_roomName) {\n      throw new ServerError(ErrorCode.APPLICATION_ERROR, \"'roomName' cannot be overwritten.\");\n    }\n    this.#_roomName = roomName;\n  }\n  /**\n   * A unique, auto-generated, 9-character-long id of the room.\n   * You may replace `this.roomId` during `onCreate()`.\n   *\n   * @returns roomId string\n   */\n  get roomId() {\n    return this.#_roomId;\n  }\n  /**\n   * Setting the roomId, is restricted in room lifetime except upon room creation.\n   *\n   * @param roomId\n   * @returns roomId string\n   */\n  set roomId(roomId) {\n    if (this._internalState !== 0 /* CREATING */ && !isDevMode) {\n      throw new ServerError(ErrorCode.APPLICATION_ERROR, \"'roomId' can only be overridden upon room creation.\");\n    }\n    this.#_roomId = roomId;\n  }\n  onAuth(client, options, context) {\n    return true;\n  }\n  static async onAuth(token, options, context) {\n    return true;\n  }\n  /**\n   * This method is called during graceful shutdown of the server process\n   * You may override this method to dispose the room in your own way.\n   *\n   * Once process reaches room count of 0, the room process will be terminated.\n   */\n  onBeforeShutdown() {\n    this.disconnect(\n      isDevMode ? Protocol.WS_CLOSE_DEVMODE_RESTART : Protocol.WS_CLOSE_CONSENTED\n    );\n  }\n  /**\n   * Returns whether the sum of connected clients and reserved seats exceeds maximum number of clients.\n   *\n   * @returns boolean\n   */\n  hasReachedMaxClients() {\n    return this.clients.length + Object.keys(this.reservedSeats).length >= this.maxClients || this._internalState === 2 /* DISPOSING */;\n  }\n  /**\n   * Set the number of seconds a room can wait for a client to effectively join the room.\n   * You should consider how long your `onAuth()` will have to wait for setting a different seat reservation time.\n   * The default value is 15 seconds. You may set the `COLYSEUS_SEAT_RESERVATION_TIME`\n   * environment variable if you'd like to change the seat reservation time globally.\n   *\n   * @default 15 seconds\n   *\n   * @param seconds - number of seconds.\n   * @returns The modified Room object.\n   */\n  setSeatReservationTime(seconds) {\n    this.seatReservationTime = seconds;\n    return this;\n  }\n  hasReservedSeat(sessionId, reconnectionToken) {\n    const reservedSeat = this.reservedSeats[sessionId];\n    if (reservedSeat === void 0) {\n      return false;\n    }\n    if (reservedSeat[3]) {\n      return reconnectionToken && this._reconnections[reconnectionToken]?.[0] === sessionId && this._reconnectingSessionId.has(sessionId);\n    } else {\n      return reservedSeat[2] === false;\n    }\n  }\n  checkReconnectionToken(reconnectionToken) {\n    const sessionId = this._reconnections[reconnectionToken]?.[0];\n    const reservedSeat = this.reservedSeats[sessionId];\n    if (reservedSeat && reservedSeat[3]) {\n      this._reconnectingSessionId.set(sessionId, reconnectionToken);\n      return sessionId;\n    } else {\n      return void 0;\n    }\n  }\n  /**\n   * (Optional) Set a simulation interval that can change the state of the game.\n   * The simulation interval is your game loop.\n   *\n   * @default 16.6ms (60fps)\n   *\n   * @param onTickCallback - You can implement your physics or world updates here!\n   *  This is a good place to update the room state.\n   * @param delay - Interval delay on executing `onTickCallback` in milliseconds.\n   */\n  setSimulationInterval(onTickCallback, delay = DEFAULT_SIMULATION_INTERVAL) {\n    if (this._simulationInterval) {\n      clearInterval(this._simulationInterval);\n    }\n    if (onTickCallback) {\n      if (this.onUncaughtException !== void 0) {\n        onTickCallback = wrapTryCatch(onTickCallback, this.onUncaughtException.bind(this), SimulationIntervalException, \"setSimulationInterval\");\n      }\n      this._simulationInterval = setInterval(() => {\n        this.clock.tick();\n        onTickCallback(this.clock.deltaTime);\n      }, delay);\n    }\n  }\n  /**\n   * @deprecated Use `.patchRate=` instead.\n   */\n  setPatchRate(milliseconds) {\n    this.patchRate = milliseconds;\n  }\n  /**\n   * @deprecated Use `.state =` instead.\n   */\n  setState(newState) {\n    this.state = newState;\n  }\n  setSerializer(serializer) {\n    this._serializer = serializer;\n  }\n  async setMetadata(meta) {\n    if (!this.listing.metadata) {\n      this.listing.metadata = meta;\n    } else {\n      for (const field in meta) {\n        if (!meta.hasOwnProperty(field)) {\n          continue;\n        }\n        this.listing.metadata[field] = meta[field];\n      }\n      if (\"markModified\" in this.listing) {\n        this.listing.markModified(\"metadata\");\n      }\n    }\n    if (this._internalState === 1 /* CREATED */) {\n      await this.listing.save();\n    }\n  }\n  async setPrivate(bool = true) {\n    if (this.listing.private === bool) return;\n    this.listing.private = bool;\n    if (this._internalState === 1 /* CREATED */) {\n      await this.listing.save();\n    }\n    this._events.emit(\"visibility-change\", bool);\n  }\n  /**\n   * Locking the room will remove it from the pool of available rooms for new clients to connect to.\n   */\n  async lock() {\n    this._lockedExplicitly = arguments[0] === void 0;\n    if (this.#_locked) {\n      return;\n    }\n    this.#_locked = true;\n    await this.listing.updateOne({\n      $set: { locked: this.#_locked }\n    });\n    this._events.emit(\"lock\");\n  }\n  /**\n   * Unlocking the room returns it to the pool of available rooms for new clients to connect to.\n   */\n  async unlock() {\n    if (arguments[0] === void 0) {\n      this._lockedExplicitly = false;\n    }\n    if (!this.#_locked) {\n      return;\n    }\n    this.#_locked = false;\n    await this.listing.updateOne({\n      $set: { locked: this.#_locked }\n    });\n    this._events.emit(\"unlock\");\n  }\n  send(client, messageOrType, messageOrOptions, options) {\n    logger.warn(\"DEPRECATION WARNING: use client.send(...) instead of this.send(client, ...)\");\n    client.send(messageOrType, messageOrOptions, options);\n  }\n  broadcast(type, message, options) {\n    if (options && options.afterNextPatch) {\n      delete options.afterNextPatch;\n      this._afterNextPatchQueue.push([\"broadcast\", arguments]);\n      return;\n    }\n    this.broadcastMessageType(type, message, options);\n  }\n  /**\n   * Broadcast bytes (UInt8Arrays) to a particular room\n   */\n  broadcastBytes(type, message, options) {\n    if (options && options.afterNextPatch) {\n      delete options.afterNextPatch;\n      this._afterNextPatchQueue.push([\"broadcastBytes\", arguments]);\n      return;\n    }\n    this.broadcastMessageType(type, message, options);\n  }\n  /**\n   * Checks whether mutations have occurred in the state, and broadcast them to all connected clients.\n   */\n  broadcastPatch() {\n    if (this.onBeforePatch) {\n      this.onBeforePatch(this.state);\n    }\n    if (!this._simulationInterval) {\n      this.clock.tick();\n    }\n    if (!this.state) {\n      return false;\n    }\n    const hasChanges = this._serializer.applyPatches(this.clients, this.state);\n    this._dequeueAfterPatchMessages();\n    return hasChanges;\n  }\n  onMessage(messageType, callback, validate) {\n    this.onMessageHandlers[messageType] = this.onUncaughtException !== void 0 ? { validate, callback: wrapTryCatch(callback, this.onUncaughtException.bind(this), OnMessageException, \"onMessage\", false, messageType) } : { validate, callback };\n    return () => delete this.onMessageHandlers[messageType];\n  }\n  /**\n   * Disconnect all connected clients, and then dispose the room.\n   *\n   * @param closeCode WebSocket close code (default = 4000, which is a \"consented leave\")\n   * @returns Promise<void>\n   */\n  disconnect(closeCode = Protocol.WS_CLOSE_CONSENTED) {\n    if (this._internalState === 2 /* DISPOSING */) {\n      return Promise.resolve(`disconnect() ignored: room (${this.roomId}) is already disposing.`);\n    } else if (this._internalState === 0 /* CREATING */) {\n      throw new Error(\"cannot disconnect during onCreate()\");\n    }\n    this._internalState = 2 /* DISPOSING */;\n    this.listing.remove();\n    this.#_autoDispose = true;\n    const delayedDisconnection = new Promise((resolve) => this._events.once(\"disconnect\", () => resolve()));\n    for (const [_, reconnection] of Object.values(this._reconnections)) {\n      reconnection.reject(new Error(\"disconnecting\"));\n    }\n    let numClients = this.clients.length;\n    if (numClients > 0) {\n      while (numClients--) {\n        this._forciblyCloseClient(this.clients[numClients], closeCode);\n      }\n    } else {\n      this._events.emit(\"dispose\");\n    }\n    return delayedDisconnection;\n  }\n  async [\"_onJoin\"](client, authContext) {\n    const sessionId = client.sessionId;\n    client.reconnectionToken = generateId();\n    if (this.reservedSeatTimeouts[sessionId]) {\n      clearTimeout(this.reservedSeatTimeouts[sessionId]);\n      delete this.reservedSeatTimeouts[sessionId];\n    }\n    if (this._autoDisposeTimeout) {\n      clearTimeout(this._autoDisposeTimeout);\n      this._autoDisposeTimeout = void 0;\n    }\n    const [joinOptions, authData, isConsumed, isWaitingReconnection] = this.reservedSeats[sessionId];\n    if (isConsumed) {\n      throw new ServerError(ErrorCode.MATCHMAKE_EXPIRED, \"already consumed\");\n    }\n    this.reservedSeats[sessionId][2] = true;\n    debugMatchMaking(\"consuming seat reservation, sessionId: '%s' (roomId: %s)\", client.sessionId, this.roomId);\n    client._afterNextPatchQueue = this._afterNextPatchQueue;\n    client.ref[\"onleave\"] = (_) => client.state = ClientState.LEAVING;\n    client.ref.once(\"close\", client.ref[\"onleave\"]);\n    if (isWaitingReconnection) {\n      const previousReconnectionToken = this._reconnectingSessionId.get(sessionId);\n      if (previousReconnectionToken) {\n        this.clients.push(client);\n        await this._reconnections[previousReconnectionToken]?.[1].resolve(client);\n      } else {\n        const errorMessage = process.env.NODE_ENV === \"production\" ? \"already consumed\" : \"bad reconnection token\";\n        throw new ServerError(ErrorCode.MATCHMAKE_EXPIRED, errorMessage);\n      }\n    } else {\n      try {\n        if (authData) {\n          client.auth = authData;\n        } else if (this.onAuth !== _Room.prototype.onAuth) {\n          try {\n            client.auth = await this.onAuth(client, joinOptions, authContext);\n            if (!client.auth) {\n              throw new ServerError(ErrorCode.AUTH_FAILED, \"onAuth failed\");\n            }\n          } catch (e) {\n            delete this.reservedSeats[sessionId];\n            await this._decrementClientCount();\n            throw e;\n          }\n        }\n        if (client.state === ClientState.LEAVING) {\n          throw new ServerError(Protocol.WS_CLOSE_GOING_AWAY, \"already disconnected\");\n        }\n        this.clients.push(client);\n        Object.defineProperty(this.reservedSeats, sessionId, {\n          value: this.reservedSeats[sessionId],\n          enumerable: false\n        });\n        if (this.onJoin) {\n          await this.onJoin(client, joinOptions, client.auth);\n        }\n        if (client.state === ClientState.LEAVING) {\n          throw new Error(\"early_leave\");\n        } else {\n          delete this.reservedSeats[sessionId];\n          this._events.emit(\"join\", client);\n        }\n      } catch (e) {\n        await this._onLeave(client, Protocol.WS_CLOSE_GOING_AWAY);\n        delete this.reservedSeats[sessionId];\n        if (!e.code) {\n          e.code = ErrorCode.APPLICATION_ERROR;\n        }\n        throw e;\n      }\n    }\n    if (client.state === ClientState.JOINING) {\n      client.ref.removeListener(\"close\", client.ref[\"onleave\"]);\n      client.ref[\"onleave\"] = this._onLeave.bind(this, client);\n      client.ref.once(\"close\", client.ref[\"onleave\"]);\n      client.ref.on(\"message\", this._onMessage.bind(this, client));\n      client.raw(getMessageBytes[Protocol.JOIN_ROOM](\n        client.reconnectionToken,\n        this._serializer.id,\n        this._serializer.handshake && this._serializer.handshake()\n      ));\n    }\n  }\n  /**\n   * Allow the specified client to reconnect into the room. Must be used inside `onLeave()` method.\n   * If seconds is provided, the reconnection is going to be cancelled after the provided amount of seconds.\n   *\n   * @param previousClient - The client which is to be waiting until re-connection happens.\n   * @param seconds - Timeout period on re-connection in seconds.\n   *\n   * @returns Deferred<Client> - The differed is a promise like type.\n   *  This type can forcibly reject the promise by calling `.reject()`.\n   */\n  allowReconnection(previousClient, seconds) {\n    if (previousClient._enqueuedMessages !== void 0) {\n      return Promise.reject(new Error(\"not joined\"));\n    }\n    if (seconds === void 0) {\n      console.warn('DEPRECATED: allowReconnection() requires a second argument. Using \"manual\" mode.');\n      seconds = \"manual\";\n    }\n    if (seconds === \"manual\") {\n      seconds = Infinity;\n    }\n    if (this._internalState === 2 /* DISPOSING */) {\n      return Promise.reject(new Error(\"disposing\"));\n    }\n    const sessionId = previousClient.sessionId;\n    const reconnectionToken = previousClient.reconnectionToken;\n    this._reserveSeat(sessionId, true, previousClient.auth, seconds, true);\n    const reconnection = new Deferred();\n    this._reconnections[reconnectionToken] = [sessionId, reconnection];\n    if (seconds !== Infinity) {\n      this.reservedSeatTimeouts[sessionId] = setTimeout(() => reconnection.reject(false), seconds * 1e3);\n    }\n    const cleanup = () => {\n      delete this._reconnections[reconnectionToken];\n      delete this.reservedSeats[sessionId];\n      delete this.reservedSeatTimeouts[sessionId];\n      this._reconnectingSessionId.delete(sessionId);\n    };\n    reconnection.then((newClient) => {\n      newClient.auth = previousClient.auth;\n      newClient.userData = previousClient.userData;\n      previousClient.state = ClientState.RECONNECTED;\n      previousClient.ref = newClient.ref;\n      previousClient.reconnectionToken = newClient.reconnectionToken;\n      clearTimeout(this.reservedSeatTimeouts[sessionId]);\n      cleanup();\n    }).catch(() => {\n      cleanup();\n      this.resetAutoDisposeTimeout();\n    });\n    return reconnection;\n  }\n  resetAutoDisposeTimeout(timeoutInSeconds = 1) {\n    clearTimeout(this._autoDisposeTimeout);\n    if (!this.#_autoDispose) {\n      return;\n    }\n    this._autoDisposeTimeout = setTimeout(() => {\n      this._autoDisposeTimeout = void 0;\n      this._disposeIfEmpty();\n    }, timeoutInSeconds * 1e3);\n  }\n  broadcastMessageType(type, message, options = {}) {\n    debugMessage(\"broadcast: %O (roomId: %s)\", message, this.roomId);\n    const encodedMessage = message instanceof Uint8Array ? getMessageBytes.raw(Protocol.ROOM_DATA_BYTES, type, void 0, message) : getMessageBytes.raw(Protocol.ROOM_DATA, type, message);\n    const except = typeof options.except !== \"undefined\" ? Array.isArray(options.except) ? options.except : [options.except] : void 0;\n    let numClients = this.clients.length;\n    while (numClients--) {\n      const client = this.clients[numClients];\n      if (!except || !except.includes(client)) {\n        client.enqueueRaw(encodedMessage);\n      }\n    }\n  }\n  sendFullState(client) {\n    client.raw(this._serializer.getFullState(client));\n  }\n  _dequeueAfterPatchMessages() {\n    const length = this._afterNextPatchQueue.length;\n    if (length > 0) {\n      for (let i = 0; i < length; i++) {\n        const [target, args] = this._afterNextPatchQueue[i];\n        if (target === \"broadcast\") {\n          this.broadcast.apply(this, args);\n        } else {\n          target.raw.apply(target, args);\n        }\n      }\n      this._afterNextPatchQueue.splice(0, length);\n    }\n  }\n  async _reserveSeat(sessionId, joinOptions = true, authData = void 0, seconds = this.seatReservationTime, allowReconnection = false, devModeReconnection) {\n    if (!allowReconnection && this.hasReachedMaxClients()) {\n      return false;\n    }\n    this.reservedSeats[sessionId] = [joinOptions, authData, false, allowReconnection];\n    if (!allowReconnection) {\n      await this._incrementClientCount();\n      this.reservedSeatTimeouts[sessionId] = setTimeout(async () => {\n        delete this.reservedSeats[sessionId];\n        delete this.reservedSeatTimeouts[sessionId];\n        await this._decrementClientCount();\n      }, seconds * 1e3);\n      this.resetAutoDisposeTimeout(seconds);\n    }\n    if (devModeReconnection) {\n      this._reconnectingSessionId.set(sessionId, sessionId);\n    }\n    return true;\n  }\n  _disposeIfEmpty() {\n    const willDispose = this.#_onLeaveConcurrent === 0 && // no \"onLeave\" calls in progress\n    this.#_autoDispose && this._autoDisposeTimeout === void 0 && this.clients.length === 0 && Object.keys(this.reservedSeats).length === 0;\n    if (willDispose) {\n      this._events.emit(\"dispose\");\n    }\n    return willDispose;\n  }\n  async _dispose() {\n    this._internalState = 2 /* DISPOSING */;\n    this.listing.remove();\n    let userReturnData;\n    if (this.onDispose) {\n      userReturnData = this.onDispose();\n    }\n    if (this.#_patchInterval) {\n      clearInterval(this.#_patchInterval);\n      this.#_patchInterval = void 0;\n    }\n    if (this._simulationInterval) {\n      clearInterval(this._simulationInterval);\n      this._simulationInterval = void 0;\n    }\n    if (this._autoDisposeTimeout) {\n      clearInterval(this._autoDisposeTimeout);\n      this._autoDisposeTimeout = void 0;\n    }\n    this.clock.clear();\n    this.clock.stop();\n    return await (userReturnData || Promise.resolve());\n  }\n  _onMessage(client, buffer) {\n    if (client.state === ClientState.LEAVING) {\n      return;\n    }\n    const it = { offset: 1 };\n    const code = buffer[0];\n    if (!buffer) {\n      debugAndPrintError(`${this.roomName} (roomId: ${this.roomId}), couldn't decode message: ${buffer}`);\n      return;\n    }\n    if (code === Protocol.ROOM_DATA) {\n      const messageType = decode.stringCheck(buffer, it) ? decode.string(buffer, it) : decode.number(buffer, it);\n      const messageTypeHandler = this.onMessageHandlers[messageType];\n      let message;\n      try {\n        message = buffer.byteLength > it.offset ? unpack(buffer.subarray(it.offset, buffer.byteLength)) : void 0;\n        debugMessage(\"received: '%s' -> %j (roomId: %s)\", messageType, message, this.roomId);\n        if (messageTypeHandler?.validate !== void 0) {\n          message = messageTypeHandler.validate(message);\n        }\n      } catch (e) {\n        debugAndPrintError(e);\n        client.leave(Protocol.WS_CLOSE_WITH_ERROR);\n        return;\n      }\n      if (messageTypeHandler) {\n        messageTypeHandler.callback(client, message);\n      } else {\n        (this.onMessageHandlers[\"*\"] || this.onMessageHandlers[\"__no_message_handler\"]).callback(client, messageType, message);\n      }\n    } else if (code === Protocol.ROOM_DATA_BYTES) {\n      const messageType = decode.stringCheck(buffer, it) ? decode.string(buffer, it) : decode.number(buffer, it);\n      const messageTypeHandler = this.onMessageHandlers[messageType];\n      let message = buffer.subarray(it.offset, buffer.byteLength);\n      debugMessage(\"received: '%s' -> %j (roomId: %s)\", messageType, message, this.roomId);\n      if (messageTypeHandler?.validate !== void 0) {\n        message = messageTypeHandler.validate(message);\n      }\n      if (messageTypeHandler) {\n        messageTypeHandler.callback(client, message);\n      } else {\n        (this.onMessageHandlers[\"*\"] || this.onMessageHandlers[\"__no_message_handler\"]).callback(client, messageType, message);\n      }\n    } else if (code === Protocol.JOIN_ROOM && client.state === ClientState.JOINING) {\n      client.state = ClientState.JOINED;\n      client._joinedAt = this.clock.elapsedTime;\n      if (this.state) {\n        this.sendFullState(client);\n      }\n      if (client._enqueuedMessages.length > 0) {\n        client._enqueuedMessages.forEach((enqueued) => client.raw(enqueued));\n      }\n      delete client._enqueuedMessages;\n    } else if (code === Protocol.LEAVE_ROOM) {\n      this._forciblyCloseClient(client, Protocol.WS_CLOSE_CONSENTED);\n    }\n  }\n  _forciblyCloseClient(client, closeCode) {\n    client.ref.removeAllListeners(\"message\");\n    client.ref.removeListener(\"close\", client.ref[\"onleave\"]);\n    this._onLeave(client, closeCode).then(() => client.leave(closeCode));\n  }\n  async _onLeave(client, code) {\n    debugMatchMaking(\"onLeave, sessionId: '%s' (close code: %d, roomId: %s)\", client.sessionId, code, this.roomId);\n    client.state = ClientState.LEAVING;\n    if (!this.clients.delete(client)) {\n      return;\n    }\n    if (this.onLeave) {\n      try {\n        this.#_onLeaveConcurrent++;\n        await this.onLeave(client, code === Protocol.WS_CLOSE_CONSENTED);\n      } catch (e) {\n        debugAndPrintError(`onLeave error: ${e && e.message || e || \"promise rejected\"} (roomId: ${this.roomId})`);\n      } finally {\n        this.#_onLeaveConcurrent--;\n      }\n    }\n    if (this._reconnections[client.reconnectionToken]) {\n      this._reconnections[client.reconnectionToken][1].catch(async () => {\n        await this._onAfterLeave(client);\n      });\n    } else if (client.state !== ClientState.RECONNECTED) {\n      await this._onAfterLeave(client);\n    }\n  }\n  async _onAfterLeave(client) {\n    const willDispose = await this._decrementClientCount();\n    if (this.reservedSeats[client.sessionId] === void 0) {\n      this._events.emit(\"leave\", client, willDispose);\n    }\n  }\n  async _incrementClientCount() {\n    if (!this.#_locked && this.hasReachedMaxClients()) {\n      this.#_maxClientsReached = true;\n      this.lock.call(this, true);\n    }\n    await this.listing.updateOne({\n      $inc: { clients: 1 },\n      $set: { locked: this.#_locked }\n    });\n  }\n  async _decrementClientCount() {\n    const willDispose = this._disposeIfEmpty();\n    if (this._internalState === 2 /* DISPOSING */) {\n      return true;\n    }\n    if (!willDispose) {\n      if (this.#_maxClientsReached && !this._lockedExplicitly) {\n        this.#_maxClientsReached = false;\n        this.unlock.call(this, true);\n      }\n      await this.listing.updateOne({\n        $inc: { clients: -1 },\n        $set: { locked: this.#_locked }\n      });\n    }\n    return willDispose;\n  }\n  #registerUncaughtExceptionHandlers() {\n    const onUncaughtException = this.onUncaughtException.bind(this);\n    const originalSetTimeout = this.clock.setTimeout;\n    this.clock.setTimeout = (cb, timeout, ...args) => {\n      return originalSetTimeout.call(this.clock, wrapTryCatch(cb, onUncaughtException, TimedEventException, \"setTimeout\"), timeout, ...args);\n    };\n    const originalSetInterval = this.clock.setInterval;\n    this.clock.setInterval = (cb, timeout, ...args) => {\n      return originalSetInterval.call(this.clock, wrapTryCatch(cb, onUncaughtException, TimedEventException, \"setInterval\"), timeout, ...args);\n    };\n    if (this.onCreate !== void 0) {\n      this.onCreate = wrapTryCatch(this.onCreate.bind(this), onUncaughtException, OnCreateException, \"onCreate\", true);\n    }\n    if (this.onAuth !== void 0) {\n      this.onAuth = wrapTryCatch(this.onAuth.bind(this), onUncaughtException, OnAuthException, \"onAuth\", true);\n    }\n    if (this.onJoin !== void 0) {\n      this.onJoin = wrapTryCatch(this.onJoin.bind(this), onUncaughtException, OnJoinException, \"onJoin\", true);\n    }\n    if (this.onLeave !== void 0) {\n      this.onLeave = wrapTryCatch(this.onLeave.bind(this), onUncaughtException, OnLeaveException, \"onLeave\", true);\n    }\n    if (this.onDispose !== void 0) {\n      this.onDispose = wrapTryCatch(this.onDispose.bind(this), onUncaughtException, OnDisposeException, \"onDispose\");\n    }\n  }\n};\nexport {\n  DEFAULT_SEAT_RESERVATION_TIME,\n  Room,\n  RoomInternalState\n};\n", "// packages/core/src/serializer/NoneSerializer.ts\nvar NoneSerializer = class {\n  constructor() {\n    this.id = \"none\";\n  }\n  reset(data) {\n  }\n  getFullState(client) {\n    return null;\n  }\n  applyPatches(clients, state) {\n    return false;\n  }\n};\nexport {\n  NoneSerializer\n};\n", "// packages/core/src/Transport.ts\nimport { spliceOne } from \"./utils/Utils.mjs\";\nvar Transport = class {\n};\nvar ClientState = /* @__PURE__ */ ((ClientState2) => {\n  ClientState2[ClientState2[\"JOINING\"] = 0] = \"JOINING\";\n  ClientState2[ClientState2[\"JOINED\"] = 1] = \"JOINED\";\n  ClientState2[ClientState2[\"RECONNECTED\"] = 2] = \"RECONNECTED\";\n  ClientState2[ClientState2[\"LEAVING\"] = 3] = \"LEAVING\";\n  return ClientState2;\n})(ClientState || {});\nvar ClientArray = class extends Array {\n  getById(sessionId) {\n    return this.find((client) => client.sessionId === sessionId);\n  }\n  delete(client) {\n    return spliceOne(this, this.indexOf(client));\n  }\n};\nexport {\n  ClientArray,\n  ClientState,\n  Transport\n};\n", "// packages/core/src/serializer/SchemaSerializer.ts\nimport { Encoder, dumpChanges, Reflection } from \"@colyseus/schema\";\nimport { debugPatch } from \"../Debug.mjs\";\nimport { Protocol } from \"../Protocol.mjs\";\nimport { ClientState } from \"../Transport.mjs\";\nvar SHARED_VIEW = {};\nvar SchemaSerializer = class {\n  constructor() {\n    this.id = \"schema\";\n    this.hasFilters = false;\n    // flag to avoid re-encoding full state if no changes were made\n    this.needFullEncode = true;\n    // TODO: make this optional. allocating a new buffer for each room may not be always necessary.\n    this.fullEncodeBuffer = Buffer.allocUnsafe(Encoder.BUFFER_SIZE);\n    this.sharedOffsetCache = { offset: 0 };\n  }\n  reset(newState) {\n    this.encoder = new Encoder(newState);\n    this.hasFilters = this.encoder.context.hasFilters;\n    this.fullEncodeBuffer[0] = Protocol.ROOM_STATE;\n    if (this.hasFilters) {\n      this.views = /* @__PURE__ */ new Map();\n    }\n  }\n  getFullState(client) {\n    if (this.needFullEncode || this.encoder.root.changes.length > 0) {\n      this.sharedOffsetCache = { offset: 1 };\n      this.fullEncodeCache = this.encoder.encodeAll(this.sharedOffsetCache, this.fullEncodeBuffer);\n      this.needFullEncode = false;\n    }\n    if (this.hasFilters && client?.view) {\n      return this.encoder.encodeAllView(\n        client.view,\n        this.sharedOffsetCache.offset,\n        { ...this.sharedOffsetCache },\n        this.fullEncodeBuffer\n      );\n    } else {\n      return this.fullEncodeCache;\n    }\n  }\n  applyPatches(clients) {\n    let numClients = clients.length;\n    if (numClients == 0 || !this.encoder.hasChanges) {\n      return false;\n    }\n    this.needFullEncode = true;\n    if (debugPatch.enabled) {\n      debugPatch.dumpChanges = dumpChanges(this.encoder.state);\n    }\n    const it = { offset: 1 };\n    this.encoder.sharedBuffer[0] = Protocol.ROOM_STATE_PATCH;\n    const encodedChanges = this.encoder.encode(it);\n    if (!this.hasFilters) {\n      while (numClients--) {\n        const client = clients[numClients];\n        if (client.state !== ClientState.JOINED) {\n          continue;\n        }\n        client.raw(encodedChanges);\n      }\n    } else {\n      const sharedOffset = it.offset;\n      while (numClients--) {\n        const client = clients[numClients];\n        if (client.state !== ClientState.JOINED) {\n          continue;\n        }\n        const view = client.view || SHARED_VIEW;\n        let encodedView = this.views.get(view);\n        if (encodedView === void 0) {\n          encodedView = view === SHARED_VIEW ? encodedChanges : this.encoder.encodeView(client.view, sharedOffset, it);\n          this.views.set(view, encodedView);\n        }\n        client.raw(encodedView);\n      }\n      this.views.clear();\n    }\n    this.encoder.discardChanges();\n    if (debugPatch.enabled) {\n      debugPatch(\n        \"%d bytes sent to %d clients, %j\",\n        encodedChanges.length,\n        clients.length,\n        debugPatch.dumpChanges\n      );\n    }\n    return true;\n  }\n  handshake() {\n    if (!this.handshakeCache) {\n      this.handshakeCache = this.encoder.state && Reflection.encode(this.encoder);\n    }\n    return this.handshakeCache;\n  }\n};\nexport {\n  SchemaSerializer\n};\n", "// packages/core/src/errors/RoomExceptions.ts\nvar OnCreateException = class extends Error {\n  constructor(cause, message, options) {\n    super(message, { cause });\n    this.options = options;\n    this.name = \"OnCreateException\";\n  }\n};\nvar OnAuthException = class extends Error {\n  constructor(cause, message, client, options) {\n    super(message, { cause });\n    this.client = client;\n    this.options = options;\n    this.name = \"OnAuthException\";\n  }\n};\nvar OnJoinException = class extends Error {\n  constructor(cause, message, client, options, auth) {\n    super(message, { cause });\n    this.client = client;\n    this.options = options;\n    this.auth = auth;\n    this.name = \"OnJoinException\";\n  }\n};\nvar OnLeaveException = class extends Error {\n  constructor(cause, message, client, consented) {\n    super(message, { cause });\n    this.client = client;\n    this.consented = consented;\n    this.name = \"OnLeaveException\";\n  }\n};\nvar OnDisposeException = class extends Error {\n  constructor(cause, message) {\n    super(message, { cause });\n    this.name = \"OnDisposeException\";\n  }\n};\nvar OnMessageException = class extends Error {\n  constructor(cause, message, client, payload, type) {\n    super(message, { cause });\n    this.client = client;\n    this.payload = payload;\n    this.type = type;\n    this.name = \"OnMessageException\";\n  }\n};\nvar SimulationIntervalException = class extends Error {\n  constructor(cause, message) {\n    super(message, { cause });\n    this.name = \"SimulationIntervalException\";\n  }\n};\nvar TimedEventException = class extends Error {\n  constructor(cause, message, ...args) {\n    super(message, { cause });\n    this.name = \"TimedEventException\";\n    this.args = args;\n  }\n};\nexport {\n  OnAuthException,\n  OnCreateException,\n  OnDisposeException,\n  OnJoinException,\n  OnLeaveException,\n  OnMessageException,\n  SimulationIntervalException,\n  TimedEventException\n};\n", "// packages/core/src/presence/LocalPresence.ts\nimport fs from \"fs\";\nimport path from \"path\";\nimport { EventEmitter } from \"events\";\nimport { spliceOne } from \"../utils/Utils.mjs\";\nimport { isDevMode } from \"../utils/DevMode.mjs\";\nvar DEVMODE_CACHE_FILE_PATH = path.resolve(\".devmode.json\");\nvar LocalPresence = class {\n  constructor() {\n    this.channels = new EventEmitter();\n    this.data = {};\n    this.hash = {};\n    this.keys = {};\n    this.timeouts = {};\n    if (isDevMode && fs.existsSync(DEVMODE_CACHE_FILE_PATH)) {\n      const cache = fs.readFileSync(DEVMODE_CACHE_FILE_PATH).toString(\"utf-8\") || \"{}\";\n      const parsed = JSON.parse(cache);\n      if (parsed.data) {\n        this.data = parsed.data;\n      }\n      if (parsed.hash) {\n        this.hash = parsed.hash;\n      }\n      if (parsed.keys) {\n        this.keys = parsed.keys;\n      }\n    }\n  }\n  subscribe(topic, callback) {\n    this.channels.on(topic, callback);\n    return this;\n  }\n  unsubscribe(topic, callback) {\n    if (callback) {\n      this.channels.removeListener(topic, callback);\n    } else {\n      this.channels.removeAllListeners(topic);\n    }\n    return this;\n  }\n  publish(topic, data) {\n    this.channels.emit(topic, data);\n    return this;\n  }\n  async exists(key) {\n    return this.keys[key] !== void 0 || this.data[key] !== void 0 || this.hash[key] !== void 0;\n  }\n  set(key, value) {\n    this.keys[key] = value;\n  }\n  setex(key, value, seconds) {\n    this.keys[key] = value;\n    this.expire(key, seconds);\n  }\n  expire(key, seconds) {\n    if (this.timeouts[key]) {\n      clearTimeout(this.timeouts[key]);\n    }\n    this.timeouts[key] = setTimeout(() => {\n      delete this.keys[key];\n      delete this.timeouts[key];\n    }, seconds * 1e3);\n  }\n  get(key) {\n    return this.keys[key];\n  }\n  del(key) {\n    delete this.keys[key];\n    delete this.data[key];\n    delete this.hash[key];\n  }\n  sadd(key, value) {\n    if (!this.data[key]) {\n      this.data[key] = [];\n    }\n    if (this.data[key].indexOf(value) === -1) {\n      this.data[key].push(value);\n    }\n  }\n  async smembers(key) {\n    return this.data[key] || [];\n  }\n  async sismember(key, field) {\n    return this.data[key] && this.data[key].includes(field) ? 1 : 0;\n  }\n  srem(key, value) {\n    if (this.data[key]) {\n      spliceOne(this.data[key], this.data[key].indexOf(value));\n    }\n  }\n  scard(key) {\n    return (this.data[key] || []).length;\n  }\n  async sinter(...keys) {\n    const intersection = {};\n    for (let i = 0, l = keys.length; i < l; i++) {\n      (await this.smembers(keys[i])).forEach((member) => {\n        if (!intersection[member]) {\n          intersection[member] = 0;\n        }\n        intersection[member]++;\n      });\n    }\n    return Object.keys(intersection).reduce((prev, curr) => {\n      if (intersection[curr] > 1) {\n        prev.push(curr);\n      }\n      return prev;\n    }, []);\n  }\n  hset(key, field, value) {\n    if (!this.hash[key]) {\n      this.hash[key] = {};\n    }\n    this.hash[key][field] = value;\n  }\n  hincrby(key, field, incrBy) {\n    if (!this.hash[key]) {\n      this.hash[key] = {};\n    }\n    let value = Number(this.hash[key][field] || \"0\");\n    value += incrBy;\n    this.hash[key][field] = value.toString();\n    return value;\n  }\n  hincrbyex(key, field, incrBy, expireInSeconds) {\n    if (!this.hash[key]) {\n      this.hash[key] = {};\n    }\n    let value = Number(this.hash[key][field] || \"0\");\n    value += incrBy;\n    this.hash[key][field] = value.toString();\n    this.setex(key, field, expireInSeconds);\n    return value;\n  }\n  async hget(key, field) {\n    return this.hash[key] && this.hash[key][field];\n  }\n  async hgetall(key) {\n    return this.hash[key] || {};\n  }\n  hdel(key, field) {\n    const success = this.hash?.[key]?.[field] !== void 0;\n    if (success) {\n      delete this.hash[key][field];\n    }\n    return success;\n  }\n  async hlen(key) {\n    return this.hash[key] && Object.keys(this.hash[key]).length || 0;\n  }\n  async incr(key) {\n    if (!this.keys[key]) {\n      this.keys[key] = 0;\n    }\n    this.keys[key]++;\n    return Promise.resolve(this.keys[key]);\n  }\n  async decr(key) {\n    if (!this.keys[key]) {\n      this.keys[key] = 0;\n    }\n    this.keys[key]--;\n    return Promise.resolve(this.keys[key]);\n  }\n  llen(key) {\n    return this.data[key] && this.data[key].length || 0;\n  }\n  rpush(key, ...values) {\n    if (!this.data[key]) {\n      this.data[key] = [];\n    }\n    let lastLength = 0;\n    values.forEach((value) => {\n      lastLength = this.data[key].push(value);\n    });\n    return lastLength;\n  }\n  lpush(key, ...values) {\n    if (!this.data[key]) {\n      this.data[key] = [];\n    }\n    let lastLength = 0;\n    values.forEach((value) => {\n      lastLength = this.data[key].unshift(value);\n    });\n    return lastLength;\n  }\n  lpop(key) {\n    return Array.isArray(this.data[key]) && this.data[key].shift();\n  }\n  rpop(key) {\n    return this.data[key].pop();\n  }\n  brpop(...args) {\n    const keys = args.slice(0, -2);\n    const timeoutInSeconds = args[args.length - 1];\n    const getFirstPopulated = () => {\n      const keyWithValue = keys.find((key) => this.data[key] && this.data[key].length > 0);\n      if (keyWithValue) {\n        return [keyWithValue, this.data[keyWithValue].pop()];\n      } else {\n        return null;\n      }\n    };\n    const firstPopulated = getFirstPopulated();\n    if (firstPopulated) {\n      return Promise.resolve(firstPopulated);\n    } else {\n      const maxRetries = timeoutInSeconds * 8;\n      let tries = 0;\n      return new Promise((resolve) => {\n        const interval = setInterval(() => {\n          tries++;\n          const firstPopulated2 = getFirstPopulated();\n          if (firstPopulated2) {\n            clearInterval(interval);\n            return resolve(firstPopulated2);\n          } else if (tries >= maxRetries) {\n            clearInterval(interval);\n            return resolve(void 0);\n          }\n        }, timeoutInSeconds * 1e3 / maxRetries);\n      });\n    }\n  }\n  shutdown() {\n    if (isDevMode) {\n      const cache = JSON.stringify({\n        data: this.data,\n        hash: this.hash,\n        keys: this.keys\n      });\n      fs.writeFileSync(DEVMODE_CACHE_FILE_PATH, cache, { encoding: \"utf-8\" });\n    }\n  }\n};\nexport {\n  LocalPresence\n};\n", "// packages/core/src/Stats.ts\nimport { MatchMakerState, presence, processId, state } from \"./MatchMaker.mjs\";\nvar local = {\n  roomCount: 0,\n  ccu: 0\n};\nimport(\"@pm2/io\").then((io) => {\n  io.default.metric({ id: \"app/stats/ccu\", name: \"ccu\", value: () => local.ccu });\n  io.default.metric({ id: \"app/stats/roomcount\", name: \"roomcount\", value: () => local.roomCount });\n}).catch(() => {\n});\nasync function fetchAll() {\n  const allStats = [];\n  const allProcesses = await presence.hgetall(getRoomCountKey());\n  for (let remoteProcessId in allProcesses) {\n    if (remoteProcessId === processId) {\n      allStats.push({ processId, roomCount: local.roomCount, ccu: local.ccu });\n    } else {\n      const [roomCount, ccu] = allProcesses[remoteProcessId].split(\",\").map(Number);\n      allStats.push({ processId: remoteProcessId, roomCount, ccu });\n    }\n  }\n  return allStats;\n}\nvar lastPersisted = 0;\nvar persistTimeout = void 0;\nvar persistInterval = 1e3;\nfunction persist(forceNow = false) {\n  if (state === MatchMakerState.SHUTTING_DOWN) {\n    return;\n  }\n  const now = Date.now();\n  if (forceNow || now - lastPersisted > persistInterval) {\n    lastPersisted = now;\n    return presence.hset(getRoomCountKey(), processId, `${local.roomCount},${local.ccu}`);\n  } else {\n    clearTimeout(persistTimeout);\n    persistTimeout = setTimeout(persist, persistInterval);\n  }\n}\nfunction reset(_persist = true) {\n  local.roomCount = 0;\n  local.ccu = 0;\n  if (_persist) {\n    lastPersisted = 0;\n    clearTimeout(persistTimeout);\n    persist();\n  }\n}\nfunction excludeProcess(_processId) {\n  return presence.hdel(getRoomCountKey(), _processId);\n}\nasync function getGlobalCCU() {\n  const allStats = await fetchAll();\n  return allStats.reduce((prev, next) => prev + next.ccu, 0);\n}\nvar autoPersistInterval = void 0;\nfunction setAutoPersistInterval() {\n  const interval = 60 * 1e3;\n  autoPersistInterval = setInterval(() => {\n    const now = Date.now();\n    if (now - lastPersisted > interval) {\n      persist();\n    }\n  }, interval);\n}\nfunction clearAutoPersistInterval() {\n  clearInterval(autoPersistInterval);\n}\nfunction getRoomCountKey() {\n  return \"roomcount\";\n}\nexport {\n  clearAutoPersistInterval,\n  excludeProcess,\n  fetchAll,\n  getGlobalCCU,\n  local,\n  persist,\n  reset,\n  setAutoPersistInterval\n};\n", "// packages/core/src/rooms/RelayRoom.ts\nimport { defineTypes, MapSchema, Schema } from \"@colyseus/schema\";\nimport { Room } from \"../Room.mjs\";\nvar Player = class extends Schema {\n};\ndefineTypes(Player, {\n  connected: \"boolean\",\n  name: \"string\",\n  sessionId: \"string\"\n});\nvar State = class extends Schema {\n  constructor() {\n    super(...arguments);\n    // tslint:disable-line\n    this.players = new MapSchema();\n  }\n};\ndefineTypes(State, {\n  players: { map: Player }\n});\nvar RelayRoom = class extends Room {\n  constructor() {\n    super(...arguments);\n    // tslint:disable-line\n    this.allowReconnectionTime = 0;\n  }\n  onCreate(options) {\n    this.setState(new State());\n    if (options.maxClients) {\n      this.maxClients = options.maxClients;\n    }\n    if (options.allowReconnectionTime) {\n      this.allowReconnectionTime = Math.min(options.allowReconnectionTime, 40);\n    }\n    if (options.metadata) {\n      this.setMetadata(options.metadata);\n    }\n    this.onMessage(\"*\", (client, type, message) => {\n      this.broadcast(type, [client.sessionId, message], { except: client });\n    });\n  }\n  onJoin(client, options = {}) {\n    const player = new Player();\n    player.connected = true;\n    player.sessionId = client.sessionId;\n    if (options.name) {\n      player.name = options.name;\n    }\n    this.state.players.set(client.sessionId, player);\n  }\n  async onLeave(client, consented) {\n    if (this.allowReconnectionTime > 0) {\n      const player = this.state.players.get(client.sessionId);\n      player.connected = false;\n      try {\n        if (consented) {\n          throw new Error(\"consented leave\");\n        }\n        await this.allowReconnection(client, this.allowReconnectionTime);\n        player.connected = true;\n      } catch (e) {\n        this.state.players.delete(client.sessionId);\n      }\n    }\n  }\n};\nexport {\n  RelayRoom\n};\n", "//\r\n// Monkey-patch Colyseus' default behaviour\r\n//\r\nimport { Room, Client, ClientPrivate } from \"@colyseus/core\";\r\n\r\nfunction getStateSize(room) {\r\n    // TODO: `Serializer<T>` should provide a method for this (e.g. `serializer.hasState()`)\r\n    const hasState = (\r\n      room._serializer.encoder || // schema v3\r\n      room._serializer.state || // schema v2\r\n      room._serializer.previousState // legacy-fossil-delta\r\n    );\r\n    const fullState = hasState && room._serializer.getFullState();\r\n    return fullState && (fullState.byteLength || fullState.length) || 0;\r\n}\r\n\r\n(<any>Room.prototype).getAvailableData = function () {\r\n    return {\r\n        clients: this.clients.length,\r\n        maxClients: this.maxClients,\r\n        metadata: this.metadata,\r\n        roomId: this.roomId,\r\n    };\r\n};\r\n\r\n(<any>Room.prototype).getRoomListData = async function () {\r\n    const stateSize = getStateSize(this);\r\n    const elapsedTime = this.clock.elapsedTime;\r\n    const locked = this.locked;\r\n    const data = this.getAvailableData();\r\n\r\n    return { ...data, locked, elapsedTime, stateSize };\r\n};\r\n\r\n(<any>Room.prototype).getInspectData = async function () {\r\n    const state = this.state;\r\n    const stateSize = getStateSize(this);\r\n    const roomElapsedTime = this.clock.elapsedTime;\r\n\r\n    const data = this.getAvailableData();\r\n    const clients = this.clients.map((client: Client & ClientPrivate) => ({\r\n        sessionId: client.sessionId,\r\n        elapsedTime: roomElapsedTime - client._joinedAt\r\n    }));\r\n    const locked = this.locked;\r\n\r\n    return { ...data, locked, clients, state, stateSize };\r\n};\r\n\r\n// Actions\r\n(<any>Room.prototype)._forceClientDisconnect = async function (sessionId) {\r\n    for (let i = 0; i < this.clients.length; i++) {\r\n        if (this.clients[i].sessionId === sessionId) {\r\n            this.clients[i].leave();\r\n            break;\r\n        }\r\n    }\r\n};\r\n\r\n(<any>Room.prototype)._sendMessageToClient = async function (sessionId, type, data) {\r\n    for (let i = 0; i < this.clients.length; i++) {\r\n        if (this.clients[i].sessionId === sessionId) {\r\n            this.clients[i].send(type, data);\r\n            break;\r\n        }\r\n    }\r\n};\r\n"],
  "mappings": "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",
  "names": ["exports", "module", "type", "exports", "module", "setup", "debug", "exports", "module", "exports", "module", "exports", "module", "useColors", "debug", "exports", "module", "exports", "module", "exports", "module", "path", "exports", "module", "family", "version", "exports", "module", "path", "debug", "target", "dir", "platform", "arch", "runtime", "abi", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "exports", "module", "type", "string", "readObject", "readString", "type", "target", "saveState", "position", "bundledStrings", "referenceMap", "encodeUtf8", "string", "packr", "writeStruct", "pack", "type", "maxBytes", "key", "newPosition", "pack", "target", "targetView", "position", "type", "encode", "bundledStrings", "packr", "hasNodeBuffer", "textEncoder", "target", "string", "position", "prepareStructures", "pack", "packr", "targetView", "safeEnd", "number", "type", "onLoadedStructures", "readStruct", "src", "srcEnd", "dataView", "saveState", "OPERATION", "textEncoder", "_convoBuffer", "_int32", "_float32", "_float64", "_int64", "int8", "uint8", "int16", "uint16", "int32", "uint32", "int64", "uint64", "bigint64", "biguint64", "float32", "float64", "boolean", "string", "number", "encode", "decode", "target", "_a", "_b", "type", "encode", "decoder", "decode", "value", "index", "previousValue", "changeTree", "copy", "type", "target", "_a", "_b", "target", "_a", "type", "_b", "changeSet", "level", "target", "state", "_a", "_b", "encode", "Encoder", "Decoder", "decoder", "decode", "type", "reflectionType", "encode", "type", "debug", "import_events", "nanoid", "spliceOne", "import_debug", "debug", "state", "spliceOne", "Encoder", "type", "_a", "type", "target", "decode", "path", "state", "type"]
}
